<docs>
<doc name="T:PeterO.ArrayWriter">
<summary>An array of bytes that grows as needed.
    </summary>
</doc>
<doc name="M:PeterO.ArrayWriter.#ctor">
<summary>Initializes a new instance of the <see cref='T:PeterO.ArrayWriter'/> class with a default buffer size.
    </summary>
</doc>
<doc name="M:PeterO.ArrayWriter.#ctor(System.Int32)">
<summary>Initializes a new instance of the <see cref='T:PeterO.ArrayWriter'/> class with the given initial buffer size.
    </summary>
    <param name='initialSize'>The parameter
      <paramref name='initialSize'/>
       is a 32-bit signed integer.
    </param>
</doc>
<doc name="M:PeterO.ArrayWriter.Clear">
<summary>Offers a fast way to reset the length of the array writer's data to 0.
    </summary>
</doc>
<doc name="M:PeterO.ArrayWriter.ToArray">
<summary>Generates an array of all bytes written so far to it.
    </summary>
    <returns>A byte array.
    </returns>
</doc>
<doc name="M:PeterO.ArrayWriter.Write(System.Byte[],System.Int32,System.Int32)">
<summary>Writes a series of bytes to the array.
    </summary>
    <param name='src'>Byte array containing the data to write.
    </param>
    <param name='offset'>A zero-based index showing where the desired portion of
      <paramref name='src'/>
       begins.
    </param>
    <param name='length'>The number of elements in the desired portion of
      <paramref name='src'/>
       (but not more than
      <paramref name='src'/>
       's length).
    </param>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='src'/>
       is null.
    </exception>
    <exception cref='T:System.ArgumentException'>Either
      <paramref name='offset'/>
       or
      <paramref name='length'/>
       is less than 0 or greater than
      <paramref name='src'/>
       's length, or
      <paramref name='src'/>
       ' s length minus
      <paramref name='offset'/>
       is less than
      <paramref name='length'/>
       .
    </exception>
</doc>
<doc name="M:PeterO.ArrayWriter.WriteByte(System.Int32)">
<summary>Writes an 8-bit byte to the array.
    </summary>
    <param name='byteValue'>An integer containing the byte to write. Only the lower 8 bits of this
      value will be used.
    </param>
</doc>
<doc name="T:PeterO.Cbor.CBORDataUtilities">
<summary>Contains methods useful for reading and writing data, with a focus on
      CBOR.
    </summary>
</doc>
<doc name="M:PeterO.Cbor.CBORDataUtilities.ParseJSONNumber(System.String)">
<summary>Parses a number whose format follows the JSON specification. See
      #ParseJSONNumber(String, integersOnly, parseOnly) for more information.
    </summary>
    <param name='str'>A string to parse. The string is not allowed to contain white space
      characters, including spaces.
    </param>
    <returns>A CBOR object that represents the parsed number. Returns positive zero if
      the number is a zero that starts with a minus sign (such as "-0" or
      "-0.0"). Returns null if the parsing fails, including if the string is
      null or empty.
    </returns>
</doc>
<doc name="M:PeterO.Cbor.CBORDataUtilities.ParseJSONNumber(System.String,System.Boolean,System.Boolean)">
<summary>Parses a number whose format follows the JSON specification (RFC 8259).
      Roughly speaking, a valid number consists of an optional minus sign, one
      or more basic digits (starting with 1 to 9 unless the only digit is 0), an
      optional decimal point (".", full stop) with one or more basic digits, and
      an optional letter E or e with an optional plus or minus sign and one or
      more basic digits (the exponent).
    </summary>
    <param name='str'>A string to parse. The string is not allowed to contain white space
      characters, including spaces.
    </param>
    <param name='integersOnly'>If true, no decimal points or exponents are allowed in the string.
    </param>
    <param name='positiveOnly'>If true, only positive numbers are allowed (the leading minus is
      disallowed).
    </param>
    <returns>A CBOR object that represents the parsed number. Returns positive zero if
      the number is a zero that starts with a minus sign (such as "-0" or
      "-0.0"). Returns null if the parsing fails, including if the string is
      null or empty.
    </returns>
</doc>
<doc name="M:PeterO.Cbor.CBORDataUtilities.ParseJSONNumber(System.String,System.Boolean,System.Boolean,System.Boolean)">
<summary>Parses a number whose format follows the JSON specification (RFC 8259).
      Roughly speaking, a valid number consists of an optional minus sign, one
      or more basic digits (starting with 1 to 9 unless the only digit is 0), an
      optional decimal point (".", full stop) with one or more basic digits, and
      an optional letter E or e with an optional plus or minus sign and one or
      more basic digits (the exponent).
    </summary>
    <param name='str'>A string to parse. The string is not allowed to contain white space
      characters, including spaces.
    </param>
    <param name='integersOnly'>If true, no decimal points or exponents are allowed in the string.
    </param>
    <param name='positiveOnly'>If true, only positive numbers are allowed (the leading minus is
      disallowed).
    </param>
    <param name='preserveNegativeZero'>If true, returns positive zero if the number is a zero that starts with a
      minus sign (such as "-0" or "-0.0"). Otherwise, returns negative zero in
      this case.
    </param>
    <returns>A CBOR object that represents the parsed number. Returns null if the
      parsing fails, including if the string is null or empty.
    </returns>
</doc>
<doc name="T:PeterO.Cbor.URIUtility">
<summary>Contains utility methods for processing Uniform Resource Identifiers
      (URIs) and Internationalized Resource Identifiers (IRIs) under RFC3986 and
      RFC3987, respectively. In the following documentation, URIs and IRIs
      include URI references and IRI references, for convenience.
    </summary>
</doc>
<doc name="T:PeterO.Cbor.URIUtility.ParseMode">
<summary>Specifies whether certain characters are allowed when parsing IRIs and
      URIs.
    </summary>
</doc>
<doc name="F:PeterO.Cbor.URIUtility.ParseMode.IRILenient">
<summary>The rules only check for the appropriate delimiters when splitting the
      path, without checking if all the characters in each component are valid.
      Even with this mode, strings with unpaired surrogate code points are
      considered invalid.
    </summary>
</doc>
<doc name="F:PeterO.Cbor.URIUtility.ParseMode.IRIStrict">
<summary>The rules follow the syntax for parsing IRIs. In particular, many code
      points outside the Basic Latin range (U+0000 to U+007F) are allowed.
      Strings with unpaired surrogate code points are considered invalid.
    </summary>
</doc>
<doc name="F:PeterO.Cbor.URIUtility.ParseMode.IRISurrogateLenient">
<summary>The rules only check for the appropriate delimiters when splitting the
      path, without checking if all the characters in each component are valid.
      Unpaired surrogate code points are treated as though they were replacement
      characters instead for the purposes of these rules, so that strings with
      those code points are not considered invalid strings.
    </summary>
</doc>
<doc name="F:PeterO.Cbor.URIUtility.ParseMode.URILenient">
<summary>The rules only check for the appropriate delimiters when splitting the
      path, without checking if all the characters in each component are valid.
      Code points outside the Basic Latin range (U+0000 to U+007F) are not
      allowed.
    </summary>
</doc>
<doc name="F:PeterO.Cbor.URIUtility.ParseMode.URIStrict">
<summary>The rules follow the syntax for parsing IRIs, except that code points
      outside the Basic Latin range (U+0000 to U+007F) are not allowed.
    </summary>
</doc>
<doc name="M:PeterO.Cbor.URIUtility.escapeURI(System.String,System.Int32)">
<summary>Escapes characters that can't appear in URIs or IRIs. The function is
      idempotent; that is, calling the function again on the result with the
      same mode doesn't change the result.
    </summary>
    <param name='s'>A string to escape.
    </param>
    <param name='mode'>The parameter
      <paramref name='mode'/>
       is a 32-bit signed integer.
    </param>
    <returns>A string possibly containing escaped characters, or null if s is null.
    </returns>
</doc>
<doc name="M:PeterO.Cbor.URIUtility.hasScheme(System.String)">
<summary>Determines whether the string is a valid IRI with a scheme component. This
      can be used to check for relative IRI references.
      <para>The following cases return true:
      </para>
      <code>xx-x:mm example:/ww
      </code>
       The following cases return false:
      <code>x@y:/z /x/y/z example.xyz
      </code>
    </summary>
    <param name='refValue'>A string representing an IRI to check.
    </param>
    <returns><c>true</c>
       if the string is a valid IRI with a scheme component; otherwise, <c>false</c>
       .
    </returns>
</doc>
<doc name="M:PeterO.Cbor.URIUtility.hasSchemeForURI(System.String)">
<summary>Determines whether the string is a valid URI with a scheme component. This
      can be used to check for relative URI references. The following cases
      return true:
      <code>http://example/z xx-x:mm example:/ww
      </code>
       The following cases return false:
      <code>x@y:/z /x/y/z example.xyz
      </code>
    </summary>
    <param name='refValue'>A string representing an IRI to check.
    </param>
    <returns><c>true</c>
       if the string is a valid URI with a scheme component; otherwise, <c>false</c>
       .
    </returns>
</doc>
<doc name="M:PeterO.Cbor.URIUtility.isValidCurieReference(System.String,System.Int32,System.Int32)">
<summary>Determines whether the substring is a valid CURIE reference under RDFA
      1.1. (The CURIE reference is the part after the colon.).
    </summary>
    <param name='s'>A string containing a CURIE reference. Can be null.
    </param>
    <param name='offset'>A zero-based index showing where the desired portion of "s" begins.
    </param>
    <param name='length'>The number of elements in the desired portion of "s" (but not more than
      "s" 's length).
    </param>
    <returns><c>true</c>
       if the substring is a valid CURIE reference under RDFA 1; otherwise, <c>false</c>
       . Returns false if
      <paramref name='s'/>
       is null.
    </returns>
    <exception cref='T:System.ArgumentException'>Either
      <paramref name='offset'/>
       or
      <paramref name='length'/>
       is less than 0 or greater than
      <paramref name='s'/>
       's length, or
      <paramref name='s'/>
       ' s length minus
      <paramref name='offset'/>
       is less than
      <paramref name='length'/>
       .
    </exception>
</doc>
<doc name="M:PeterO.Cbor.URIUtility.relativeResolve(System.String,System.String)">
<summary>Resolves a URI or IRI relative to another URI or IRI.
    </summary>
    <param name='refValue'>A string representing a URI or IRI reference. Example:
      <c>dir/file.txt</c>
       .
    </param>
    <param name='baseURI'>A string representing an absolute URI reference. Example:
      <c>http://example.com/my/path/</c>
       .
    </param>
    <returns>The resolved IRI, or null if
      <paramref name='refValue'/>
       is null or is not a valid IRI. If
      <paramref name='baseURI'/>
       is null or is not a valid IRI, returns refValue. Example:
      <c>http://example.com/my/path/dir/file.txt</c>
       .
    </returns>
</doc>
<doc name="M:PeterO.Cbor.URIUtility.relativeResolve(System.String,System.String,PeterO.Cbor.URIUtility.ParseMode)">
<summary>Resolves a URI or IRI relative to another URI or IRI.
    </summary>
    <param name='refValue'>A string representing a URI or IRI reference. Example:
      <c>dir/file.txt</c>
       . Can be null.
    </param>
    <param name='baseURI'>A string representing an absolute URI reference. Example:
      <c>http://example.com/my/path/</c>
       .
    </param>
    <param name='parseMode'>Parse mode that specifies whether certain characters are allowed when
      parsing IRIs and URIs.
    </param>
    <returns>The resolved IRI, or null if
      <paramref name='refValue'/>
       is null or is not a valid IRI. If
      <paramref name='baseURI'/>
       is null or is not a valid IRI, returns refValue.
    </returns>
</doc>
<doc name="M:PeterO.Cbor.URIUtility.splitIRI(System.String)">
<summary>Parses an Internationalized Resource Identifier (IRI) reference under
      RFC3987. If the IRI reference is syntactically valid, splits the string
      into its components and returns an array containing the indices into the
      components.
    </summary>
    <param name='s'>A string that contains an IRI. Can be null.
    </param>
    <returns>If the string is a valid IRI reference, returns an array of 10 integers.
      Each of the five pairs corresponds to the start and end index of the IRI's
      scheme, authority, path, query, or fragment component, respectively. The
      scheme, authority, query, and fragment components, if present, will each
      be given without the ending colon, the starting "//", the starting "?",
      and the starting "#", respectively. If a component is absent, both indices
      in that pair will be -1. If the string is null or is not a valid IRI,
      returns null.
    </returns>
</doc>
<doc name="M:PeterO.Cbor.URIUtility.splitIRI(System.String,PeterO.Cbor.URIUtility.ParseMode)">
<summary>Parses an Internationalized Resource Identifier (IRI) reference under
      RFC3987. If the IRI is syntactically valid, splits the string into its
      components and returns an array containing the indices into the
      components.
    </summary>
    <param name='s'>A string representing an IRI. Can be null.
    </param>
    <param name='parseMode'>The parameter
      <paramref name='parseMode'/>
       is a ParseMode object.
    </param>
    <returns>If the string is a valid IRI reference, returns an array of 10 integers.
      Each of the five pairs corresponds to the start and end index of the IRI's
      scheme, authority, path, query, or fragment component, respectively. The
      scheme, authority, query, and fragment components, if present, will each
      be given without the ending colon, the starting "//", the starting "?",
      and the starting "#", respectively. If a component is absent, both indices
      in that pair will be -1. If the string is null or is not a valid IRI,
      returns null.
    </returns>
</doc>
<doc name="M:PeterO.Cbor.URIUtility.splitIRI(System.String,System.Int32,System.Int32,PeterO.Cbor.URIUtility.ParseMode)">
<summary>Parses a substring that represents an Internationalized Resource
      Identifier (IRI) under RFC3987. If the IRI is syntactically valid, splits
      the string into its components and returns an array containing the indices
      into the components.
    </summary>
    <param name='s'>A string that contains an IRI. Can be null.
    </param>
    <param name='offset'>A zero-based index showing where the desired portion of "s" begins.
    </param>
    <param name='length'>The length of the desired portion of "s" (but not more than "s" 's
      length).
    </param>
    <param name='parseMode'>Parse mode that specifies whether certain characters are allowed when
      parsing IRIs and URIs.
    </param>
    <returns>If the string is a valid IRI, returns an array of 10 integers. Each of the
      five pairs corresponds to the start and end index of the IRI's scheme,
      authority, path, query, or fragment component, respectively. The scheme,
      authority, query, and fragment components, if present, will each be given
      without the ending colon, the starting "//", the starting "?", and the
      starting "#", respectively. If a component is absent, both indices in that
      pair will be -1 (an index won't be less than 0 in any other case). If the
      string is null or is not a valid IRI, returns null.
    </returns>
    <exception cref='T:System.ArgumentException'>Either
      <paramref name='offset'/>
       or
      <paramref name='length'/>
       is less than 0 or greater than
      <paramref name='s'/>
       's length, or
      <paramref name='s'/>
       ' s length minus
      <paramref name='offset'/>
       is less than
      <paramref name='length'/>
       .
    </exception>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='s'/>
       is null.
    </exception>
</doc>
<doc name="T:PeterO.DataUtilities">
<summary>Contains methods useful for reading and writing strings. It is designed to
      have no dependencies other than the basic runtime class library.
      <para>Many of these methods work with text encoded in UTF-8, an encoding form
        of the Unicode Standard which uses one byte to encode the most basic
        characters and two to four bytes to encode other characters. For
        example, the
        <c>GetUtf8</c>
         method converts a text string to an array of bytes in UTF-8.
      </para>
      <para>In C# and Java, text strings are represented as sequences of 16-bit
        values called
        <c>char</c>
         s. These sequences are well-formed under UTF-16, a 16-bit encoding form
        of Unicode, except if they contain unpaired surrogate code points. (A
        surrogate code point is used to encode supplementary characters, those
        with code points U+10000 or higher, in UTF-16. A surrogate pair is a
        high surrogate [U+D800 to U+DBFF] followed by a low surrogate [U+DC00 to
        U+DFFF]. An unpaired surrogate code point is a surrogate not appearing
        in a surrogate pair.) Many of the methods in this class allow setting
        the behavior to follow when unpaired surrogate code points are found in
        text strings, such as throwing an error or treating the unpaired
        surrogate as a replacement character (U+FFFD).
      </para>
    </summary>
</doc>
<doc name="M:PeterO.DataUtilities.CodePointAt(System.String,System.Int32)">
<summary>Gets the Unicode code point at the given index of the string.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
    <param name='index'>Index of the current position into the string.
    </param>
    <returns>The Unicode code point at the given position. Returns -1 if
      <paramref name='index'/>
       is less than 0, or is the string's length or greater. Returns the
      replacement character (U+FFFD) if the current character is an unpaired
      surrogate code point.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       is null.
    </exception>
</doc>
<doc name="M:PeterO.DataUtilities.CodePointAt(System.String,System.Int32,System.Int32)">
<summary>Gets the Unicode code point at the given index of the string.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
    <param name='index'>Index of the current position into the string.
    </param>
    <param name='surrogateBehavior'>Specifies what kind of value to return if the previous character is an
      unpaired surrogate code point: if 0, return the replacement character
      (U+FFFD); if 1, return the value of the surrogate code point; if neither 0
      nor 1, return -1.
    </param>
    <returns>The Unicode code point at the current position. Returns -1 if
      <paramref name='index'/>
       is less than 0, or is the string's length or greater. Returns a value as
      specified under
      <paramref name='surrogateBehavior'/>
       if the previous character is an unpaired surrogate code point.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       is null.
    </exception>
</doc>
<doc name="M:PeterO.DataUtilities.CodePointBefore(System.String,System.Int32)">
<summary>Gets the Unicode code point just before the given index of the string.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
    <param name='index'>Index of the current position into the string.
    </param>
    <returns>The Unicode code point at the previous position. Returns -1 if
      <paramref name='index'/>
       is 0 or less, or is greater than the string's length. Returns the
      replacement character (U+FFFD) if the previous character is an unpaired
      surrogate code point.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       is null.
    </exception>
</doc>
<doc name="M:PeterO.DataUtilities.CodePointBefore(System.String,System.Int32,System.Int32)">
<summary>Gets the Unicode code point just before the given index of the string.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
    <param name='index'>Index of the current position into the string.
    </param>
    <param name='surrogateBehavior'>Specifies what kind of value to return if the previous character is an
      unpaired surrogate code point: if 0, return the replacement character
      (U+FFFD); if 1, return the value of the surrogate code point; if neither 0
      nor 1, return -1.
    </param>
    <returns>The Unicode code point at the previous position. Returns -1 if
      <paramref name='index'/>
       is 0 or less, or is greater than the string's length. Returns a value as
      specified under
      <paramref name='surrogateBehavior'/>
       if the previous character is an unpaired surrogate code point.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       is null.
    </exception>
</doc>
<doc name="M:PeterO.DataUtilities.CodePointCompare(System.String,System.String)">
<summary>Compares two strings in Unicode code point order. Unpaired surrogate code
      points are treated as individual code points.
    </summary>
    <param name='strA'>The first string. Can be null.
    </param>
    <param name='strB'>The second string. Can be null.
    </param>
    <returns>A value indicating which string is " less" or " greater" . 0: Both strings
      are equal or null. Less than 0: a is null and b isn't; or the first code
      point that's different is less in A than in B; or b starts with a and is
      longer than a. Greater than 0: b is null and a isn't; or the first code
      point that's different is greater in A than in B; or a starts with b and
      is longer than b.
    </returns>
</doc>
<doc name="M:PeterO.DataUtilities.GetUtf8Bytes(System.String,System.Boolean)">
<summary>Encodes a string in UTF-8 as a byte array.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
    <param name='replace'>If true, replaces unpaired surrogate code points with the replacement
      character (U+FFFD). If false, stops processing when an unpaired surrogate
      code point is seen.
    </param>
    <returns>The string encoded in UTF-8.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       is null.
    </exception>
    <exception cref='T:System.ArgumentException'>The string contains an unpaired surrogate code point and
      <paramref name='replace'/>
       is false, or an internal error occurred.
    </exception>
</doc>
<doc name="M:PeterO.DataUtilities.GetUtf8Bytes(System.String,System.Boolean,System.Boolean)">
<summary>Encodes a string in UTF-8 as a byte array.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
    <param name='replace'>If true, replaces unpaired surrogate code points with the replacement
      character (U+FFFD). If false, stops processing when an unpaired surrogate
      code point is seen.
    </param>
    <param name='lenientLineBreaks'>If true, replaces carriage return (CR) not followed by line feed (LF) and
      LF not preceded by CR with CR-LF pairs.
    </param>
    <returns>The string encoded in UTF-8.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       is null.
    </exception>
    <exception cref='T:System.ArgumentException'>The string contains an unpaired surrogate code point and
      <paramref name='replace'/>
       is false, or an internal error occurred.
    </exception>
</doc>
<doc name="M:PeterO.DataUtilities.GetUtf8Length(System.String,System.Boolean)">
<summary>Calculates the number of bytes needed to encode a string in UTF-8.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
    <param name='replace'>If true, treats unpaired surrogate code points as having 3 UTF-8 bytes
      (the UTF-8 length of the replacement character U+FFFD).
    </param>
    <returns>The number of bytes needed to encode the given string in UTF-8, or -1 if
      the string contains an unpaired surrogate code point and
      <paramref name='replace'/>
       is false.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       is null.
    </exception>
</doc>
<doc name="M:PeterO.DataUtilities.GetUtf8String(System.Byte[],System.Boolean)">
<summary>Generates a text string from a UTF-8 byte array.
    </summary>
    <param name='bytes'>A byte array containing text encoded in UTF-8.
    </param>
    <param name='replace'>If true, replaces invalid encoding with the replacement character
      (U+FFFD). If false, stops processing when invalid UTF-8 is seen.
    </param>
    <returns>A string represented by the UTF-8 byte array.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='bytes'/>
       is null.
    </exception>
    <exception cref='T:System.ArgumentException'>The string is not valid UTF-8 and
      <paramref name='replace'/>
       is false.
    </exception>
</doc>
<doc name="M:PeterO.DataUtilities.GetUtf8String(System.Byte[],System.Int32,System.Int32,System.Boolean)">
<summary>Generates a text string from a portion of a UTF-8 byte array.
    </summary>
    <param name='bytes'>A byte array containing text encoded in UTF-8.
    </param>
    <param name='offset'>Offset into the byte array to start reading.
    </param>
    <param name='bytesCount'>Length, in bytes, of the UTF-8 string.
    </param>
    <param name='replace'>If true, replaces invalid encoding with the replacement character
      (U+FFFD). If false, stops processing when invalid UTF-8 is seen.
    </param>
    <returns>A string represented by the UTF-8 byte array.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='bytes'/>
       is null.
    </exception>
    <exception cref='T:System.ArgumentException'>The portion of the byte array is not valid UTF-8 and
      <paramref name='replace'/>
       is false.
    </exception>
    <exception cref='T:System.ArgumentException'>The parameter
      <paramref name='offset'/>
       is less than 0,
      <paramref name='bytesCount'/>
       is less than 0, or offset plus bytesCount is greater than the length of
      "data" .
    </exception>
</doc>
<doc name="M:PeterO.DataUtilities.ReadUtf8(System.IO.Stream,System.Int32,System.Text.StringBuilder,System.Boolean)">
<summary>Reads a string in UTF-8 encoding from a data stream.
    </summary>
    <param name='stream'>A readable data stream.
    </param>
    <param name='bytesCount'>The length, in bytes, of the string. If this is less than 0, this function
      will read until the end of the stream.
    </param>
    <param name='builder'>A string builder object where the resulting string will be stored.
    </param>
    <param name='replace'>If true, replaces invalid encoding with the replacement character
      (U+FFFD). If false, stops processing when an unpaired surrogate code point
      is seen.
    </param>
    <returns>0 if the entire string was read without errors, -1 if the string is not
      valid UTF-8 and
      <paramref name='replace'/>
       is false, or -2 if the end of the stream was reached before the last
      character was read completely (which is only the case if
      <paramref name='bytesCount'/>
       is 0 or greater).
    </returns>
    <exception cref='T:System.IO.IOException'>An I/O error occurred.
    </exception>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='stream'/>
       is null or
      <paramref name='builder'/>
       is null.
    </exception>
</doc>
<doc name="M:PeterO.DataUtilities.ReadUtf8FromBytes(System.Byte[],System.Int32,System.Int32,System.Text.StringBuilder,System.Boolean)">
<summary>Reads a string in UTF-8 encoding from a byte array.
    </summary>
    <param name='data'>A byte array containing a UTF-8 string.
    </param>
    <param name='offset'>Offset into the byte array to start reading.
    </param>
    <param name='bytesCount'>Length, in bytes, of the UTF-8 string.
    </param>
    <param name='builder'>A string builder object where the resulting string will be stored.
    </param>
    <param name='replace'>If true, replaces invalid encoding with the replacement character
      (U+FFFD). If false, stops processing when invalid UTF-8 is seen.
    </param>
    <returns>0 if the entire string was read without errors, or -1 if the string is not
      valid UTF-8 and
      <paramref name='replace'/>
       is false.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='data'/>
       is null or
      <paramref name='builder'/>
       is null.
    </exception>
    <exception cref='T:System.ArgumentException'>The parameter
      <paramref name='offset'/>
       is less than 0,
      <paramref name='bytesCount'/>
       is less than 0, or offset plus bytesCount is greater than the length of
      <paramref name='data'/>
       .
    </exception>
</doc>
<doc name="M:PeterO.DataUtilities.ReadUtf8ToString(System.IO.Stream)">
<summary>Reads a string in UTF-8 encoding from a data stream in full and returns
      that string. Replaces invalid encoding with the replacement character
      (U+FFFD).
    </summary>
    <param name='stream'>A readable data stream.
    </param>
    <returns>The string read.
    </returns>
    <exception cref='T:System.IO.IOException'>An I/O error occurred.
    </exception>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='stream'/>
       is null.
    </exception>
</doc>
<doc name="M:PeterO.DataUtilities.ReadUtf8ToString(System.IO.Stream,System.Int32,System.Boolean)">
<summary>Reads a string in UTF-8 encoding from a data stream and returns that
      string.
    </summary>
    <param name='stream'>A readable data stream.
    </param>
    <param name='bytesCount'>The length, in bytes, of the string. If this is less than 0, this function
      will read until the end of the stream.
    </param>
    <param name='replace'>If true, replaces invalid encoding with the replacement character
      (U+FFFD). If false, throws an error if an unpaired surrogate code point is
      seen.
    </param>
    <returns>The string read.
    </returns>
    <exception cref='T:System.IO.IOException'>An I/O error occurred; or, the string is not valid UTF-8 and
      <paramref name='replace'/>
       is false.
    </exception>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='stream'/>
       is null.
    </exception>
</doc>
<doc name="M:PeterO.DataUtilities.ToLowerCaseAscii(System.String)">
<summary>Returns a string with the basic upper-case letters A to Z (U+0041 to
      U+005A) converted to lower-case. Other characters remain unchanged.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
    <returns>The converted string, or null if
      <paramref name='str'/>
       is null.
    </returns>
</doc>
<doc name="M:PeterO.DataUtilities.ToUpperCaseAscii(System.String)">
<summary>Returns a string with the basic lower-case letters A to Z (U+0061 to
      U+007A) converted to upper-case. Other characters remain unchanged.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
    <returns>The converted string, or null if
      <paramref name='str'/>
       is null.
    </returns>
</doc>
<doc name="M:PeterO.DataUtilities.WriteUtf8(System.String,System.IO.Stream,System.Boolean)">
<summary>Writes a string in UTF-8 encoding to a data stream.
    </summary>
    <param name='str'>A string to write.
    </param>
    <param name='stream'>A writable data stream.
    </param>
    <param name='replace'>If true, replaces unpaired surrogate code points with the replacement
      character (U+FFFD). If false, stops processing when an unpaired surrogate
      code point is seen.
    </param>
    <returns>0 if the entire string was written; or -1 if the string contains an
      unpaired surrogate code point and
      <paramref name='replace'/>
       is false.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       is null or
      <paramref name='stream'/>
       is null.
    </exception>
    <exception cref='T:System.IO.IOException'>An I/O error occurred.
    </exception>
</doc>
<doc name="M:PeterO.DataUtilities.WriteUtf8(System.String,System.Int32,System.Int32,System.IO.Stream,System.Boolean)">
<summary>Writes a portion of a string in UTF-8 encoding to a data stream.
    </summary>
    <param name='str'>A string to write.
    </param>
    <param name='offset'>The zero-based index where the string portion to write begins.
    </param>
    <param name='length'>The length of the string portion to write.
    </param>
    <param name='stream'>A writable data stream.
    </param>
    <param name='replace'>If true, replaces unpaired surrogate code points with the replacement
      character (U+FFFD). If false, stops processing when an unpaired surrogate
      code point is seen.
    </param>
    <returns>0 if the entire string portion was written; or -1 if the string portion
      contains an unpaired surrogate code point and
      <paramref name='replace'/>
       is false.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       is null or
      <paramref name='stream'/>
       is null.
    </exception>
    <exception cref='T:System.ArgumentException'>The parameter
      <paramref name='offset'/>
       is less than 0,
      <paramref name='length'/>
       is less than 0, or
      <paramref name='offset'/>
       plus
      <paramref name='length'/>
       is greater than the string's length.
    </exception>
    <exception cref='T:System.IO.IOException'>An I/O error occurred.
    </exception>
</doc>
<doc name="M:PeterO.DataUtilities.WriteUtf8(System.String,System.Int32,System.Int32,System.IO.Stream,System.Boolean,System.Boolean)">
<summary>Writes a portion of a string in UTF-8 encoding to a data stream.
    </summary>
    <param name='str'>A string to write.
    </param>
    <param name='offset'>The zero-based index where the string portion to write begins.
    </param>
    <param name='length'>The length of the string portion to write.
    </param>
    <param name='stream'>A writable data stream.
    </param>
    <param name='replace'>If true, replaces unpaired surrogate code points with the replacement
      character (U+FFFD). If false, stops processing when an unpaired surrogate
      code point is seen.
    </param>
    <param name='lenientLineBreaks'>If true, replaces carriage return (CR) not followed by line feed (LF) and
      LF not preceded by CR with CR-LF pairs.
    </param>
    <returns>0 if the entire string portion was written; or -1 if the string portion
      contains an unpaired surrogate code point and
      <paramref name='replace'/>
       is false.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       is null or
      <paramref name='stream'/>
       is null.
    </exception>
    <exception cref='T:System.ArgumentException'>The parameter
      <paramref name='offset'/>
       is less than 0,
      <paramref name='length'/>
       is less than 0, or
      <paramref name='offset'/>
       plus
      <paramref name='length'/>
       is greater than the string's length.
    </exception>
    <exception cref='T:System.IO.IOException'>An I/O error occurred.
    </exception>
</doc>
<doc name="T:PeterO.Numbers.EContext">

            <summary>Contains parameters for controlling the precision, rounding, and exponent
      range of arbitrary-precision numbers. (The "E" stands for "extended", and
      has this prefix to group it with the other classes common to this library,
      particularly EDecimal, EFloat, and ERational.).
      <para><b>Thread safety:</b>
         With one exception, instances of this class are immutable and are safe
        to use among multiple threads. The one exception involves the
        <c>Flags</c>
         property. If the context's
        <c>HasFlags</c>
         property (a read-only property) is
        <c>true</c>
         , the
        <c>Flags</c>
         property is mutable, thus making the context mutable. This class
        doesn't synchronize access to such mutable contexts, so applications
        should provide their own synchronization if a context with the
        <c>HasFlags</c>
         property set to
        <c>true</c>
         will be shared among multiple threads and at least one of those threads
        needs to write the
        <c>Flags</c>
         property (which can happen, for example, by passing the context to most
        methods of
        <c>EDecimal</c>
         such as
        <c>Add</c>
         ).
      </para>
    </summary>

</doc>
<doc name="M:PeterO.Numbers.EContext.#ctor(System.Int32,PeterO.Numbers.ERounding,System.Int32,System.Int32,System.Boolean)">

            <summary>Initializes a new instance of the <see cref='T:PeterO.Numbers.EContext'/> class.
      <c>HasFlags</c>
       will be set to false.
    </summary><param name='precision'>The maximum number of digits a number can have, or 0 for an unlimited
      number of digits.
    </param><param name='rounding'>The rounding mode to use when a number can't fit the given precision.
    </param><param name='exponentMinSmall'>The minimum exponent.
    </param><param name='exponentMaxSmall'>The maximum exponent.
    </param><param name='clampNormalExponents'>Whether to clamp a number's significand to the given maximum precision (if
      it isn't zero) while remaining within the exponent range.
    </param>

</doc>
<doc name="P:PeterO.Numbers.EContext.AdjustExponent">

            <summary>Gets a value indicating whether the EMax and EMin properties refer to the
      number's Exponent property adjusted to the number's precision, or just the
      number's Exponent property. The default value is true, meaning that EMax
      and EMin refer to the adjusted exponent. Setting this value to false
      (using WithAdjustExponent) is useful for modeling floating point
      representations with an integer mantissa (significand) and an integer
      exponent, such as Java's BigDecimal.
    </summary><value><c>true</c>
       if the EMax and EMin properties refer to the number's Exponent property
      adjusted to the number's precision, or just the number's Exponent
      property; otherwise, <c>false</c>
       .. The default value is true, meaning that EMax and EMin refer to the
      adjusted exponent. Setting this value to false (using WithAdjustExponent)
      is useful for modeling floating point representations with an integer
      mantissa (significand) and an integer exponent, such as Java's BigDecimal.

      <c>true</c>
       if the EMax and EMin properties refer to the number's Exponent property
      adjusted to the number's precision, or false if they refer to just the
      number's Exponent property.
    </value>

</doc>
<doc name="F:PeterO.Numbers.EContext.Basic">

            <summary>A basic arithmetic context, 9 digits precision, rounding mode half-up,
      unlimited exponent range. The default rounding mode is HalfUp.
    </summary>

</doc>
<doc name="F:PeterO.Numbers.EContext.BigDecimalJava">

            <summary>An arithmetic context for Java's BigDecimal format. The default rounding
      mode is HalfUp.
    </summary>

</doc>
<doc name="F:PeterO.Numbers.EContext.Binary128">

            <summary>An arithmetic context for the IEEE-754-2008 binary128 format, 113 bits
      precision. The default rounding mode is HalfEven.
    </summary>

</doc>
<doc name="F:PeterO.Numbers.EContext.Binary16">

            <summary>An arithmetic context for the IEEE-754-2008 binary16 format, 11 bits
      precision. The default rounding mode is HalfEven.
    </summary>

</doc>
<doc name="F:PeterO.Numbers.EContext.Binary32">

            <summary>An arithmetic context for the IEEE-754-2008 binary32 format, 24 bits
      precision. The default rounding mode is HalfEven.
    </summary>

</doc>
<doc name="F:PeterO.Numbers.EContext.Binary64">

            <summary>An arithmetic context for the IEEE-754-2008 binary64 format, 53 bits
      precision. The default rounding mode is HalfEven.
    </summary>

</doc>
<doc name="P:PeterO.Numbers.EContext.ClampNormalExponents">

            <summary>Gets a value indicating whether a converted number's Exponent property
      will not be higher than EMax + 1 - Precision. If a number's exponent is
      higher than that value, but not high enough to cause overflow, the
      exponent is clamped to that value and enough zeros are added to the
      number's mantissa (significand) to account for the adjustment. If
      HasExponentRange is false, this value is always false.
    </summary><value>If true, a converted number's Exponent property will not be higher than
      EMax + 1 - Precision.
    </value>

</doc>
<doc name="F:PeterO.Numbers.EContext.CliDecimal">

            <summary>An arithmetic context for the .NET Framework decimal format (see
      <see cref='T:PeterO.Numbers.EDecimal'>
         "Forms of numbers"
      </see>
       ), 96 bits precision, and a valid exponent range of -28 to 0. The default
      rounding mode is HalfEven. (The
      <c>"Cli"</c>
       stands for "Common Language Infrastructure", which defined this format as
      the .NET Framework decimal format in version 1, but leaves it unspecified
      in later versions.).
    </summary>

</doc>
<doc name="M:PeterO.Numbers.EContext.Copy">

            <summary>Initializes a new EContext that is a copy of another EContext.
    </summary><returns>A context object for arbitrary-precision arithmetic settings.
    </returns>

</doc>
<doc name="F:PeterO.Numbers.EContext.Decimal128">

            <summary>An arithmetic context for the IEEE-754-2008 decimal128 format. The
      default rounding mode is HalfEven.
    </summary>

</doc>
<doc name="F:PeterO.Numbers.EContext.Decimal32">

            <summary>An arithmetic context for the IEEE-754-2008 decimal32 format. The default
      rounding mode is HalfEven.
    </summary>

</doc>
<doc name="F:PeterO.Numbers.EContext.Decimal64">

            <summary>An arithmetic context for the IEEE-754-2008 decimal64 format. The default
      rounding mode is HalfEven.
    </summary>

</doc>
<doc name="P:PeterO.Numbers.EContext.EMax">

            <summary>Gets the highest exponent possible when a converted number is expressed
      in scientific notation with one digit before the radix point. For example,
      with a precision of 3 and an EMax of 100, the maximum value possible is
      9.99E + 100. (This is not the same as the highest possible Exponent
      property.) If HasExponentRange is false, this value will be 0.
    </summary><value>The highest exponent possible when a converted number is expressed in
      scientific notation with one digit before the radix point. For example,
      with a precision of 3 and an EMax of 100, the maximum value possible is
      9.99E + 100. (This is not the same as the highest possible Exponent
      property.) If HasExponentRange is false, this value will be 0.
    </value>

</doc>
<doc name="P:PeterO.Numbers.EContext.EMin">

            <summary>Gets the lowest exponent possible when a converted number is expressed in
      scientific notation with one digit before the radix point. For example,
      with a precision of 3 and an EMin of -100, the next value that comes after
      0 is 0.001E-100. (If AdjustExponent is false, this property specifies the
      lowest possible Exponent property instead.) If HasExponentRange is false,
      this value will be 0.
    </summary><value>The lowest exponent possible when a converted number is expressed in
      scientific notation with one digit before the radix point. For example,
      with a precision of 3 and an EMin of -100, the next value that comes after
      0 is 0.001E-100. (If AdjustExponent is false, this property specifies the
      lowest possible Exponent property instead.) If HasExponentRange is false,
      this value will be 0.
    </value>

</doc>
<doc name="M:PeterO.Numbers.EContext.ExponentWithinRange(PeterO.Numbers.EInteger)">

            <summary>Determines whether a number can have the given Exponent property under
      this arithmetic context.
    </summary><param name='exponent'>An arbitrary-precision integer indicating the desired exponent.
    </param><returns><c>true</c>
       if a number can have the given Exponent property under this arithmetic
      context; otherwise, <c>false</c>
       . If this context allows unlimited precision, returns true for the
      exponent EMax and any exponent less than EMax.
    </returns><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='exponent'/>
       is null.
    </exception>

</doc>
<doc name="F:PeterO.Numbers.EContext.FlagClamped">

            <summary>Signals that the exponent was adjusted to fit the exponent range.
    </summary>

</doc>
<doc name="F:PeterO.Numbers.EContext.FlagDivideByZero">

            <summary>Signals a division of a nonzero number by zero.
    </summary>

</doc>
<doc name="F:PeterO.Numbers.EContext.FlagInexact">

            <summary>Signals that the result was rounded to a different mathematical value,
      but as close as possible to the original.
    </summary>

</doc>
<doc name="F:PeterO.Numbers.EContext.FlagInvalid">

            <summary>Signals an invalid operation.
    </summary>

</doc>
<doc name="F:PeterO.Numbers.EContext.FlagLostDigits">

            <summary>Signals that an operand was rounded to a different mathematical value
      before an operation.
    </summary>

</doc>
<doc name="F:PeterO.Numbers.EContext.FlagOverflow">

            <summary>Signals that the result is non-zero and the exponent is higher than the
      highest exponent allowed.
    </summary>

</doc>
<doc name="F:PeterO.Numbers.EContext.FlagRounded">

            <summary>Signals that the result was rounded to fit the precision; either the
      value or the exponent may have changed from the original.
    </summary>

</doc>
<doc name="F:PeterO.Numbers.EContext.FlagSubnormal">

            <summary>Signals that the result's exponent, before rounding, is lower than the
      lowest exponent allowed.
    </summary>

</doc>
<doc name="F:PeterO.Numbers.EContext.FlagUnderflow">

            <summary>Signals that the result's exponent, before rounding, is lower than the
      lowest exponent allowed, and the result was rounded to a different
      mathematical value, but as close as possible to the original.
    </summary>

</doc>
<doc name="P:PeterO.Numbers.EContext.Flags">

            <summary>Gets or sets the flags that are set from converting numbers according to
      this arithmetic context. If
      <c>HasFlags</c>
       is false, this value will be 0. This value is a combination of bit
      fields. To retrieve a particular flag, use the AND operation on the return
      value of this method. For example:
      <c>(this.Flags &amp; EContext.FlagInexact) != 0</c>
       returns
      <c>true</c>
       if the Inexact flag is set.
    </summary><value>The flags that are set from converting numbers according to this
      arithmetic context. If
      <c>HasFlags</c>
       is false, this value will be 0. This value is a combination of bit
      fields. To retrieve a particular flag, use the AND operation on the return
      value of this method. For example:
      <c>(this.Flags &amp; EContext.FlagInexact) != 0</c>
       returns
      <c>true</c>
       if the Inexact flag is set.
    </value>

</doc>
<doc name="M:PeterO.Numbers.EContext.ForPrecision(System.Int32)">

            <summary>Creates a new arithmetic context using the given maximum number of
      digits, an unlimited exponent range, and the HalfUp rounding mode.
    </summary><param name='precision'>Maximum number of digits (precision).
    </param><returns>A context object for arbitrary-precision arithmetic settings.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EContext.ForPrecisionAndRounding(System.Int32,PeterO.Numbers.ERounding)">

            <summary>Creates a new EContext object initialized with an unlimited exponent
      range, and the given rounding mode and maximum precision.
    </summary><param name='precision'>Maximum number of digits (precision).
    </param><param name='rounding'>The parameter
      <paramref name='rounding'/>
       is an ERounding object.
    </param><returns>A context object for arbitrary-precision arithmetic settings.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EContext.ForRounding(PeterO.Numbers.ERounding)">

            <summary>Creates a new EContext object initialized with an unlimited precision, an
      unlimited exponent range, and the given rounding mode.
    </summary><param name='rounding'>The rounding mode for the new precision context.
    </param><returns>A context object for arbitrary-precision arithmetic settings.
    </returns>

</doc>
<doc name="P:PeterO.Numbers.EContext.HasExponentRange">

            <summary>Gets a value indicating whether this context defines a minimum and
      maximum exponent. If false, converted exponents can have any exponent and
      operations can't cause overflow or underflow.
    </summary><value><c>true</c>
       if this context defines a minimum and maximum exponent; otherwise, <c>false</c>
       .. If false, converted exponents can have any exponent and operations
      can't cause overflow or underflow.
      <c>true</c>
       if this context defines a minimum and maximum exponent; otherwise, <c>false</c>
       .
    </value>

</doc>
<doc name="P:PeterO.Numbers.EContext.HasFlags">

            <summary>Gets a value indicating whether this context has a mutable Flags field.
    </summary><value><c>true</c>
       if this context has a mutable Flags field; otherwise, <c>false</c>
       .
    </value>

</doc>
<doc name="P:PeterO.Numbers.EContext.HasMaxPrecision">

            <summary>Gets a value indicating whether this context defines a maximum precision.

    </summary><value><c>true</c>
       if this context defines a maximum precision; otherwise, <c>false</c>
       .
    </value>

</doc>
<doc name="P:PeterO.Numbers.EContext.IsPrecisionInBits">

            <summary>Gets a value indicating whether this context's Precision property is in
      bits, rather than digits. The default is false.
    </summary><value><c>true</c>
       if this context's Precision property is in bits, rather than digits; otherwise, <c>false</c>
       .. The default is false.
      <c>true</c>
       if this context's Precision property is in bits, rather than digits; otherwise, <c>false</c>
       . The default is false.
    </value>

</doc>
<doc name="P:PeterO.Numbers.EContext.IsSimplified">

            <summary>Gets a value indicating whether to use a "simplified" arithmetic. In the
      simplified arithmetic, infinity, not-a-number, and subnormal numbers are
      not allowed, and negative zero is treated the same as positive zero. For
      further details, see
      <a href='http://speleotrove.com/decimal/dax3274.html'>
        <c>http://speleotrove.com/decimal/dax3274.html</c>
      </a>
    </summary><value><c>true</c>
       if to use a "simplified" arithmetic; otherwise, <c>false</c>
       .. In the simplified arithmetic, infinity, not-a-number, and subnormal
      numbers are not allowed, and negative zero is treated the same as positive
      zero. For further details, see
      <a href='http://speleotrove.com/decimal/dax3274.html'>
        <c>http://speleotrove.com/decimal/dax3274.html</c>
      </a>
       .
      <c>true</c>
       if a "simplified" arithmetic will be used; otherwise, <c>false</c>
       .
    </value>

</doc>
<doc name="P:PeterO.Numbers.EContext.Precision">

            <summary>Gets the maximum length of a converted number in digits, ignoring the
      radix point and exponent. For example, if precision is 3, a converted
      number's mantissa (significand) can range from 0 to 999 (up to three
      digits long). If 0, converted numbers can have any precision.
    </summary><value>The maximum length of a converted number in digits, ignoring the radix
      point and exponent. For example, if precision is 3, a converted number's
      mantissa (significand) can range from 0 to 999 (up to three digits long).
      If 0, converted numbers can have any precision.
    </value>

</doc>
<doc name="P:PeterO.Numbers.EContext.Rounding">

            <summary>Gets the desired rounding mode when converting numbers that can't be
      represented in the given precision and exponent range.
    </summary><value>The desired rounding mode when converting numbers that can't be
      represented in the given precision and exponent range.
    </value>

</doc>
<doc name="M:PeterO.Numbers.EContext.ToString">

            <summary>Gets a string representation of this object. Note that the string's
      format is not intended to be parsed and may change at any time.
    </summary><returns>A string representation of this object.
    </returns>

</doc>
<doc name="P:PeterO.Numbers.EContext.Traps">

            <summary>Gets the traps that are set for each flag in the context. Whenever a flag
      is signaled, even if
      <c>HasFlags</c>
       is false, and the flag's trap is enabled, the operation will throw a
      TrapException.
      <para>For example, if Traps equals
        <c>FlagInexact</c>
         and FlagSubnormal, a TrapException will be thrown if an operation's
        return value is not the same as the exact result (FlagInexact) or if the
        return value's exponent is lower than the lowest allowed
        (FlagSubnormal).
      </para>
    </summary><value>The traps that are set for each flag in the context. Whenever a flag is
      signaled, even if
      <c>HasFlags</c>
       is false, and the flag's trap is enabled, the operation will throw a
      TrapException.
      <para>For example, if Traps equals
        <c>FlagInexact</c>
         and FlagSubnormal, a TrapException will be thrown if an operation's
        return value is not the same as the exact result (FlagInexact) or if the
        return value's exponent is lower than the lowest allowed
        (FlagSubnormal).
      </para>
       .
    </value>

</doc>
<doc name="F:PeterO.Numbers.EContext.Unlimited">

            <summary>No specific (theoretical) limit on precision. Rounding mode HalfUp.
    </summary>

</doc>
<doc name="F:PeterO.Numbers.EContext.UnlimitedHalfEven">

            <summary>No specific (theoretical) limit on precision. Rounding mode HalfEven.
    </summary>

</doc>
<doc name="M:PeterO.Numbers.EContext.WithAdjustExponent(System.Boolean)">

            <summary>Copies this EContext and sets the copy's "AdjustExponent" property to the
      given value.
    </summary><param name='adjustExponent'>The new value of the "AdjustExponent" property for the copy.
    </param><returns>A context object for arbitrary-precision arithmetic settings.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EContext.WithBigExponentRange(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">

            <summary>Copies this arithmetic context and sets the copy's exponent range.
    </summary><param name='exponentMin'>Desired minimum exponent (EMin).
    </param><param name='exponentMax'>Desired maximum exponent (EMax).
    </param><returns>A context object for arbitrary-precision arithmetic settings.
    </returns><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='exponentMin'/>
       is null.
    </exception><exception cref='T:System.ArgumentException'>"ExponentMin greater than exponentMax".
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EContext.WithBigPrecision(PeterO.Numbers.EInteger)">

            <summary>Copies this EContext and gives it a particular precision value.
    </summary><param name='bigintPrecision'>Desired precision. 0 means unlimited precision.
    </param><returns>A context object for arbitrary-precision arithmetic settings.
    </returns><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='bigintPrecision'/>
       is null.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EContext.WithBlankFlags">

            <summary>Copies this EContext with
      <c>HasFlags</c>
       set to true and a Flags value of 0.
    </summary><returns>A context object for arbitrary-precision arithmetic settings.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EContext.WithExponentClamp(System.Boolean)">

            <summary>Copies this arithmetic context and sets the copy's "ClampNormalExponents"
      flag to the given value.
    </summary><param name='clamp'>The desired value of the "ClampNormalExponents" flag.
    </param><returns>A context object for arbitrary-precision arithmetic settings.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EContext.WithExponentRange(System.Int32,System.Int32)">

            <summary>Copies this arithmetic context and sets the copy's exponent range.
    </summary><param name='exponentMinSmall'>Desired minimum exponent (EMin).
    </param><param name='exponentMaxSmall'>Desired maximum exponent (EMax).
    </param><returns>A context object for arbitrary-precision arithmetic settings.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EContext.WithNoFlags">

            <summary>Copies this EContext with
      <c>HasFlags</c>
       set to false and a Flags value of 0.
    </summary><returns>A context object for arbitrary-precision arithmetic settings.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EContext.WithPrecision(System.Int32)">

            <summary>Copies this EContext and gives it a particular precision value.
    </summary><param name='precision'>Desired precision. 0 means unlimited precision.
    </param><returns>A context object for arbitrary-precision arithmetic settings.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EContext.WithPrecisionInBits(System.Boolean)">

            <summary>Copies this EContext and sets the copy's "IsPrecisionInBits" property to
      the given value.
    </summary><param name='isPrecisionBits'>The new value of the "IsPrecisionInBits" property for the copy.
    </param><returns>A context object for arbitrary-precision arithmetic settings.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EContext.WithRounding(PeterO.Numbers.ERounding)">

            <summary>Copies this EContext with the specified rounding mode.
    </summary><param name='rounding'>Desired value of the Rounding property.
    </param><returns>A context object for arbitrary-precision arithmetic settings.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EContext.WithSimplified(System.Boolean)">

            <summary>Copies this EContext and sets the copy's "IsSimplified" property to the
      given value.
    </summary><param name='simplified'>Desired value of the IsSimplified property.
    </param><returns>A context object for arbitrary-precision arithmetic settings.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EContext.WithTraps(System.Int32)">

            <summary>Copies this EContext with Traps set to the given value.
    </summary><param name='traps'>Flags representing the traps to enable. See the property "Traps".
    </param><returns>A context object for arbitrary-precision arithmetic settings.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EContext.WithUnlimitedExponents">

            <summary>Copies this EContext with an unlimited exponent range.
    </summary><returns>A context object for arbitrary-precision arithmetic settings.
    </returns>

</doc>
<doc name="T:PeterO.Numbers.EDecimal">

            <summary>Represents an arbitrary-precision decimal floating-point number. (The "E"
      stands for "extended", meaning that instances of this class can be values
      other than numbers proper, such as infinity and not-a-number.)
      <para><b>About decimal arithmetic</b>
      </para>
      <para>Decimal (base-10) arithmetic, such as that provided by this class, is
        appropriate for calculations involving such real-world data as prices
        and other sums of money, tax rates, and measurements. These calculations
        often involve multiplying or dividing one decimal with another decimal,
        or performing other operations on decimal numbers. Many of these
        calculations also rely on rounding behavior in which the result after
        rounding is a decimal number (for example, multiplying a price by a
        premium rate, then rounding, should result in a decimal amount of
        money).
      </para>
      <para>On the other hand, most implementations of
        <c>float</c>
         and
        <c>double</c>
         , including in C# and Java, store numbers in a binary (base-2)
        floating-point format and use binary floating-point arithmetic. Many
        decimal numbers can't be represented exactly in binary floating-point
        format (regardless of its length). Applying binary arithmetic to numbers
        intended to be decimals can sometimes lead to unintuitive results, as is
        shown in the description for the FromDouble() method of this class.
      </para>
      <para><b>About EDecimal instances</b>
      </para>
      <para>Each instance of this class consists of an integer mantissa
        (significand) and an integer exponent, both arbitrary-precision. The
        value of the number equals mantissa (significand) * 10^exponent.
      </para>
      <para>The mantissa (significand) is the value of the digits that make up a
        number, ignoring the decimal point and exponent. For example, in the
        number 2356.78, the mantissa (significand) is 235678. The exponent is
        where the "floating" decimal point of the number is located. A positive
        exponent means "move it to the right", and a negative exponent means
        "move it to the left." In the example 2, 356.78, the exponent is -2,
        since it has 2 decimal places and the decimal point is "moved to the
        left by 2." Therefore, in the arbitrary-precision decimal
        representation, this number would be stored as 235678 * 10^-2.
      </para>
      <para>The mantissa (significand) and exponent format preserves trailing zeros
        in the number's value. This may give rise to multiple ways to store the
        same value. For example, 1.00 and 1 would be stored differently, even
        though they have the same value. In the first case, 100 * 10^-2 (100
        with decimal point moved left by 2), and in the second case, 1 * 10^0 (1
        with decimal point moved 0).
      </para>
      <para>This class also supports values for negative zero, not-a-number (NaN)
        values, and infinity.
        <b>Negative zero</b>
         is generally used when a negative number is rounded to 0; it has the
        same mathematical value as positive zero.
        <b>Infinity</b>
         is generally used when a non-zero number is divided by zero, or when a
        very high or very low number can't be represented in a given exponent
        range.
        <b>Not-a-number</b>
         is generally used to signal errors.
      </para>
      <para>This class implements the General Decimal Arithmetic Specification
        version 1.70 (except part of chapter 6):
        <c>http://speleotrove.com/decimal/decarith.html</c>
      </para>
      <para><b>Errors and Exceptions</b>
      </para>
      <para>Passing a signaling NaN to any arithmetic operation shown here will
        signal the flag FlagInvalid and return a quiet NaN, even if another
        operand to that operation is a quiet NaN, unless noted otherwise.
      </para>
      <para>Passing a quiet NaN to any arithmetic operation shown here will return
        a quiet NaN, unless noted otherwise. Invalid operations will also return
        a quiet NaN, as stated in the individual methods.
      </para>
      <para>Unless noted otherwise, passing a null arbitrary-precision decimal
        argument to any method here will throw an exception.
      </para>
      <para>When an arithmetic operation signals the flag FlagInvalid,
        FlagOverflow, or FlagDivideByZero, it will not throw an exception too,
        unless the flag's trap is enabled in the arithmetic context (see
        EContext's Traps property).
      </para>
      <para>If an operation requires creating an intermediate value that might be
        too big to fit in memory (or might require more than 2 gigabytes of
        memory to store -- due to the current use of a 32-bit integer internally
        as a length), the operation may signal an invalid-operation flag and
        return not-a-number (NaN). In certain rare cases, the CompareTo method
        may throw OutOfMemoryException (called OutOfMemoryError in Java) in the
        same circumstances.
      </para>
      <para><b>Serialization</b>
      </para>
      <para>An arbitrary-precision decimal value can be serialized (converted to a
        stable format) in one of the following ways:
      </para>
      <list>
        <item>By calling the toString() method, which will always return distinct
          strings for distinct arbitrary-precision decimal values.
        </item>
        <item>By calling the UnsignedMantissa, Exponent, and IsNegative properties,
          and calling the IsInfinity, IsQuietNaN, and IsSignalingNaN methods.
          The return values combined will uniquely identify a particular
          arbitrary-precision decimal value.
        </item>
      </list>
      <para><b>Thread safety</b>
      </para>
      <para>Instances of this class are immutable, so they are inherently safe for
        use by multiple threads. Multiple instances of this object with the same
        properties are interchangeable, so they should not be compared using the
        "==" operator (which might only check if each side of the operator is
        the same instance).
      </para>
      <para><b>Comparison considerations</b>
      </para>
      <para>This class's natural ordering (under the CompareTo method) is not
        consistent with the Equals method. This means that two values that
        compare as equal under the CompareTo method might not be equal under the
        Equals method. The CompareTo method compares the mathematical values of
        the two instances passed to it (and considers two different NaN values
        as equal), while two instances with the same mathematical value, but
        different exponents, will be considered unequal under the Equals method.

      </para>
      <para><b>Security note</b>
      </para>
      <para>It is not recommended to implement security-sensitive algorithms using
        the methods in this class, for several reasons:
      </para>
      <list>
        <item><c>EDecimal</c>
           objects are immutable, so they can't be modified, and the memory they
          occupy is not guaranteed to be cleared in a timely fashion due to
          garbage collection. This is relevant for applications that use
          many-digit-long numbers as secret parameters.
        </item>
        <item>The methods in this class (especially those that involve arithmetic)
          are not guaranteed to run in constant time for all relevant inputs.
          Certain attacks that involve encrypted communications have exploited
          the timing and other aspects of such communications to derive keying
          material or cleartext indirectly.
        </item>
      </list>
      <para>Applications should instead use dedicated security libraries to handle big numbers in security-sensitive algorithms.
      </para>
      <para><b>Forms of numbers</b>
      </para>
      <para>There are several other types of numbers that are mentioned in this
        class and elsewhere in this documentation. For reference, they are
        specified here.
      </para>
      <para><b>Unsigned integer</b>
         : An integer that's always 0 or greater, with the following maximum
        values:
      </para>
      <list>
        <item>8-bit unsigned integer, or
          <i>
             byte
          </i>
           : 255.
        </item>
        <item>16-bit unsigned integer: 65535.
        </item>
        <item>32-bit unsigned integer: (2
          <sup>
             32
          </sup>
           -1).
        </item>
        <item>64-bit unsigned integer: (2
          <sup>
             64
          </sup>
           -1).
        </item>
      </list>
      <para><b>Signed integer</b>
         : An integer in
        <i>
           two's-complement form
        </i>
         , with the following ranges:
      </para>
      <list>
        <item>8-bit signed integer: -128 to 127.
        </item>
        <item>16-bit signed integer: -32768 to 32767.
        </item>
        <item>32-bit signed integer: -2
          <sup>
             31
          </sup>
           to (2
          <sup>
             31
          </sup>
           - 1).
        </item>
        <item>64-bit signed integer: -2
          <sup>
             63
          </sup>
           to (2
          <sup>
             63
          </sup>
           - 1).
        </item>
      </list>
      <para><b>Two's complement form</b>
         : In
        <i>
           two' s-complement form
        </i>
         , nonnegative numbers have the highest (most significant) bit set to
        zero, and negative numbers have that bit (and all bits beyond) set to
        one, and a negative number is stored in such form by decreasing its
        absolute value by 1 and swapping the bits of the resulting number.
      </para>
      <para><b>64-bit floating-point number</b>
         : A 64-bit binary floating-point number, in the form
        <i>
           significand
        </i>
         * 2
        <sup>
          <i>
             exponent
          </i>
        </sup>
         . The significand is 53 bits long (Precision) and the exponent ranges
        from -1074 (EMin) to 971 (EMax). The number is stored in the following
        format (commonly called the IEEE 754 format):
      </para>
      <code>|C|BBB...BBB|AAAAAA...AAAAAA|
      </code>
      <list>
        <item>A. Low 52 bits (Precision minus 1 bits): Lowest bits of the
          significand.
        </item>
        <item>B. Next 11 bits: Exponent area:
          <list>
            <item>If all bits are ones, this value is infinity if all bits in area
              A are zeros, or not-a-number (NaN) otherwise.
            </item>
            <item>If all bits are zeros, this is a subnormal number. The exponent
              is EMin and the highest bit of the significand is zero.
            </item>
            <item>If any other number, the exponent is this value reduced by 1,
              then raised by EMin, and the highest bit of the significand is
              one.
            </item>
          </list>
        </item>
        <item>C. Highest bit: If one, this is a negative number.
        </item>
      </list>
      <para>The elements described above are in the same order as the order of each
        bit of each element, that is, either most significant first or least
        significant first.
      </para>
      <para><b>32-bit binary floating-point number</b>
         : A 32-bit binary number which is stored similarly to a
        <i>
           64-bit floating-point number
        </i>
         , except that:
      </para>
      <list>
        <item>Precision is 24 bits.
        </item>
        <item>EMin is -149.
        </item>
        <item>EMax is 104.
        </item>
        <item>A. The low 23 bits (Precision minus 1 bits) are the lowest bits of
          the significand.
        </item>
        <item>B. The next 8 bits are the exponent area.
        </item>
        <item>C. If the highest bit is one, this is a negative number.
        </item>
      </list>
      <para><b>.NET Framework decimal</b>
         : A 128-bit decimal floating-point number, in the form
        <i>
           significand
        </i>
         * 10
        <sup>
           -
          <i>
             scale
          </i>
        </sup>
         , where the scale ranges from 0 to 28. The number is stored in the
        following format:
      </para>
      <list>
        <item>Low 96 bits are the significand, as a 96-bit unsigned integer (all
          96-bit values are allowed, up to (2
          <sup>
             96
          </sup>
           -1)).
        </item>
        <item>Next 16 bits are unused.
        </item>
        <item>Next 8 bits are the scale, stored as an 8-bit unsigned integer.
        </item>
        <item>Next 7 bits are unused.
        </item>
        <item>If the highest bit is one, it's a negative number.
        </item>
      </list>
      <para>The elements described above are in the same order as the order of each
        bit of each element, that is, either most significant first or least
        significant first.
      </para>
    </summary>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.Abs">

            <summary>Finds the absolute value of this object (if it's negative, it becomes
      positive).
    </summary><returns>An arbitrary-precision decimal number. Returns signaling NaN if this
      value is signaling NaN.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.Abs(PeterO.Numbers.EContext)">

            <summary>Finds the absolute value of this object (if it's negative, it becomes
      positive).
    </summary><param name='context'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and no rounding is needed.
    </param><returns>The absolute value of this object. Signals FlagInvalid and returns quiet
      NaN if this value is signaling NaN.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.Add(PeterO.Numbers.EDecimal)">

            <summary>Adds this object and another decimal number and returns the result.
    </summary><param name='otherValue'>An arbitrary-precision decimal number.
    </param><returns>The sum of the two objects.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.Add(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">

            <summary>Finds the sum of this object and another object. The result's exponent is
      set to the lower of the exponents of the two operands.
    </summary><param name='otherValue'>The number to add to.
    </param><param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and no rounding is needed.
    </param><returns>The sum of thisValue and the other object.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.CompareTo(PeterO.Numbers.EDecimal)">
<summary>Compares the mathematical values of this object and another object,
      accepting NaN values.
      <para>This method is not consistent with the Equals method because two
        different numbers with the same mathematical value, but different
        exponents, will compare as equal.
      </para>
      <para>In this method, negative zero and positive zero are considered equal.
      </para>
      <para>If this object or the other object is a quiet NaN or signaling NaN, this
        method will not trigger an error. Instead, NaN will compare greater than
        any other number, including infinity. Two different NaN values will be
        considered equal.
      </para>
    </summary>
    <param name='other'>An arbitrary-precision decimal number.
    </param>
    <returns>Less than 0 if this object's value is less than the other value, or
      greater than 0 if this object's value is greater than the other value or
      if &#x22;other&#x22; is null, or 0 if both values are equal.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.EDecimal.CompareToBinary(PeterO.Numbers.EFloat)">

            <summary>Compares an arbitrary-precision binary float with this instance.
    </summary><param name='other'>The other object to compare. Can be null.
    </param><returns>Zero if the values are equal; a negative number if this instance is less,
      or a positive number if this instance is greater. Returns 0 if both values
      are NaN (even signaling NaN) and 1 if this value is NaN (even signaling
      NaN) and the other isn't, or if the other value is null.
    </returns><exception cref='T:System.ArgumentException'>Doesn't satisfy this.IsFinite; doesn't satisfy other.IsFinite.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.CompareToSignal(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">

            <summary>Compares the mathematical values of this object and another object,
      treating quiet NaN as signaling.
      <para>In this method, negative zero and positive zero are considered equal.
      </para>
      <para>If this object or the other object is a quiet NaN or signaling NaN,
        this method will return a quiet NaN and will signal a FlagInvalid flag.
      </para>
    </summary><param name='other'>An arbitrary-precision decimal number.
    </param><param name='ctx'>An arithmetic context. The precision, rounding, and exponent range are
      ignored. If
      <c>HasFlags</c>
       of the context is true, will store the flags resulting from the operation
      (the flags are in addition to the pre-existing flags). Can be null.
    </param><returns>Quiet NaN if this object or the other object is NaN, or 0 if both objects
      have the same value, or -1 if this object is less than the other value, or
      1 if this object is greater.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.CompareToTotal(PeterO.Numbers.EDecimal)">

            <summary>Compares the values of this object and another object, imposing a total
      ordering on all possible values. In this method:
      <list>
        <item>For objects with the same value, the one with the higher exponent has
          a greater "absolute value".
        </item>
        <item>Negative zero is less than positive zero.
        </item>
        <item>Quiet NaN has a higher "absolute value" than signaling NaN. If both
          objects are quiet NaN or both are signaling NaN, the one with the
          higher diagnostic information has a greater "absolute value".
        </item>
        <item>NaN has a higher "absolute value" than infinity.
        </item>
        <item>Infinity has a higher "absolute value" than any finite number.
        </item>
        <item>Negative numbers are less than positive numbers.
        </item>
      </list>
    </summary><param name='other'>An arbitrary-precision decimal number to compare with this one.
    </param><returns>The number 0 if both objects have the same value, or -1 if this object is
      less than the other value, or 1 if this object is greater.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.CompareToTotal(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">

            <summary>Compares the values of this object and another object, imposing a total
      ordering on all possible values. In this method:
      <list>
        <item>For objects with the same value, the one with the higher exponent has
          a greater "absolute value".
        </item>
        <item>Negative zero is less than positive zero.
        </item>
        <item>Quiet NaN has a higher "absolute value" than signaling NaN. If both
          objects are quiet NaN or both are signaling NaN, the one with the
          higher diagnostic information has a greater "absolute value".
        </item>
        <item>NaN has a higher "absolute value" than infinity.
        </item>
        <item>Infinity has a higher "absolute value" than any finite number.
        </item>
        <item>Negative numbers are less than positive numbers.
        </item>
      </list>
    </summary><param name='other'>An arbitrary-precision decimal number to compare with this one.
    </param><param name='ctx'>An arithmetic context. Flags will be set in this context only if
      <c>HasFlags</c>
       and
      <c>IsSimplified</c>
       of the context are true and only if an operand needed to be rounded
      before carrying out the operation. Can be null.
    </param><returns>The number 0 if both objects have the same value, or -1 if this object is
      less than the other value, or 1 if this object is greater. Does not signal
      flags if either value is signaling NaN.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.CompareToTotalMagnitude(PeterO.Numbers.EDecimal)">

            <summary>Compares the absolute values of this object and another object, imposing
      a total ordering on all possible values (ignoring their signs). In this
      method:
      <list>
        <item>For objects with the same value, the one with the higher exponent has
          a greater "absolute value".
        </item>
        <item>Negative zero and positive zero are considered equal.
        </item>
        <item>Quiet NaN has a higher "absolute value" than signaling NaN. If both
          objects are quiet NaN or both are signaling NaN, the one with the
          higher diagnostic information has a greater "absolute value".
        </item>
        <item>NaN has a higher "absolute value" than infinity.
        </item>
        <item>Infinity has a higher "absolute value" than any finite number.
        </item>
      </list>
    </summary><param name='other'>An arbitrary-precision decimal number to compare with this one.
    </param><returns>The number 0 if both objects have the same value, or -1 if this object is
      less than the other value, or 1 if this object is greater.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.CompareToWithContext(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">

            <summary>Compares the mathematical values of this object and another object.
      <para>In this method, negative zero and positive zero are considered equal.
      </para>
      <para>If this object or the other object is a quiet NaN or signaling NaN,
        this method returns a quiet NaN, and will signal a FlagInvalid flag if
        either is a signaling NaN.
      </para>
    </summary><param name='other'>An arbitrary-precision decimal number.
    </param><param name='ctx'>An arithmetic context. The precision, rounding, and exponent range are
      ignored. If
      <c>HasFlags</c>
       of the context is true, will store the flags resulting from the operation
      (the flags are in addition to the pre-existing flags). Can be null.
    </param><returns>Quiet NaN if this object or the other object is NaN, or 0 if both objects
      have the same value, or -1 if this object is less than the other value, or
      1 if this object is greater.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.CopySign(PeterO.Numbers.EDecimal)">
<summary>Returns a number with the same value as this one, but copying the sign
      (positive or negative) of another number.
    </summary>
    <param name='other'>A number whose sign will be copied.
    </param>
    <returns>An arbitrary-precision decimal number.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter &#x22;other&#x22; is null.
    </exception>
</doc>
<doc name="M:PeterO.Numbers.EDecimal.Create(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">
<summary>Creates a number with the value
      <c>exponent*10^mantissa</c>
    </summary>
    <param name='mantissa'>Desired value for the mantissa.
    </param>
    <param name='exponent'>Desired value for the exponent.
    </param>
    <returns>An arbitrary-precision decimal number.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter &#x22;mantissa&#x22; or &#x22;exponent&#x22; is null.
    </exception>
</doc>
<doc name="M:PeterO.Numbers.EDecimal.Create(System.Int32,System.Int32)">

            <summary>Creates a number with the value
      <c>exponent*10^mantissa</c>
    </summary><param name='mantissaSmall'>Desired value for the mantissa.
    </param><param name='exponentSmall'>Desired value for the exponent.
    </param><returns>An arbitrary-precision decimal number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.CreateNaN(PeterO.Numbers.EInteger)">

            <summary>Creates a not-a-number arbitrary-precision decimal number.
    </summary><param name='diag'>A number to use as diagnostic information associated with this object. If
      none is needed, should be zero.
    </param><returns>A quiet not-a-number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.CreateNaN(PeterO.Numbers.EInteger,System.Boolean,System.Boolean,PeterO.Numbers.EContext)">
<summary>Creates a not-a-number arbitrary-precision decimal number.
    </summary>
    <param name='diag'>A number to use as diagnostic information associated with this object. If
      none is needed, should be zero.
    </param>
    <param name='signaling'>Whether the return value will be signaling (true) or quiet (false).
    </param>
    <param name='negative'>Whether the return value is negative.
    </param>
    <param name='ctx'>An arithmetic context to control the precision (in decimal digits) of the
      diagnostic information. The rounding and exponent range of this context
      will be ignored. Can be null. The only flag that can be signaled in this
      context is FlagInvalid, which happens if diagnostic information needs to
      be truncated and too much memory is required to do so.
    </param>
    <returns>An arbitrary-precision decimal number.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter &#x22;diag&#x22; is null or is less than 0.
    </exception>
</doc>
<doc name="M:PeterO.Numbers.EDecimal.DecimalMathHelper.CreateNewWithFlags(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger,System.Int32)">

            <summary>This is an internal method.
    </summary><param name='mantissa'>The parameter
      <paramref name='mantissa'/>
       is an internal parameter.
    </param><param name='exponent'>The parameter
      <paramref name='exponent'/>
       is an internal parameter.
    </param><param name='flags'>The parameter
      <paramref name='flags'/>
       is an internal parameter.
    </param><returns>An arbitrary-precision decimal number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.DecimalMathHelper.CreateShiftAccumulator(PeterO.Numbers.EInteger)">

            <summary>This is an internal method.
    </summary><param name='bigint'>An arbitrary-precision integer.
    </param><returns>An IShiftAccumulator object.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.DecimalMathHelper.GetArithmeticSupport">

            <summary>This is an internal method.
    </summary><returns>A 32-bit signed integer.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.DecimalMathHelper.GetExponent(PeterO.Numbers.EDecimal)">

            <summary>This is an internal method.
    </summary><param name='value'>An arbitrary-precision decimal number.
    </param><returns>An arbitrary-precision integer.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.DecimalMathHelper.GetFlags(PeterO.Numbers.EDecimal)">

            <summary>This is an internal method.
    </summary><param name='value'>An arbitrary-precision decimal number.
    </param><returns>A 32-bit signed integer.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.DecimalMathHelper.GetMantissa(PeterO.Numbers.EDecimal)">

            <summary>This is an internal method.
    </summary><param name='value'>An arbitrary-precision decimal number.
    </param><returns>An arbitrary-precision integer.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.DecimalMathHelper.GetRadix">

            <summary>This is an internal method.
    </summary><returns>A 32-bit signed integer.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.DecimalMathHelper.GetSign(PeterO.Numbers.EDecimal)">

            <summary>This is an internal method.
    </summary><param name='value'>An arbitrary-precision decimal number.
    </param><returns>A 32-bit signed integer.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.DecimalMathHelper.ValueOf(System.Int32)">

            <summary>This is an internal method.
    </summary><param name='val'>The parameter
      <paramref name='val'/>
       is a 32-bit signed integer.
    </param><returns>An arbitrary-precision decimal number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.DivRemNaturalScale(PeterO.Numbers.EDecimal)">

            <summary>Calculates the quotient and remainder using the
      DivideToIntegerNaturalScale and the formula in RemainderNaturalScale.
    </summary><param name='divisor'>The number to divide by.
    </param><returns>A 2 element array consisting of the quotient and remainder in that order.

    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.DivRemNaturalScale(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">

            <summary>Calculates the quotient and remainder using the
      DivideToIntegerNaturalScale and the formula in RemainderNaturalScale.
    </summary><param name='divisor'>The number to divide by.
    </param><param name='ctx'>An arithmetic context object to control the precision, rounding, and
      exponent range of the result. This context will be used only in the
      division portion of the remainder calculation; as a result, it's possible
      for the remainder to have a higher precision than given in this context.
      Flags will be set on the given context only if the context's
      <c>HasFlags</c>
       is true and the integer part of the division result doesn't fit the
      precision and exponent range without rounding. Can be null, in which the
      precision is unlimited and no additional rounding, other than the rounding
      down to an integer after division, is needed.
    </param><returns>A 2 element array consisting of the quotient and remainder in that order.

    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.Divide(PeterO.Numbers.EDecimal)">

            <summary>Divides this object by another decimal number and returns the result.
      When possible, the result will be exact.
    </summary><param name='divisor'>The number to divide by.
    </param><returns>The quotient of the two numbers. Returns infinity if the divisor is 0 and
      the dividend is nonzero. Returns not-a-number (NaN) if the divisor and the
      dividend are 0. Returns NaN if the result can't be exact because it would
      have a nonterminating decimal expansion.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.Divide(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">

            <summary>Divides this arbitrary-precision decimal number by another
      arbitrary-precision decimal number. The preferred exponent for the result
      is this object's exponent minus the divisor's exponent.
    </summary><param name='divisor'>The number to divide by.
    </param><param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and no rounding is needed.
    </param><returns>The quotient of the two objects. Signals FlagDivideByZero and returns
      infinity if the divisor is 0 and the dividend is nonzero. Signals
      FlagInvalid and returns not-a-number (NaN) if the divisor and the dividend
      are 0; or, either
      <paramref name='ctx'/>
       is null or
      <paramref name='ctx'/>
       's precision is 0, and the result would have a nonterminating decimal
      expansion; or, the rounding mode is ERounding.None and the result is not
      exact.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.DivideAndRemainderNaturalScale(PeterO.Numbers.EDecimal)">

            <summary>Calculates the quotient and remainder using the
      DivideToIntegerNaturalScale and the formula in RemainderNaturalScale.
    </summary><param name='divisor'>The number to divide by.
    </param><returns>A 2 element array consisting of the quotient and remainder in that order.

    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.DivideAndRemainderNaturalScale(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">

            <summary>Calculates the quotient and remainder using the
      DivideToIntegerNaturalScale and the formula in RemainderNaturalScale.
    </summary><param name='divisor'>The number to divide by.
    </param><param name='ctx'>An arithmetic context object to control the precision, rounding, and
      exponent range of the result. This context will be used only in the
      division portion of the remainder calculation; as a result, it's possible
      for the remainder to have a higher precision than given in this context.
      Flags will be set on the given context only if the context's
      <c>HasFlags</c>
       is true and the integer part of the division result doesn't fit the
      precision and exponent range without rounding. Can be null, in which the
      precision is unlimited and no additional rounding, other than the rounding
      down to an integer after division, is needed.
    </param><returns>A 2 element array consisting of the quotient and remainder in that order.

    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.DivideToExponent(PeterO.Numbers.EDecimal,PeterO.Numbers.EInteger)">

            <summary>Divides two arbitrary-precision decimal numbers, and gives a particular
      exponent to the result, using the half-even rounding mode.
    </summary><param name='divisor'>The number to divide by.
    </param><param name='exponent'>The desired exponent. A negative number places the cutoff point to the
      right of the usual decimal point (so a negative number means the number of
      decimal places to round to). A positive number places the cutoff point to
      the left of the usual decimal point.
    </param><returns>The quotient of the two objects. Signals FlagDivideByZero and returns
      infinity if the divisor is 0 and the dividend is nonzero. Signals
      FlagInvalid and returns not-a-number (NaN) if the divisor and the dividend
      are 0.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.DivideToExponent(PeterO.Numbers.EDecimal,PeterO.Numbers.EInteger,PeterO.Numbers.EContext)">

            <summary>Divides two arbitrary-precision decimal numbers, and gives a particular
      exponent to the result.
    </summary><param name='divisor'>The number to divide by.
    </param><param name='exponent'>The desired exponent. A negative number places the cutoff point to the
      right of the usual decimal point (so a negative number means the number of
      decimal places to round to). A positive number places the cutoff point to
      the left of the usual decimal point.
    </param><param name='ctx'>An arithmetic context object to control the rounding mode to use if the
      result must be scaled down to have the same exponent as this value. If the
      precision given in the context is other than 0, calls the Quantize method
      with both arguments equal to the result of the operation (and can signal
      FlagInvalid and return NaN if the result doesn't fit the given precision).
      If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the default rounding mode is HalfEven.
    </param><returns>The quotient of the two objects. Signals FlagDivideByZero and returns
      infinity if the divisor is 0 and the dividend is nonzero. Signals
      FlagInvalid and returns not-a-number (NaN) if the divisor and the dividend
      are 0. Signals FlagInvalid and returns not-a-number (NaN) if the context
      defines an exponent range and the desired exponent is outside that range.
      Signals FlagInvalid and returns not-a-number (NaN) if the rounding mode is
      ERounding.None and the result is not exact.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.DivideToExponent(PeterO.Numbers.EDecimal,PeterO.Numbers.EInteger,PeterO.Numbers.ERounding)">

            <summary>Divides two arbitrary-precision decimal numbers, and gives a particular
      exponent to the result.
    </summary><param name='divisor'>The number to divide by.
    </param><param name='desiredExponent'>The desired exponent. A negative number places the cutoff point to the
      right of the usual decimal point (so a negative number means the number of
      decimal places to round to). A positive number places the cutoff point to
      the left of the usual decimal point.
    </param><param name='rounding'>The rounding mode to use if the result must be scaled down to have the
      same exponent as this value.
    </param><returns>The quotient of the two objects. Signals FlagDivideByZero and returns
      infinity if the divisor is 0 and the dividend is nonzero. Returns
      not-a-number (NaN) if the divisor and the dividend are 0. Returns NaN if
      the rounding mode is ERounding.None and the result is not exact.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.DivideToExponent(PeterO.Numbers.EDecimal,System.Int32)">

            <summary>Divides two arbitrary-precision decimal numbers, and gives a particular
      exponent (expressed as a 32-bit signed integer) to the result, using the
      half-even rounding mode.
    </summary><param name='divisor'>The number to divide by.
    </param><param name='desiredExponentInt'>The desired exponent. A negative number places the cutoff point to the
      right of the usual decimal point (so a negative number means the number of
      decimal places to round to). A positive number places the cutoff point to
      the left of the usual decimal point.
    </param><returns>The quotient of the two objects. Signals FlagDivideByZero and returns
      infinity if the divisor is 0 and the dividend is nonzero. Signals
      FlagInvalid and returns not-a-number (NaN) if the divisor and the dividend
      are 0.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.DivideToExponent(PeterO.Numbers.EDecimal,System.Int32,PeterO.Numbers.EContext)">

            <summary>Divides two arbitrary-precision decimal numbers, and gives a particular
      exponent (expressed as a 32-bit signed integer) to the result, using the
      half-even rounding mode.
    </summary><param name='divisor'>The number to divide by.
    </param><param name='desiredExponentInt'>The desired exponent. A negative number places the cutoff point to the
      right of the usual decimal point (so a negative number means the number of
      decimal places to round to). A positive number places the cutoff point to
      the left of the usual decimal point.
    </param><param name='ctx'>An arithmetic context object to control the rounding mode to use if the
      result must be scaled down to have the same exponent as this value. If the
      precision given in the context is other than 0, calls the Quantize method
      with both arguments equal to the result of the operation (and can signal
      FlagInvalid and return NaN if the result doesn't fit the given precision).
      If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the default rounding mode is HalfEven.
    </param><returns>The quotient of the two objects. Signals FlagDivideByZero and returns
      infinity if the divisor is 0 and the dividend is nonzero. Signals
      FlagInvalid and returns not-a-number (NaN) if the divisor and the dividend
      are 0. Signals FlagInvalid and returns not-a-number (NaN) if the context
      defines an exponent range and the desired exponent is outside that range.
      Signals FlagInvalid and returns not-a-number (NaN) if the rounding mode is
      ERounding.None and the result is not exact.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.DivideToExponent(PeterO.Numbers.EDecimal,System.Int32,PeterO.Numbers.ERounding)">

            <summary>Divides two arbitrary-precision decimal numbers, and gives a particular
      exponent (expressed as a 32-bit signed integer) to the result, using the
      half-even rounding mode.
    </summary><param name='divisor'>The number to divide by.
    </param><param name='desiredExponentInt'>The desired exponent. A negative number places the cutoff point to the
      right of the usual decimal point (so a negative number means the number of
      decimal places to round to). A positive number places the cutoff point to
      the left of the usual decimal point.
    </param><param name='rounding'>The rounding mode to use if the result must be scaled down to have the
      same exponent as this value.
    </param><returns>The quotient of the two objects. Signals FlagDivideByZero and returns
      infinity if the divisor is 0 and the dividend is nonzero. Signals
      FlagInvalid and returns not-a-number (NaN) if the divisor and the dividend
      are 0. Signals FlagInvalid and returns not-a-number (NaN) if the rounding
      mode is ERounding.None and the result is not exact.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.DivideToExponent(PeterO.Numbers.EDecimal,System.Int64)">

            <summary>Divides two arbitrary-precision decimal numbers, and gives a particular
      exponent (expressed as a 64-bit signed integer) to the result, using the
      half-even rounding mode.
    </summary><param name='divisor'>The number to divide by.
    </param><param name='desiredExponentSmall'>The desired exponent. A negative number places the cutoff point to the
      right of the usual decimal point (so a negative number means the number of
      decimal places to round to). A positive number places the cutoff point to
      the left of the usual decimal point.
    </param><returns>The quotient of the two objects. Signals FlagDivideByZero and returns
      infinity if the divisor is 0 and the dividend is nonzero. Signals
      FlagInvalid and returns not-a-number (NaN) if the divisor and the dividend
      are 0.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.DivideToExponent(PeterO.Numbers.EDecimal,System.Int64,PeterO.Numbers.EContext)">

            <summary>Divides two arbitrary-precision decimal numbers, and gives a particular
      exponent to the result.
    </summary><param name='divisor'>The number to divide by.
    </param><param name='desiredExponentSmall'>The desired exponent. A negative number places the cutoff point to the
      right of the usual decimal point (so a negative number means the number of
      decimal places to round to). A positive number places the cutoff point to
      the left of the usual decimal point.
    </param><param name='ctx'>An arithmetic context object to control the rounding mode to use if the
      result must be scaled down to have the same exponent as this value. If the
      precision given in the context is other than 0, calls the Quantize method
      with both arguments equal to the result of the operation (and can signal
      FlagInvalid and return NaN if the result doesn't fit the given precision).
      If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the default rounding mode is HalfEven.
    </param><returns>The quotient of the two objects. Signals FlagDivideByZero and returns
      infinity if the divisor is 0 and the dividend is nonzero. Signals
      FlagInvalid and returns not-a-number (NaN) if the divisor and the dividend
      are 0. Signals FlagInvalid and returns not-a-number (NaN) if the context
      defines an exponent range and the desired exponent is outside that range.
      Signals FlagInvalid and returns not-a-number (NaN) if the rounding mode is
      ERounding.None and the result is not exact.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.DivideToExponent(PeterO.Numbers.EDecimal,System.Int64,PeterO.Numbers.ERounding)">

            <summary>Divides two arbitrary-precision decimal numbers, and gives a particular
      exponent to the result.
    </summary><param name='divisor'>The number to divide by.
    </param><param name='desiredExponentSmall'>The desired exponent. A negative number places the cutoff point to the
      right of the usual decimal point (so a negative number means the number of
      decimal places to round to). A positive number places the cutoff point to
      the left of the usual decimal point.
    </param><param name='rounding'>The rounding mode to use if the result must be scaled down to have the
      same exponent as this value.
    </param><returns>The quotient of the two objects. Signals FlagDivideByZero and returns
      infinity if the divisor is 0 and the dividend is nonzero. Signals
      FlagInvalid and returns not-a-number (NaN) if the divisor and the dividend
      are 0. Signals FlagInvalid and returns not-a-number (NaN) if the rounding
      mode is ERounding.None and the result is not exact.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.DivideToIntegerNaturalScale(PeterO.Numbers.EDecimal)">

            <summary>Divides two arbitrary-precision decimal numbers, and returns the integer
      part of the result, rounded down, with the preferred exponent set to this
      value's exponent minus the divisor's exponent.
    </summary><param name='divisor'>The number to divide by.
    </param><returns>The integer part of the quotient of the two objects. Signals
      FlagDivideByZero and returns infinity if the divisor is 0 and the dividend
      is nonzero. Signals FlagInvalid and returns not-a-number (NaN) if the
      divisor and the dividend are 0.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.DivideToIntegerNaturalScale(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">

            <summary>Divides this object by another object, and returns the integer part of
      the result (which is initially rounded down), with the preferred exponent
      set to this value's exponent minus the divisor's exponent.
    </summary><param name='divisor'>The parameter
      <paramref name='divisor'/>
       is an EDecimal object.
    </param><param name='ctx'>The parameter
      <paramref name='ctx'/>
       is an EContext object.
    </param><returns>The integer part of the quotient of the two objects. Signals FlagInvalid
      and returns not-a-number (NaN) if the return value would overflow the
      exponent range. Signals FlagDivideByZero and returns infinity if the
      divisor is 0 and the dividend is nonzero. Signals FlagInvalid and returns
      not-a-number (NaN) if the divisor and the dividend are 0. Signals
      FlagInvalid and returns not-a-number (NaN) if the rounding mode is
      ERounding.None and the result is not exact.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.DivideToIntegerZeroScale(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">

            <summary>Divides this object by another object, and returns the integer part of
      the result, with the exponent set to 0.
    </summary><param name='divisor'>The number to divide by.
    </param><param name='ctx'>An arithmetic context object to control the precision. The rounding and
      exponent range settings of this context are ignored. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited.
    </param><returns>The integer part of the quotient of the two objects. The exponent will be
      set to 0. Signals FlagDivideByZero and returns infinity if the divisor is
      0 and the dividend is nonzero. Signals FlagInvalid and returns
      not-a-number (NaN) if the divisor and the dividend are 0, or if the result
      doesn't fit the given precision.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.DivideToSameExponent(PeterO.Numbers.EDecimal,PeterO.Numbers.ERounding)">

            <summary>Divides this object by another decimal number and returns a result with
      the same exponent as this object (the dividend).
    </summary><param name='divisor'>The number to divide by.
    </param><param name='rounding'>The rounding mode to use if the result must be scaled down to have the
      same exponent as this value.
    </param><returns>The quotient of the two numbers. Signals FlagDivideByZero and returns
      infinity if the divisor is 0 and the dividend is nonzero. Signals
      FlagInvalid and returns not-a-number (NaN) if the divisor and the dividend
      are 0. Signals FlagInvalid and returns not-a-number (NaN) if the rounding
      mode is ERounding.None and the result is not exact.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.Equals(PeterO.Numbers.EDecimal)">

            <summary>Determines whether this object's mantissa (significand), exponent, and
      properties are equal to those of another object. Not-a-number values are
      considered equal if the rest of their properties are equal.
    </summary><param name='other'>An arbitrary-precision decimal number.
    </param><returns><c>true</c>
       if this object's mantissa (significand) and exponent are equal to those
      of another object; otherwise, <c>false</c>
       .
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.Equals(System.Object)">

            <summary>Determines whether this object's mantissa (significand), exponent, and
      properties are equal to those of another object and that other object is
      an arbitrary-precision decimal number. Not-a-number values are considered
      equal if the rest of their properties are equal.
    </summary><param name='obj'>The parameter
      <paramref name='obj'/>
       is an arbitrary object.
    </param><returns><c>true</c>
       if the objects are equal; otherwise, <c>false</c>
       .
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.Exp(PeterO.Numbers.EContext)">
<summary>Finds e (the base of natural logarithms) raised to the power of this
      object's value.
    </summary>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags).
      <i>
         This parameter can't be null, as the exponential function's results are
        generally not exact.
      </i>
       (Unlike in the General Decimal Arithmetic Specification, any rounding
      mode is allowed.).
    </param>
    <returns>Exponential of this object. If this object's value is 1, returns an
      approximation to " e" within the given precision. Signals FlagInvalid and
      returns not-a-number (NaN) if the parameter &#x22;ctx&#x22; is null or the
      precision is unlimited (the context's Precision property is 0).
    </returns>
</doc>
<doc name="P:PeterO.Numbers.EDecimal.Exponent">

            <summary>Gets this object's exponent. This object's value will be an integer if
      the exponent is positive or zero.
    </summary><value>This object's exponent. This object' s value will be an integer if the
      exponent is positive or zero.
    </value>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.FromByte(System.Byte)">

            <summary>Converts a byte (from 0 to 255) to an arbitrary-precision decimal number.

    </summary><param name='inputByte'>The number to convert as a byte (from 0 to 255).
    </param><returns>This number's value as an arbitrary-precision decimal number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.FromDecimal(System.Decimal)">

            <summary>Converts a
      <c>decimal</c>
       under the Common Language Infrastructure (see
      <see cref='T:PeterO.Numbers.EDecimal'>
         "Forms of numbers"
      </see>
       ) to an arbitrary-precision decimal.
    </summary><param name='dec'>A
      <c>decimal</c>
       under the Common Language Infrastructure (usually a .NET Framework
      decimal).
    </param><returns>An arbitrary-precision decimal floating-point number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.FromDouble(System.Double)">
<summary>Creates a decimal number from a 64-bit binary floating-point number. This
      method computes the exact value of the floating point number, not an
      approximation, as is often the case by converting the floating point
      number to a string first. Remember, though, that the exact value of a
      64-bit binary floating-point number is not always the value that results
      when passing a literal decimal number (for example, calling
      <c>ExtendedDecimal.FromDouble(0.1f)</c>
       ), since not all decimal numbers can be converted to exact binary numbers
      (in the example given, the resulting arbitrary-precision decimal will be
      the value of the closest "double" to 0.1, not 0.1 exactly). To create an
      arbitrary-precision decimal number from a decimal number, use FromString
      instead in most cases (for example:
      <c>ExtendedDecimal.FromString("0.1")</c>
       ).
    </summary>
    <param name='dbl'>The parameter
      <paramref name='dbl'/>
       is a 64-bit floating-point number.
    </param>
    <returns>A decimal number with the same value as &#x22;dbl&#x22;.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.EDecimal.FromEFloat(PeterO.Numbers.EFloat)">
<summary>Creates a decimal number from an arbitrary-precision binary floating-point
      number.
    </summary>
    <param name='bigfloat'>An arbitrary-precision binary floating-point number.
    </param>
    <returns>An arbitrary-precision decimal number.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter &#x22;bigfloat&#x22; is null.
    </exception>
</doc>
<doc name="M:PeterO.Numbers.EDecimal.FromEInteger(PeterO.Numbers.EInteger)">

            <summary>Converts an arbitrary-precision integer to an arbitrary precision
      decimal.
    </summary><param name='bigint'>An arbitrary-precision integer.
    </param><returns>An arbitrary-precision decimal number with the exponent set to 0.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.FromExtendedFloat(PeterO.Numbers.EFloat)">

            <summary>Converts an arbitrary-precision binary floating-point number to an
      arbitrary precision decimal.
    </summary><param name='ef'>An arbitrary-precision binary floating-point number.
    </param><returns>An arbitrary-precision decimal number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.FromInt16(System.Int16)">

            <summary>Converts a 16-bit signed integer to an arbitrary-precision decimal
      number.
    </summary><param name='inputInt16'>The number to convert as a 16-bit signed integer.
    </param><returns>This number's value as an arbitrary-precision decimal number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.FromInt32(System.Int32)">

            <summary>Creates a decimal number from a 32-bit signed integer.
    </summary><param name='valueSmaller'>The parameter
      <paramref name='valueSmaller'/>
       is a 32-bit signed integer.
    </param><returns>An arbitrary-precision decimal number with the exponent set to 0.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.FromInt64(System.Int64)">

            <summary>Creates a decimal number from a 64-bit signed integer.
    </summary><param name='valueSmall'>The parameter
      <paramref name='valueSmall'/>
       is a 64-bit signed integer.
    </param><returns>An arbitrary-precision decimal number with the exponent set to 0.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.FromSByte(System.SByte)">

            <summary>Converts an 8-bit signed integer to an arbitrary-precision decimal
      number.
    </summary><param name='inputSByte'>The number to convert as an 8-bit signed integer.
    </param><returns>This number's value as an arbitrary-precision decimal number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.FromSingle(System.Single)">
<summary>Creates a decimal number from a 32-bit binary floating-point number. This
      method computes the exact value of the floating point number, not an
      approximation, as is often the case by converting the floating point
      number to a string first. Remember, though, that the exact value of a
      32-bit binary floating-point number is not always the value that results
      when passing a literal decimal number (for example, calling
      <c>ExtendedDecimal.FromSingle(0.1f)</c>
       ), since not all decimal numbers can be converted to exact binary numbers
      (in the example given, the resulting arbitrary-precision decimal will be
      the the value of the closest "float" to 0.1, not 0.1 exactly). To create
      an arbitrary-precision decimal number from a decimal number, use
      FromString instead in most cases (for example:
      <c>ExtendedDecimal.FromString("0.1")</c>
       ).
    </summary>
    <param name='flt'>The parameter
      <paramref name='flt'/>
       is a 32-bit binary floating-point number.
    </param>
    <returns>A decimal number with the same value as &#x22;flt&#x22;.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.EDecimal.FromString(System.String)">
<summary>Creates a decimal number from a text string that represents a number. See
      <c>FromString(String, int, int, EContext)</c>
       for more information.
    </summary>
    <param name='str'>A string that represents a number.
    </param>
    <returns>An arbitrary-precision decimal number with the same value as the given
      string.
    </returns>
    <exception cref='T:System.FormatException'>The parameter &#x22;str&#x22; is not a correctly formatted number string.
    </exception>
</doc>
<doc name="M:PeterO.Numbers.EDecimal.FromString(System.String,PeterO.Numbers.EContext)">
<summary>Creates a decimal number from a text string that represents a number. See
      <c>FromString(String, int, int, EContext)</c>
       for more information.
    </summary>
    <param name='str'>A string that represents a number.
    </param>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and rounding isn't needed.
    </param>
    <returns>An arbitrary-precision decimal number with the same value as the given
      string.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter &#x22;str&#x22; is null.
    </exception>
</doc>
<doc name="M:PeterO.Numbers.EDecimal.FromString(System.String,System.Int32,System.Int32)">
<summary>Creates a decimal number from a text string that represents a number. See
      <c>FromString(String, int, int, EContext)</c>
       for more information.
    </summary>
    <param name='str'>A string that represents a number.
    </param>
    <param name='offset'>A zero-based index showing where the desired portion of
      <paramref name='str'/>
       begins.
    </param>
    <param name='length'>The length, in code units, of the desired portion of
      <paramref name='str'/>
       (but not more than
      <paramref name='str'/>
       's length).
    </param>
    <returns>An arbitrary-precision decimal number with the same value as the given
      string.
    </returns>
    <exception cref='T:System.FormatException'>The parameter &#x22;str&#x22; is not a correctly formatted number string.
    </exception>
    <exception cref='T:System.ArgumentNullException'>The parameter &#x22;str&#x22; is null.
    </exception>
</doc>
<doc name="M:PeterO.Numbers.EDecimal.FromString(System.String,System.Int32,System.Int32,PeterO.Numbers.EContext)">
<summary><para>Creates a decimal number from a text string that represents a number.
      </para>
      <para>The format of the string generally consists of:
      </para>
      <list type=''>
        <item>An optional plus sign ("+" , U+002B) or minus sign ("-", U+002D) (if
          the minus sign, the value is negative.)
        </item>
        <item>One or more digits, with a single optional decimal point after the
          first digit and before the last digit.
        </item>
        <item>Optionally, "E"/"e" followed by an optional (positive exponent) or "-"
          (negative exponent) and followed by one or more digits specifying the
          exponent.
        </item>
      </list>
      <para>The string can also be "-INF", "-Infinity", "Infinity", "INF", quiet NaN
        ("NaN" /"-NaN") followed by any number of digits, or signaling NaN
        ("sNaN" /"-sNaN") followed by any number of digits, all in any
        combination of upper and lower case.
      </para>
      <para>All characters mentioned above are the corresponding characters in the
        Basic Latin range. In particular, the digits must be the basic digits 0
        to 9 (U+0030 to U+0039). The string is not allowed to contain white
        space characters, including spaces.
      </para>
    </summary>
    <param name='str'>A text string, a portion of which represents a number.
    </param>
    <param name='offset'>A zero-based index showing where the desired portion of
      <paramref name='str'/>
       begins.
    </param>
    <param name='length'>The length, in code units, of the desired portion of
      <paramref name='str'/>
       (but not more than
      <paramref name='str'/>
       's length).
    </param>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and rounding isn't needed.
    </param>
    <returns>An arbitrary-precision decimal number with the same value as the given
      string.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter &#x22;str&#x22; is null.
    </exception>
    <exception cref='T:System.ArgumentException'>Either &#x22;offset&#x22; or &#x22;length&#x22; is less than 0 or greater
      than &#x22;str&#x22; 's length, or &#x22;str&#x22; 's length minus
      &#x22;offset&#x22; is less than &#x22;length&#x22;.
    </exception>
</doc>
<doc name="M:PeterO.Numbers.EDecimal.FromUInt16(System.UInt16)">

            <summary>Converts a 16-bit unsigned integer to an arbitrary-precision decimal
      number.
    </summary><param name='inputUInt16'>The number to convert as a 16-bit unsigned integer.
    </param><returns>This number's value as an arbitrary-precision decimal number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.FromUInt32(System.UInt32)">

            <summary>Converts a 32-bit signed integer to an arbitrary-precision decimal
      number.
    </summary><param name='inputUInt32'>The number to convert as a 32-bit signed integer.
    </param><returns>This number's value as an arbitrary-precision decimal number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.FromUInt64(System.UInt64)">

            <summary>Converts a 64-bit unsigned integer to an arbitrary-precision decimal
      number.
    </summary><param name='inputUInt64'>The number to convert as a 64-bit unsigned integer.
    </param><returns>This number's value as an arbitrary-precision decimal number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.GetHashCode">

            <summary>Calculates this object's hash code. No application or process IDs are
      used in the hash code calculation.
    </summary><returns>A 32-bit signed integer.
    </returns>

</doc>
<doc name="P:PeterO.Numbers.EDecimal.IsFinite">

            <summary>Gets a value indicating whether this object is finite (not infinity or
      NaN).
    </summary><value><c>true</c>
       if this object is finite (not infinity or NaN); otherwise, <c>false</c>
       .
    </value>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.IsInfinity">

            <summary>Gets a value indicating whether this object is positive or negative
      infinity.
    </summary><returns><c>true</c>
       if this object is positive or negative infinity; otherwise, <c>false</c>
       .
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.IsNaN">

            <summary>Gets a value indicating whether this object is not a number (NaN).
    </summary><returns><c>true</c>
       if this object is not a number (NaN); otherwise, <c>false</c>
       .
    </returns>

</doc>
<doc name="P:PeterO.Numbers.EDecimal.IsNegative">

            <summary>Gets a value indicating whether this object is negative, including
      negative zero.
    </summary><value><c>true</c>
       if this object is negative, including negative zero; otherwise, <c>false</c>
       .
    </value>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.IsNegativeInfinity">

            <summary>Returns whether this object is negative infinity.
    </summary><returns><c>true</c>
       if this object is negative infinity; otherwise, <c>false</c>
       .
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.IsPositiveInfinity">

            <summary>Returns whether this object is positive infinity.
    </summary><returns><c>true</c>
       if this object is positive infinity; otherwise, <c>false</c>
       .
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.IsQuietNaN">

            <summary>Gets a value indicating whether this object is a quiet not-a-number
      value.
    </summary><returns><c>true</c>
       if this object is a quiet not-a-number value; otherwise, <c>false</c>
       .
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.IsSignalingNaN">

            <summary>Gets a value indicating whether this object is a signaling not-a-number
      value.
    </summary><returns><c>true</c>
       if this object is a signaling not-a-number value; otherwise, <c>false</c>
       .
    </returns>

</doc>
<doc name="P:PeterO.Numbers.EDecimal.IsZero">

            <summary>Gets a value indicating whether this object's value equals 0.
    </summary><value><c>true</c>
       if this object's value equals 0; otherwise, <c>false</c>
       .
      <c>true</c>
       if this object' s value equals 0; otherwise, .
      <c>false</c>
       .
    </value>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.Log(PeterO.Numbers.EContext)">
<summary>Finds the natural logarithm of this object, that is, the power (exponent)
      that e (the base of natural logarithms) must be raised to in order to
      equal this object's value.
    </summary>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags).
      <i>
         This parameter can't be null, as the ln function's results are
        generally not exact.
      </i>
       (Unlike in the General Decimal Arithmetic Specification, any rounding
      mode is allowed.).
    </param>
    <returns>Ln(this object). Signals the flag FlagInvalid and returns NaN if this
      object is less than 0 (the result would be a complex number with a real
      part equal to Ln of this object's absolute value and an imaginary part
      equal to pi, but the return value is still NaN.). Signals FlagInvalid and
      returns not-a-number (NaN) if the parameter &#x22;ctx&#x22; is null or the
      precision is unlimited (the context's Precision property is 0). Signals no
      flags and returns negative infinity if this object's value is 0.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.EDecimal.Log10(PeterO.Numbers.EContext)">
<summary>Finds the base-10 logarithm of this object, that is, the power (exponent)
      that the number 10 must be raised to in order to equal this object's
      value.
    </summary>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags).
      <i>
         This parameter can't be null, as the ln function's results are
        generally not exact.
      </i>
       (Unlike in the General Decimal Arithmetic Specification, any rounding
      mode is allowed.).
    </param>
    <returns>Ln(this object)/Ln(10). Signals the flag FlagInvalid and returns
      not-a-number (NaN) if this object is less than 0. Signals FlagInvalid and
      returns not-a-number (NaN) if the parameter &#x22;ctx&#x22; is null or the
      precision is unlimited (the context's Precision property is 0).
    </returns>
</doc>
<doc name="P:PeterO.Numbers.EDecimal.Mantissa">

            <summary>Gets this object's unscaled value.
    </summary><value>This object' s unscaled value. Will be negative if this object's value is
      negative (including a negative NaN).
    </value>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.Max(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal)">

            <summary>Gets the greater value between two decimal numbers.
    </summary><param name='first'>An arbitrary-precision decimal number.
    </param><param name='second'>Another arbitrary-precision decimal number.
    </param><returns>The larger value of the two numbers.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.Max(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">

            <summary>Gets the greater value between two decimal numbers.
    </summary><param name='first'>The first value to compare.
    </param><param name='second'>The second value to compare.
    </param><param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and rounding isn't needed.
    </param><returns>The larger value of the two numbers.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.MaxMagnitude(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal)">

            <summary>Gets the greater value between two values, ignoring their signs. If the
      absolute values are equal, has the same effect as Max.
    </summary><param name='first'>The first value to compare.
    </param><param name='second'>The second value to compare.
    </param><returns>An arbitrary-precision decimal number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.MaxMagnitude(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">

            <summary>Gets the greater value between two values, ignoring their signs. If the
      absolute values are equal, has the same effect as Max.
    </summary><param name='first'>The first value to compare.
    </param><param name='second'>The second value to compare.
    </param><param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and rounding isn't needed.
    </param><returns>An arbitrary-precision decimal number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.Min(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal)">

            <summary>Gets the lesser value between two decimal numbers.
    </summary><param name='first'>The first value to compare.
    </param><param name='second'>The second value to compare.
    </param><returns>The smaller value of the two numbers.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.Min(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">

            <summary>Gets the lesser value between two decimal numbers.
    </summary><param name='first'>The first value to compare.
    </param><param name='second'>The second value to compare.
    </param><param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and rounding isn't needed.
    </param><returns>The smaller value of the two numbers.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.MinMagnitude(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal)">

            <summary>Gets the lesser value between two values, ignoring their signs. If the
      absolute values are equal, has the same effect as Min.
    </summary><param name='first'>The first value to compare.
    </param><param name='second'>The second value to compare.
    </param><returns>An arbitrary-precision decimal number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.MinMagnitude(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">

            <summary>Gets the lesser value between two values, ignoring their signs. If the
      absolute values are equal, has the same effect as Min.
    </summary><param name='first'>The first value to compare.
    </param><param name='second'>The second value to compare.
    </param><param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and rounding isn't needed.
    </param><returns>An arbitrary-precision decimal number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.MovePointLeft(PeterO.Numbers.EInteger)">
<summary>Returns a number similar to this number but with the decimal point moved
      to the left.
    </summary>
    <param name='bigPlaces'>The number of decimal places to move the decimal point to the left. If
      this number is negative, instead moves the decimal point to the right by
      this number's absolute value.
    </param>
    <returns>A number whose exponent is decreased by &#x22;bigPlaces&#x22;, but not to
      more than 0.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.EDecimal.MovePointLeft(PeterO.Numbers.EInteger,PeterO.Numbers.EContext)">

            <summary>Returns a number similar to this number but with the decimal point moved
      to the left.
    </summary><param name='bigPlaces'>The number of decimal places to move the decimal point to the left. If
      this number is negative, instead moves the decimal point to the right by
      this number's absolute value.
    </param><param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and rounding isn't needed.
    </param><returns>A number whose exponent is decreased by
      <paramref name='bigPlaces'/>
       , but not to more than 0.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.MovePointLeft(System.Int32)">
<summary>Returns a number similar to this number but with the decimal point moved
      to the left.
    </summary>
    <param name='places'>The number of decimal places to move the decimal point to the left. If
      this number is negative, instead moves the decimal point to the right by
      this number's absolute value.
    </param>
    <returns>A number whose exponent is decreased by &#x22;places&#x22;, but not to
      more than 0.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.EDecimal.MovePointLeft(System.Int32,PeterO.Numbers.EContext)">

            <summary>Returns a number similar to this number but with the decimal point moved
      to the left.
    </summary><param name='places'>The number of decimal places to move the decimal point to the left. If
      this number is negative, instead moves the decimal point to the right by
      this number's absolute value.
    </param><param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and rounding isn't needed.
    </param><returns>A number whose exponent is decreased by
      <paramref name='places'/>
       , but not to more than 0.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.MovePointRight(PeterO.Numbers.EInteger)">
<summary>Returns a number similar to this number but with the decimal point moved
      to the right.
    </summary>
    <param name='bigPlaces'>The number of decimal places to move the decimal point to the right. If
      this number is negative, instead moves the decimal point to the left by
      this number's absolute value.
    </param>
    <returns>A number whose exponent is increased by &#x22;bigPlaces&#x22;, but not to
      more than 0.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.EDecimal.MovePointRight(PeterO.Numbers.EInteger,PeterO.Numbers.EContext)">

            <summary>Returns a number similar to this number but with the decimal point moved
      to the right.
    </summary><param name='bigPlaces'>The number of decimal places to move the decimal point to the right. If
      this number is negative, instead moves the decimal point to the left by
      this number's absolute value.
    </param><param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and rounding isn't needed.
    </param><returns>A number whose exponent is increased by
      <paramref name='bigPlaces'/>
       , but not to more than 0.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.MovePointRight(System.Int32)">
<summary>Returns a number similar to this number but with the decimal point moved
      to the right.
    </summary>
    <param name='places'>The number of decimal places to move the decimal point to the right. If
      this number is negative, instead moves the decimal point to the left by
      this number's absolute value.
    </param>
    <returns>A number whose exponent is increased by &#x22;places&#x22;, but not to
      more than 0.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.EDecimal.MovePointRight(System.Int32,PeterO.Numbers.EContext)">

            <summary>Returns a number similar to this number but with the decimal point moved
      to the right.
    </summary><param name='places'>The number of decimal places to move the decimal point to the right. If
      this number is negative, instead moves the decimal point to the left by
      this number's absolute value.
    </param><param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and rounding isn't needed.
    </param><returns>A number whose exponent is increased by
      <paramref name='places'/>
       , but not to more than 0.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.Multiply(PeterO.Numbers.EDecimal)">

            <summary>Multiplies two decimal numbers. The resulting exponent will be the sum of
      the exponents of the two decimal numbers.
    </summary><param name='otherValue'>Another decimal number.
    </param><returns>The product of the two decimal numbers.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.Multiply(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">

            <summary>Multiplies two decimal numbers. The resulting scale will be the sum of
      the scales of the two decimal numbers. The result's sign is positive if
      both operands have the same sign, and negative if they have different
      signs.
    </summary><param name='op'>Another decimal number.
    </param><param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and rounding isn't needed.
    </param><returns>The product of the two decimal numbers.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.MultiplyAndAdd(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal)">

            <summary>Multiplies by one decimal number, and then adds another decimal number.
    </summary><param name='multiplicand'>The value to multiply.
    </param><param name='augend'>The value to add.
    </param><returns>An EDecimal object.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.MultiplyAndAdd(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">

            <summary>Multiplies by one value, and then adds another value.
    </summary><param name='op'>The value to multiply.
    </param><param name='augend'>The value to add.
    </param><param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and rounding isn't needed.
      If the precision doesn't indicate a simplified arithmetic, rounding and
      precision/exponent adjustment is done only once, namely, after multiplying
      and adding.
    </param><returns>The result thisValue * multiplicand + augend.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.MultiplyAndSubtract(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
<summary>Multiplies by one value, and then subtracts another value.
    </summary>
    <param name='op'>The value to multiply.
    </param>
    <param name='subtrahend'>The value to subtract.
    </param>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and rounding isn't needed.
      If the precision doesn't indicate a simplified arithmetic, rounding and
      precision/exponent adjustment is done only once, namely, after multiplying
      and subtracting.
    </param>
    <returns>The result thisValue * multiplicand - subtrahend.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter &#x22;op&#x22; or &#x22;subtrahend&#x22; is null.
    </exception>
</doc>
<doc name="F:PeterO.Numbers.EDecimal.NaN">

            <summary>A not-a-number value.
    </summary>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.Negate">

            <summary>Gets an object with the same value as this one, but with the sign
      reversed.
    </summary><returns>An arbitrary-precision decimal number. If this value is positive zero,
      returns negative zero. Returns signaling NaN if this value is signaling
      NaN.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.Negate(PeterO.Numbers.EContext)">

            <summary>Returns a decimal number with the same value as this object but with the
      sign reversed.
    </summary><param name='context'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and rounding isn't needed.
    </param><returns>An arbitrary-precision decimal number. If this value is positive zero,
      returns positive zero. Signals FlagInvalid and returns quiet NaN if this
      value is signaling NaN.
    </returns>

</doc>
<doc name="F:PeterO.Numbers.EDecimal.NegativeInfinity">

            <summary>Negative infinity, less than any other number.
    </summary>

</doc>
<doc name="F:PeterO.Numbers.EDecimal.NegativeZero">

            <summary>Represents the number negative zero.
    </summary>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.NextMinus(PeterO.Numbers.EContext)">
<summary>Finds the largest value that's smaller than the given value.
    </summary>
    <param name='ctx'>An arithmetic context object to control the precision and exponent range
      of the result. The rounding mode from this context is ignored. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags).
    </param>
    <returns>Returns the largest value that's less than the given value. Returns
      negative infinity if the result is negative infinity. Signals FlagInvalid
      and returns not-a-number (NaN) if the parameter &#x22;ctx&#x22; is null,
      the precision is 0, or &#x22;ctx&#x22; has an unlimited exponent range.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.EDecimal.NextPlus(PeterO.Numbers.EContext)">
<summary>Finds the smallest value that's greater than the given value.
    </summary>
    <param name='ctx'>An arithmetic context object to control the precision and exponent range
      of the result. The rounding mode from this context is ignored. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags).
    </param>
    <returns>Returns the smallest value that's greater than the given value.Signals
      FlagInvalid and returns not-a-number (NaN) if the parameter
      &#x22;ctx&#x22; is null, the precision is 0, or &#x22;ctx&#x22; has an
      unlimited exponent range.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.EDecimal.NextToward(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">

            <summary>Finds the next value that is closer to the other object's value than this
      object's value. Returns a copy of this value with the same sign as the
      other value if both values are equal.
    </summary><param name='otherValue'>An arbitrary-precision decimal number that the return value will approach.
    </param><param name='ctx'>An arithmetic context object to control the precision and exponent range
      of the result. The rounding mode from this context is ignored. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags).
    </param><returns>Returns the next value that is closer to the other object' s value than
      this object's value. Signals FlagInvalid and returns NaN if the parameter
      <paramref name='ctx'/>
       is null, the precision is 0, or
      <paramref name='ctx'/>
       has an unlimited exponent range.
    </returns>

</doc>
<doc name="F:PeterO.Numbers.EDecimal.One">

            <summary>Represents the number 1.
    </summary>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.PI(PeterO.Numbers.EContext)">
<summary>Finds the constant , the circumference of a circle divided by its
      diameter.
    </summary>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags).
      <i>
         This parameter can't be null, as &#x3c0; can never be represented
        exactly.
      </i>
       .
    </param>
    <returns>The constant  rounded to the given precision. Signals FlagInvalid and
      returns not-a-number (NaN) if the parameter &#x22;ctx&#x22; is null or the
      precision is unlimited (the context's Precision property is 0).
    </returns>
</doc>
<doc name="M:PeterO.Numbers.EDecimal.Plus(PeterO.Numbers.EContext)">
<summary>Rounds this object's value to a given precision, using the given rounding
      mode and range of exponent, and also converts negative zero to positive
      zero.
    </summary>
    <param name='ctx'>A context for controlling the precision, rounding mode, and exponent
      range. Can be null, in which case the precision is unlimited and rounding
      isn't needed.
    </param>
    <returns>The closest value to this object's value, rounded to the specified
      precision. Returns the same value as this object if &#x22;ctx&#x22; is
      null or the precision and exponent range are unlimited.
    </returns>
</doc>
<doc name="F:PeterO.Numbers.EDecimal.PositiveInfinity">

            <summary>Positive infinity, greater than any other number.
    </summary>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.Pow(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">

            <summary>Raises this object's value to the given exponent.
    </summary><param name='exponent'>An arbitrary-precision decimal number expressing the exponent to raise
      this object's value to.
    </param><param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and rounding isn't needed.
    </param><returns>This^exponent. Signals the flag FlagInvalid and returns NaN if this
      object and exponent are both 0; or if this value is less than 0 and the
      exponent either has a fractional part or is infinity. Signals FlagInvalid
      and returns not-a-number (NaN) if the parameter
      <paramref name='ctx'/>
       is null or the precision is unlimited (the context's Precision property
      is 0), and the exponent has a fractional part.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.Pow(System.Int32)">

            <summary>Raises this object's value to the given exponent.
    </summary><param name='exponentSmall'>The exponent to raise this object's value to.
    </param><returns>This^exponent. Returns not-a-number (NaN) if this object and exponent are
      both 0.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.Pow(System.Int32,PeterO.Numbers.EContext)">

            <summary>Raises this object's value to the given exponent.
    </summary><param name='exponentSmall'>The exponent to raise this object's value to.
    </param><param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and rounding isn't needed.
    </param><returns>This^exponent. Signals the flag FlagInvalid and returns NaN if this
      object and exponent are both 0.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.Precision">

            <summary>Finds the number of digits in this number's mantissa (significand).
      Returns 1 if this value is 0, and 0 if this value is infinity or
      not-a-number (NaN).
    </summary><returns>An arbitrary-precision integer.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.Quantize(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">

            <summary>Returns a decimal number with the same value as this object but with the
      same exponent as another decimal number.
      <para>Note that this is not always the same as rounding to a given number of
        decimal places, since it can fail if the difference between this value's
        exponent and the desired exponent is too big, depending on the maximum
        precision. If rounding to a number of decimal places is desired, it's
        better to use the RoundToExponent and RoundToIntegral methods instead.
      </para>
      <para><b>Remark:</b>
         This method can be used to implement fixed-point decimal arithmetic, in
        which a fixed number of digits come after the decimal point. A
        fixed-point decimal arithmetic in which no digits come after the decimal
        point (a desired exponent of 0) is considered an "integer arithmetic" .
      </para>
    </summary><param name='otherValue'>A decimal number containing the desired exponent of the result. The
      mantissa (significand) is ignored. The exponent is the number of
      fractional digits in the result, expressed as a negative number. Can also
      be positive, which eliminates lower-order places from the number. For
      example, -3 means round to the sixteenth (10b^-3, 0.0001b), and 3 means
      round to the sixteen-place (10b^3, 1000b). A value of 0 rounds the number
      to an integer.
    </param><param name='ctx'>An arithmetic context to control precision and rounding of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the default rounding mode is HalfEven.
    </param><returns>A decimal number with the same value as this object but with the exponent
      changed. Signals FlagInvalid and returns not-a-number (NaN) if the result
      can't fit the given precision without rounding, or if the arithmetic
      context defines an exponent range and the given exponent is outside that
      range.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.Quantize(PeterO.Numbers.EInteger,PeterO.Numbers.EContext)">

            <summary>Returns a decimal number with the same value but a new exponent.
      <para>Note that this is not always the same as rounding to a given number of
        decimal places, since it can fail if the difference between this value's
        exponent and the desired exponent is too big, depending on the maximum
        precision. If rounding to a number of decimal places is desired, it's
        better to use the RoundToExponent and RoundToIntegral methods instead.
      </para>
      <para><b>Remark:</b>
         This method can be used to implement fixed-point decimal arithmetic, in
        which each decimal number has a fixed number of digits after the decimal
        point. The following code example returns a fixed-point number with up
        to 20 digits before and exactly 5 digits after the decimal point:
      </para>
      <code>// After performing arithmetic operations, adjust // the number to 5 //
        digits after the decimal point number = number.Quantize(
        EInteger.FromInt32(-5), // five digits after the decimal point
        EContext.ForPrecision(25) // 25-digit precision);
      </code>
      <para>A fixed-point decimal arithmetic in which no digits come after the
        decimal point (a desired exponent of 0) is considered an "integer
        arithmetic".
      </para>
    </summary><param name='desiredExponent'>The desired exponent for the result. The exponent is the number of
      fractional digits in the result, expressed as a negative number. Can also
      be positive, which eliminates lower-order places from the number. For
      example, -3 means round to the thousandth (10^-3, 0.0001), and 3 means
      round to the thousand (10^3, 1000). A value of 0 rounds the number to an
      integer.
    </param><param name='ctx'>An arithmetic context to control precision and rounding of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the default rounding mode is HalfEven.
    </param><returns>A decimal number with the same value as this object but with the exponent
      changed. Signals FlagInvalid and returns not-a-number (NaN) if this object
      is infinity, if the rounded result can't fit the given precision, or if
      the context defines an exponent range and the given exponent is outside
      that range.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.Quantize(System.Int32,PeterO.Numbers.EContext)">

            <summary>Returns a decimal number with the same value but a new exponent.
      <para>Note that this is not always the same as rounding to a given number of
        decimal places, since it can fail if the difference between this value's
        exponent and the desired exponent is too big, depending on the maximum
        precision. If rounding to a number of decimal places is desired, it's
        better to use the RoundToExponent and RoundToIntegral methods instead.
      </para>
      <para><b>Remark:</b>
         This method can be used to implement fixed-point decimal arithmetic, in
        which each decimal number has a fixed number of digits after the decimal
        point. The following code example returns a fixed-point number with up
        to 20 digits before and exactly 5 digits after the decimal point:
      </para>
      <code>// After performing arithmetic operations, adjust // the number to 5
        digits after the decimal point number = number.Quantize(-5, // five
        digits after the decimal point EContext.ForPrecision(25) // 25-digit
        precision);
      </code>
      <para>A fixed-point decimal arithmetic in which no digits come after the
        decimal point (a desired exponent of 0) is considered an "integer
        arithmetic".
      </para>
    </summary><param name='desiredExponentInt'>The desired exponent for the result. The exponent is the number of
      fractional digits in the result, expressed as a negative number. Can also
      be positive, which eliminates lower-order places from the number. For
      example, -3 means round to the thousandth (10^-3, 0.0001), and 3 means
      round to the thousand (10^3, 1000). A value of 0 rounds the number to an
      integer.
    </param><param name='ctx'>An arithmetic context to control precision and rounding of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the default rounding mode is HalfEven.
    </param><returns>A decimal number with the same value as this object but with the exponent
      changed. Signals FlagInvalid and returns not-a-number (NaN) if this object
      is infinity, if the rounded result can't fit the given precision, or if
      the context defines an exponent range and the given exponent is outside
      that range.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.Quantize(System.Int32,PeterO.Numbers.ERounding)">

            <summary>Returns a decimal number with the same value as this one but a new
      exponent.
      <para><b>Remark:</b>
         This method can be used to implement fixed-point decimal arithmetic, in
        which a fixed number of digits come after the decimal point. A
        fixed-point decimal arithmetic in which no digits come after the decimal
        point (a desired exponent of 0) is considered an "integer arithmetic" .
      </para>
    </summary><param name='desiredExponentInt'>The desired exponent for the result. The exponent is the number of
      fractional digits in the result, expressed as a negative number. Can also
      be positive, which eliminates lower-order places from the number. For
      example, -3 means round to the thousandth (10^-3, 0.0001), and 3 means
      round to the thousand (10^3, 1000). A value of 0 rounds the number to an
      integer.
    </param><param name='rounding'>A rounding mode to use in case the result needs to be rounded to fit the
      given exponent.
    </param><returns>A decimal number with the same value as this object but with the exponent
      changed. Returns not-a-number (NaN) if this object is infinity, or if the
      rounding mode is ERounding.None and the result is not exact.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.Reduce(PeterO.Numbers.EContext)">

            <summary>Removes trailing zeros from this object's mantissa (significand). For
      example, 1.00 becomes 1.
      <para>If this object's value is 0, changes the exponent to 0.
      </para>
    </summary><param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and rounding isn't needed.
    </param><returns>This value with trailing zeros removed. Note that if the result has a
      very high exponent and the context says to clamp high exponents, there may
      still be some trailing zeros in the mantissa (significand).
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.Remainder(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">

            <summary>Finds the remainder that results when dividing two arbitrary-precision
      decimal numbers. The remainder is the value that remains when the absolute
      value of this object is divided by the absolute value of the other object;
      the remainder has the same sign (positive or negative) as this object's
      value.
    </summary><param name='divisor'>The parameter
      <paramref name='divisor'/>
       is an EDecimal object.
    </param><param name='ctx'>The parameter
      <paramref name='ctx'/>
       is an EContext object.
    </param><returns>The remainder of the two numbers. Signals FlagInvalid and returns
      not-a-number (NaN) if the divisor is 0, or if the result doesn't fit the
      given precision.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.RemainderNaturalScale(PeterO.Numbers.EDecimal)">

            <summary>Calculates the remainder of a number by the formula
      <c>"this" - (("this" / "divisor") * "divisor")</c>
    </summary><param name='divisor'>The number to divide by.
    </param><returns>An arbitrary-precision decimal number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.RemainderNaturalScale(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">

            <summary>Calculates the remainder of a number by the formula "this" - (("this" /
      "divisor") * "divisor").
    </summary><param name='divisor'>The number to divide by.
    </param><param name='ctx'>An arithmetic context object to control the precision, rounding, and
      exponent range of the result. This context will be used only in the
      division portion of the remainder calculation; as a result, it's possible
      for the return value to have a higher precision than given in this
      context. Flags will be set on the given context only if the context's
      <c>HasFlags</c>
       is true and the integer part of the division result doesn't fit the
      precision and exponent range without rounding. Can be null, in which the
      precision is unlimited and no additional rounding, other than the rounding
      down to an integer after division, is needed.
    </param><returns>An arbitrary-precision decimal number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.RemainderNear(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">

            <summary>Finds the distance to the closest multiple of the given divisor, based on
      the result of dividing this object's value by another object's value.
      <list type=''>
        <item>If this and the other object divide evenly, the result is 0.
        </item>
        <item>If the remainder's absolute value is less than half of the divisor's
          absolute value, the result has the same sign as this object and will
          be the distance to the closest multiple.
        </item>
        <item>If the remainder's absolute value is more than half of the divisor' s
          absolute value, the result has the opposite sign of this object and
          will be the distance to the closest multiple.
        </item>
        <item>If the remainder's absolute value is exactly half of the divisor's
          absolute value, the result has the opposite sign of this object if the
          quotient, rounded down, is odd, and has the same sign as this object
          if the quotient, rounded down, is even, and the result's absolute
          value is half of the divisor's absolute value.
        </item>
      </list>
       This function is also known as the "IEEE Remainder" function.
    </summary><param name='divisor'>The number to divide by.
    </param><param name='ctx'>An arithmetic context object to control the precision. The rounding and
      exponent range settings of this context are ignored (the rounding mode is
      always treated as HalfEven). If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which the precision is unlimited.
    </param><returns>The distance of the closest multiple. Signals FlagInvalid and returns
      not-a-number (NaN) if the divisor is 0, or either the result of integer
      division (the quotient) or the remainder wouldn't fit the given precision.

    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.RoundToExponent(PeterO.Numbers.EInteger)">

            <summary>Returns a decimal number with the same value as this object but rounded
      to a new exponent if necessary, using the HalfEven rounding mode.
    </summary><param name='exponent'>The minimum exponent the result can have. This is the maximum number of
      fractional digits in the result, expressed as a negative number. Can also
      be positive, which eliminates lower-order places from the number. For
      example, -3 means round to the thousandth (10^-3, 0.0001), and 3 means
      round to the thousand (10^3, 1000). A value of 0 rounds the number to an
      integer.
    </param><returns>A decimal number rounded to the closest value representable for the given
      exponent.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.RoundToExponent(PeterO.Numbers.EInteger,PeterO.Numbers.EContext)">

            <summary>Returns a decimal number with the same value as this object but rounded
      to a new exponent if necessary.
    </summary><param name='exponent'>The minimum exponent the result can have. This is the maximum number of
      fractional digits in the result, expressed as a negative number. Can also
      be positive, which eliminates lower-order places from the number. For
      example, -3 means round to the thousandth (10^-3, 0.0001), and 3 means
      round to the thousand (10^3, 1000). A value of 0 rounds the number to an
      integer.
    </param><param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the default rounding mode is HalfEven.
    </param><returns>A decimal number rounded to the closest value representable in the given
      precision. If the result can't fit the precision, additional digits are
      discarded to make it fit. Signals FlagInvalid and returns not-a-number
      (NaN) if the precision context defines an exponent range, the new exponent
      must be changed to the given exponent when rounding, and the given
      exponent is outside of the valid range of the arithmetic context.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.RoundToExponent(PeterO.Numbers.EInteger,PeterO.Numbers.ERounding)">

            <summary>Returns a decimal number with the same value as this object but rounded
      to a new exponent if necessary, using the given rounding mode.
    </summary><param name='exponent'>The minimum exponent the result can have. This is the maximum number of
      fractional digits in the result, expressed as a negative number. Can also
      be positive, which eliminates lower-order places from the number. For
      example, -3 means round to the thousandth (10^-3, 0.0001), and 3 means
      round to the thousand (10^3, 1000). A value of 0 rounds the number to an
      integer.
    </param><param name='rounding'>Desired mode for rounding this number's value.
    </param><returns>A decimal number rounded to the closest value representable for the given
      exponent.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.RoundToExponent(System.Int32)">

            <summary>Returns a decimal number with the same value as this object but rounded
      to a new exponent if necessary, using the HalfEven rounding mode.
    </summary><param name='exponentSmall'>The minimum exponent the result can have. This is the maximum number of
      fractional digits in the result, expressed as a negative number. Can also
      be positive, which eliminates lower-order places from the number. For
      example, -3 means round to the thousandth (10^-3, 0.0001), and 3 means
      round to the thousand (10^3, 1000). A value of 0 rounds the number to an
      integer.
    </param><returns>A decimal number rounded to the closest value representable for the given
      exponent.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.RoundToExponent(System.Int32,PeterO.Numbers.EContext)">

            <summary>Returns a decimal number with the same value as this object but rounded
      to a new exponent if necessary.
    </summary><param name='exponentSmall'>The minimum exponent the result can have. This is the maximum number of
      fractional digits in the result, expressed as a negative number. Can also
      be positive, which eliminates lower-order places from the number. For
      example, -3 means round to the thousandth (10^-3, 0.0001), and 3 means
      round to the thousand (10^3, 1000). A value of 0 rounds the number to an
      integer.
    </param><param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the default rounding mode is HalfEven.
    </param><returns>A decimal number rounded to the closest value representable in the given
      precision. If the result can't fit the precision, additional digits are
      discarded to make it fit. Signals FlagInvalid and returns not-a-number
      (NaN) if the precision context defines an exponent range, the new exponent
      must be changed to the given exponent when rounding, and the given
      exponent is outside of the valid range of the arithmetic context.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.RoundToExponent(System.Int32,PeterO.Numbers.ERounding)">

            <summary>Returns a decimal number with the same value as this object but rounded
      to a new exponent if necessary.
    </summary><param name='exponentSmall'>The minimum exponent the result can have. This is the maximum number of
      fractional digits in the result, expressed as a negative number. Can also
      be positive, which eliminates lower-order places from the number. For
      example, -3 means round to the thousandth (10^-3, 0.0001), and 3 means
      round to the thousand (10^3, 1000). A value of 0 rounds the number to an
      integer.
    </param><param name='rounding'>The desired mode to use to round the given number to the given exponent.
    </param><returns>A decimal number rounded to the given negative number of decimal places.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.RoundToExponentExact(PeterO.Numbers.EInteger,PeterO.Numbers.EContext)">

            <summary>Returns a decimal number with the same value as this object but rounded
      to the given exponent, and signals an inexact flag if the result would be
      inexact.
    </summary><param name='exponent'>The minimum exponent the result can have. This is the maximum number of
      fractional digits in the result, expressed as a negative number. Can also
      be positive, which eliminates lower-order places from the number. For
      example, -3 means round to the thousandth (10^-3, 0.0001), and 3 means
      round to the thousand (10^3, 1000). A value of 0 rounds the number to an
      integer.
    </param><param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the default rounding mode is HalfEven.
    </param><returns>A decimal number rounded to the closest value representable in the given
      precision. Signals FlagInvalid and returns not-a-number (NaN) if the
      result can't fit the given precision without rounding. Signals FlagInvalid
      and returns not-a-number (NaN) if the arithmetic context defines an
      exponent range, the new exponent must be changed to the given exponent
      when rounding, and the given exponent is outside of the valid range of the
      arithmetic context.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.RoundToExponentExact(System.Int32,PeterO.Numbers.EContext)">

            <summary>Returns a decimal number with the same value as this object but rounded
      to an integer, and signals an inexact flag if the result would be inexact.

    </summary><param name='exponentSmall'>The minimum exponent the result can have. This is the maximum number of
      fractional digits in the result, expressed as a negative number. Can also
      be positive, which eliminates lower-order places from the number. For
      example, -3 means round to the thousandth (10^-3, 0.0001), and 3 means
      round to the thousand (10^3, 1000). A value of 0 rounds the number to an
      integer.
    </param><param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the default rounding mode is HalfEven.
    </param><returns>A decimal number rounded to the closest value representable in the given
      precision. Signals FlagInvalid and returns not-a-number (NaN) if the
      result can't fit the given precision without rounding. Signals FlagInvalid
      and returns not-a-number (NaN) if the arithmetic context defines an
      exponent range, the new exponent must be changed to the given exponent
      when rounding, and the given exponent is outside of the valid range of the
      arithmetic context.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.RoundToExponentExact(System.Int32,PeterO.Numbers.ERounding)">

            <summary>Returns a decimal number with the same value as this object but rounded
      to an integer, and signals an inexact flag if the result would be inexact.

    </summary><param name='exponentSmall'>The minimum exponent the result can have. This is the maximum number of
      fractional digits in the result, expressed as a negative number. Can also
      be positive, which eliminates lower-order places from the number. For
      example, -3 means round to the thousandth (10^-3, 0.0001), and 3 means
      round to the thousand (10^3, 1000). A value of 0 rounds the number to an
      integer.
    </param><param name='rounding'>Desired mode for rounding this object's value.
    </param><returns>A decimal number rounded to the closest value representable using the
      given exponent.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.RoundToIntegerExact(PeterO.Numbers.EContext)">

            <summary>Returns a decimal number with the same value as this object but rounded
      to an integer, and signals an inexact flag if the result would be inexact.

    </summary><param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the default rounding mode is HalfEven.
    </param><returns>A decimal number rounded to the closest integer representable in the
      given precision. Signals FlagInvalid and returns not-a-number (NaN) if the
      result can't fit the given precision without rounding. Signals FlagInvalid
      and returns not-a-number (NaN) if the arithmetic context defines an
      exponent range, the new exponent must be changed to 0 when rounding, and 0
      is outside of the valid range of the arithmetic context.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.RoundToIntegerNoRoundedFlag(PeterO.Numbers.EContext)">

            <summary>Returns a decimal number with the same value as this object but rounded
      to an integer, without adding the
      <c>FlagInexact</c>
       or
      <c>FlagRounded</c>
       flags.
    </summary><param name='ctx'>An arithmetic context to control precision and rounding of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags), except
      that this function will never add the
      <c>FlagRounded</c>
       and
      <c>FlagInexact</c>
       flags (the only difference between this and RoundToExponentExact). Can be
      null, in which case the default rounding mode is HalfEven.
    </param><returns>A decimal number rounded to the closest integer representable in the
      given precision. If the result can't fit the precision, additional digits
      are discarded to make it fit. Signals FlagInvalid and returns not-a-number
      (NaN) if the precision context defines an exponent range, the new exponent
      must be changed to 0 when rounding, and 0 is outside of the valid range of
      the arithmetic context.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.RoundToIntegralExact(PeterO.Numbers.EContext)">

            <summary>Returns a decimal number with the same value as this object but rounded
      to an integer, and signals an inexact flag if the result would be inexact.

    </summary><param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the default rounding mode is HalfEven.
    </param><returns>A decimal number rounded to the closest integer representable in the
      given precision. Signals FlagInvalid and returns not-a-number (NaN) if the
      result can't fit the given precision without rounding. Signals FlagInvalid
      and returns not-a-number (NaN) if the arithmetic context defines an
      exponent range, the new exponent must be changed to 0 when rounding, and 0
      is outside of the valid range of the arithmetic context.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.RoundToIntegralNoRoundedFlag(PeterO.Numbers.EContext)">

            <summary>Returns a decimal number with the same value as this object but rounded
      to an integer, without adding the
      <c>FlagInexact</c>
       or
      <c>FlagRounded</c>
       flags.
    </summary><param name='ctx'>An arithmetic context to control precision and rounding of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags), except
      that this function will never add the
      <c>FlagRounded</c>
       and
      <c>FlagInexact</c>
       flags (the only difference between this and RoundToExponentExact). Can be
      null, in which case the default rounding mode is HalfEven.
    </param><returns>A decimal number rounded to the closest integer representable in the
      given precision. If the result can't fit the precision, additional digits
      are discarded to make it fit. Signals FlagInvalid and returns not-a-number
      (NaN) if the precision context defines an exponent range, the new exponent
      must be changed to 0 when rounding, and 0 is outside of the valid range of
      the arithmetic context.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.RoundToPrecision(PeterO.Numbers.EContext)">
<summary>Rounds this object's value to a given precision, using the given rounding
      mode and range of exponent.
    </summary>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and no rounding is needed.
    </param>
    <returns>The closest value to this object's value, rounded to the specified
      precision. Returns the same value as this object if &#x22;ctx&#x22; is
      null or the precision and exponent range are unlimited.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.EDecimal.ScaleByPowerOfTen(PeterO.Numbers.EInteger)">

            <summary>Returns a number similar to this number but with the scale adjusted.
    </summary><param name='bigPlaces'>The power of 10 to scale by.
    </param><returns>An arbitrary-precision decimal number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.ScaleByPowerOfTen(PeterO.Numbers.EInteger,PeterO.Numbers.EContext)">

            <summary>Returns a number similar to this number but with its scale adjusted.
    </summary><param name='bigPlaces'>The power of 10 to scale by.
    </param><param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and no rounding is needed.
    </param><returns>A number whose exponent is increased by
      <paramref name='bigPlaces'/>
       .
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.ScaleByPowerOfTen(System.Int32)">

            <summary>Returns a number similar to this number but with the scale adjusted.
    </summary><param name='places'>The power of 10 to scale by.
    </param><returns>An arbitrary-precision decimal number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.ScaleByPowerOfTen(System.Int32,PeterO.Numbers.EContext)">

            <summary>Returns a number similar to this number but with the scale adjusted.
    </summary><param name='places'>The power of 10 to scale by.
    </param><param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and no rounding is needed.
    </param><returns>An arbitrary-precision decimal number.
    </returns>

</doc>
<doc name="P:PeterO.Numbers.EDecimal.Sign">

            <summary>Gets this value's sign: -1 if negative; 1 if positive; 0 if zero.
    </summary><value>This value's sign: -1 if negative; 1 if positive; 0 if zero.
    </value>

</doc>
<doc name="F:PeterO.Numbers.EDecimal.SignalingNaN">

            <summary>A not-a-number value that signals an invalid operation flag when it's
      passed as an argument to any arithmetic operation in arbitrary-precision
      decimal.
    </summary>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.Sqrt(PeterO.Numbers.EContext)">
<summary>Finds the square root of this object's value.
    </summary>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags).
      <i>
         This parameter can't be null, as the square root function's results are
        generally not exact for many inputs.
      </i>
       (Unlike in the General Decimal Arithmetic Specification, any rounding
      mode is allowed.).
    </param>
    <returns>The square root. Signals the flag FlagInvalid and returns NaN if this
      object is less than 0 (the square root would be a complex number, but the
      return value is still NaN). Signals FlagInvalid and returns not-a-number
      (NaN) if the parameter &#x22;ctx&#x22; is null or the precision is
      unlimited (the context's Precision property is 0).
    </returns>
</doc>
<doc name="M:PeterO.Numbers.EDecimal.SquareRoot(PeterO.Numbers.EContext)">
<summary>Finds the square root of this object's value.
    </summary>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags).
      <i>
         This parameter can't be null, as the square root function's results are
        generally not exact for many inputs.
      </i>
       (Unlike in the General Decimal Arithmetic Specification, any rounding
      mode is allowed.).
    </param>
    <returns>The square root. Signals the flag FlagInvalid and returns NaN if this
      object is less than 0 (the square root would be a complex number, but the
      return value is still NaN). Signals FlagInvalid and returns not-a-number
      (NaN) if the parameter &#x22;ctx&#x22; is null or the precision is
      unlimited (the context's Precision property is 0).
    </returns>
</doc>
<doc name="M:PeterO.Numbers.EDecimal.Subtract(PeterO.Numbers.EDecimal)">

            <summary>Subtracts an arbitrary-precision decimal number from this instance and
      returns the result.
    </summary><param name='otherValue'>The number to subtract from this instance's value.
    </param><returns>The difference of the two objects.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.Subtract(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
<summary>Subtracts an arbitrary-precision decimal number from this instance.
    </summary>
    <param name='otherValue'>The number to subtract from this instance's value.
    </param>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and no rounding is needed.
    </param>
    <returns>The difference of the two objects.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter &#x22;otherValue&#x22; is null.
    </exception>
</doc>
<doc name="F:PeterO.Numbers.EDecimal.Ten">

            <summary>Represents the number 10.
    </summary>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.ToByteChecked">

            <summary>Converts this number's value to a byte (from 0 to 255) if it can fit in a
      byte (from 0 to 255) after truncating to an integer.
    </summary><returns>This number's value, truncated to a byte (from 0 to 255).
    </returns><exception cref='T:System.OverflowException'>This value is infinity or not-a-number, or the truncated integer is less
      than 0 or greater than 255.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.ToByteIfExact">

            <summary>Converts this number's value to a byte (from 0 to 255) if it can fit in a
      byte (from 0 to 255) without rounding to a different numerical value.
    </summary><returns>This number's value as a byte (from 0 to 255).
    </returns><exception cref='T:System.ArithmeticException'>This value is infinity or not-a-number, is not an exact integer, or is
      less than 0 or greater than 255.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.ToByteUnchecked">

            <summary>Truncates this number's value to an integer and returns the
      least-significant bits of its two's-complement form as a byte (from 0 to
      255).
    </summary><returns>This number, converted to a byte (from 0 to 255). Returns 0 if this value
      is infinity or not-a-number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.ToDecimal">

            <summary>Converts this value to a
      <c>decimal</c>
       under the Common Language Infrastructure (see
      <see cref='T:PeterO.Numbers.EDecimal'>
         "Forms of numbers"
      </see>
       ), using the half-even rounding mode.
    </summary><returns>A
      <c>decimal</c>
       under the Common Language Infrastructure (usually a .NET Framework
      decimal).
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.ToDouble">

            <summary>Converts this value to its closest equivalent as a 64-bit floating-point
      number. The half-even rounding mode is used.
      <para>If this value is a NaN, sets the high bit of the 64-bit floating point
        number's significand area for a quiet NaN, and clears it for a signaling
        NaN. Then the other bits of the significand area are set to the lowest
        bits of this object's unsigned mantissa (significand), and the
        next-highest bit of the significand area is set if those bits are all
        zeros and this is a signaling NaN. Unfortunately, in the .NET
        implementation, the return value of this method may be a quiet NaN even
        if a signaling NaN would otherwise be generated.
      </para>
    </summary><returns>The closest 64-bit floating-point number to this value. The return value
      can be positive infinity or negative infinity if this value exceeds the
      range of a 64-bit floating point number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.ToEFloat">

            <summary>Creates a binary floating-point number from this object's value. Note
      that if the binary floating-point number contains a negative exponent, the
      resulting value might not be exact, in which case the resulting binary
      float will be an approximation of this decimal number's value.
    </summary><returns>An arbitrary-precision binary floating-point number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.ToEFloat(PeterO.Numbers.EContext)">

            <summary>Creates a binary floating-point number from this object's value. Note
      that if the binary floating-point number contains a negative exponent, the
      resulting value might not be exact, in which case the resulting binary
      float will be an approximation of this decimal number's value.
    </summary><param name='ec'>The parameter
      <paramref name='ec'/>
       is an EContext object.
    </param><returns>An arbitrary-precision float floating-point number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.ToEInteger">

            <summary>Converts this value to an arbitrary-precision integer. Any fractional
      part in this value will be discarded when converting to an
      arbitrary-precision integer.
    </summary><returns>An arbitrary-precision integer.
    </returns><exception cref='T:System.OverflowException'>This object's value is infinity or not-a-number (NaN).
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.ToEIntegerExact">

            <summary>Converts this value to an arbitrary-precision integer, checking whether
      the fractional part of the value would be lost.
    </summary><returns>An arbitrary-precision integer.
    </returns><exception cref='T:System.OverflowException'>This object's value is infinity or not-a-number (NaN).
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.ToEIntegerIfExact">

            <summary>Converts this value to an arbitrary-precision integer, checking whether
      the fractional part of the value would be lost.
    </summary><returns>An arbitrary-precision integer.
    </returns><exception cref='T:System.OverflowException'>This object's value is infinity or not-a-number (NaN).
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.ToEngineeringString">

            <summary>Same as ToString(), except that when an exponent is used it will be a
      multiple of 3.
    </summary><returns>A text string.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.ToExtendedFloat">

            <summary>Creates a binary floating-point number from this object's value. Note
      that if the binary floating-point number contains a negative exponent, the
      resulting value might not be exact, in which case the resulting binary
      float will be an approximation of this decimal number's value.
    </summary><returns>An arbitrary-precision binary floating-point number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.ToInt16Checked">

            <summary>Converts this number's value to a 16-bit signed integer if it can fit in
      a 16-bit signed integer after truncating to an integer.
    </summary><returns>This number's value, truncated to a 16-bit signed integer.
    </returns><exception cref='T:System.OverflowException'>This value is infinity or not-a-number, or the truncated integer is less
      than -32768 or greater than 32767.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.ToInt16IfExact">

            <summary>Converts this number's value to a 16-bit signed integer if it can fit in
      a 16-bit signed integer without rounding to a different numerical value.
    </summary><returns>This number's value as a 16-bit signed integer.
    </returns><exception cref='T:System.ArithmeticException'>This value is infinity or not-a-number, is not an exact integer, or is
      less than -32768 or greater than 32767.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.ToInt16Unchecked">

            <summary>Truncates this number's value to an integer and returns the
      least-significant bits of its two's-complement form as a 16-bit signed
      integer.
    </summary><returns>This number, converted to a 16-bit signed integer. Returns 0 if this
      value is infinity or not-a-number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.ToInt32Checked">

            <summary>Converts this number's value to a 32-bit signed integer if it can fit in
      a 32-bit signed integer after truncating to an integer.
    </summary><returns>This number's value, truncated to a 32-bit signed integer.
    </returns><exception cref='T:System.OverflowException'>This value is infinity or not-a-number, or the truncated integer is less
      than -2147483648 or greater than 2147483647.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.ToInt32IfExact">

            <summary>Converts this number's value to a 32-bit signed integer if it can fit in
      a 32-bit signed integer without rounding to a different numerical value.
    </summary><returns>This number's value as a 32-bit signed integer.
    </returns><exception cref='T:System.ArithmeticException'>This value is infinity or not-a-number, is not an exact integer, or is
      less than -2147483648 or greater than 2147483647.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.ToInt32Unchecked">

            <summary>Truncates this number's value to an integer and returns the
      least-significant bits of its two's-complement form as a 32-bit signed
      integer.
    </summary><returns>This number, converted to a 32-bit signed integer. Returns 0 if this
      value is infinity or not-a-number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.ToInt64Checked">

            <summary>Converts this number's value to a 64-bit signed integer if it can fit in
      a 64-bit signed integer after truncating to an integer.
    </summary><returns>This number's value, truncated to a 64-bit signed integer.
    </returns><exception cref='T:System.OverflowException'>This value is infinity or not-a-number, or the truncated integer is less
      than -9223372036854775808 or greater than 9223372036854775807.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.ToInt64IfExact">

            <summary>Converts this number's value to a 64-bit signed integer if it can fit in
      a 64-bit signed integer without rounding to a different numerical value.
    </summary><returns>This number's value as a 64-bit signed integer.
    </returns><exception cref='T:System.ArithmeticException'>This value is infinity or not-a-number, is not an exact integer, or is
      less than -9223372036854775808 or greater than 9223372036854775807.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.ToInt64Unchecked">

            <summary>Truncates this number's value to an integer and returns the
      least-significant bits of its two's-complement form as a 64-bit signed
      integer.
    </summary><returns>This number, converted to a 64-bit signed integer. Returns 0 if this
      value is infinity or not-a-number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.ToPlainString">

            <summary>Converts this value to a string, but without using exponential notation.
    </summary><returns>A text string.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.ToSByteChecked">

            <summary>Converts this number's value to an 8-bit signed integer if it can fit in
      an 8-bit signed integer after truncating to an integer.
    </summary><returns>This number's value, truncated to an 8-bit signed integer.
    </returns><exception cref='T:System.OverflowException'>This value is infinity or not-a-number, or the truncated integer is less
      than -128 or greater than 127.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.ToSByteIfExact">

            <summary>Converts this number's value to an 8-bit signed integer if it can fit in
      an 8-bit signed integer without rounding to a different numerical value.
    </summary><returns>This number's value as an 8-bit signed integer.
    </returns><exception cref='T:System.ArithmeticException'>This value is infinity or not-a-number, is not an exact integer, or is
      less than -128 or greater than 127.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.ToSByteUnchecked">

            <summary>Truncates this number's value to an integer and returns the
      least-significant bits of its two's-complement form as an 8-bit signed
      integer.
    </summary><returns>This number, converted to an 8-bit signed integer. Returns 0 if this
      value is infinity or not-a-number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.ToSingle">

            <summary>Converts this value to its closest equivalent as a 32-bit floating-point
      number. The half-even rounding mode is used.
      <para>If this value is a NaN, sets the high bit of the 32-bit floating point
        number's significand area for a quiet NaN, and clears it for a signaling
        NaN. Then the other bits of the significand area are set to the lowest
        bits of this object's unsigned mantissa (significand), and the
        next-highest bit of the significand area is set if those bits are all
        zeros and this is a signaling NaN. Unfortunately, in the .NET
        implementation, the return value of this method may be a quiet NaN even
        if a signaling NaN would otherwise be generated.
      </para>
    </summary><returns>The closest 32-bit binary floating-point number to this value. The return
      value can be positive infinity or negative infinity if this value exceeds
      the range of a 32-bit floating point number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.ToString">

            <summary>Converts this value to a string. Returns a value compatible with this
      class's FromString method.
    </summary><returns>A string representation of this object. The text string will be in
      exponential notation if the exponent is greater than 0 or if the number's
      first nonzero digit is more than five digits after the decimal point.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.ToUInt16Checked">

            <summary>Converts this number's value to a 16-bit unsigned integer if it can fit
      in a 16-bit unsigned integer after truncating to an integer.
    </summary><returns>This number's value, truncated to a 16-bit unsigned integer.
    </returns><exception cref='T:System.OverflowException'>This value is infinity or not-a-number, or the truncated integer is less
      than 0 or greater than 65535.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.ToUInt16IfExact">

            <summary>Converts this number's value to a 16-bit unsigned integer if it can fit
      in a 16-bit unsigned integer without rounding to a different numerical
      value.
    </summary><returns>This number's value as a 16-bit unsigned integer.
    </returns><exception cref='T:System.ArithmeticException'>This value is infinity or not-a-number, is not an exact integer, or is
      less than 0 or greater than 65535.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.ToUInt16Unchecked">

            <summary>Truncates this number's value to an integer and returns the
      least-significant bits of its two's-complement form as a 16-bit unsigned
      integer.
    </summary><returns>This number, converted to a 16-bit unsigned integer. Returns 0 if this
      value is infinity or not-a-number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.ToUInt32Checked">

            <summary>Converts this number's value to a 32-bit signed integer if it can fit in
      a 32-bit signed integer after truncating to an integer.
    </summary><returns>This number's value, truncated to a 32-bit signed integer.
    </returns><exception cref='T:System.OverflowException'>This value is infinity or not-a-number, or the truncated integer is less
      than 0 or greater than 4294967295.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.ToUInt32IfExact">

            <summary>Converts this number's value to a 32-bit signed integer if it can fit in
      a 32-bit signed integer without rounding to a different numerical value.
    </summary><returns>This number's value as a 32-bit signed integer.
    </returns><exception cref='T:System.ArithmeticException'>This value is infinity or not-a-number, is not an exact integer, or is
      less than 0 or greater than 4294967295.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.ToUInt32Unchecked">

            <summary>Truncates this number's value to an integer and returns the
      least-significant bits of its two's-complement form as a 32-bit signed
      integer.
    </summary><returns>This number, converted to a 32-bit signed integer. Returns 0 if this
      value is infinity or not-a-number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.ToUInt64Checked">

            <summary>Converts this number's value to a 64-bit unsigned integer if it can fit
      in a 64-bit unsigned integer after truncating to an integer.
    </summary><returns>This number's value, truncated to a 64-bit unsigned integer.
    </returns><exception cref='T:System.OverflowException'>This value is infinity or not-a-number, or the truncated integer is less
      than 0 or greater than 18446744073709551615.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.ToUInt64IfExact">

            <summary>Converts this number's value to a 64-bit unsigned integer if it can fit
      in a 64-bit unsigned integer without rounding to a different numerical
      value.
    </summary><returns>This number's value as a 64-bit unsigned integer.
    </returns><exception cref='T:System.ArithmeticException'>This value is infinity or not-a-number, is not an exact integer, or is
      less than 0 or greater than 18446744073709551615.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.ToUInt64Unchecked">

            <summary>Truncates this number's value to an integer and returns the
      least-significant bits of its two's-complement form as a 64-bit unsigned
      integer.
    </summary><returns>This number, converted to a 64-bit unsigned integer. Returns 0 if this
      value is infinity or not-a-number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.Ulp">

            <summary>Returns the unit in the last place. The mantissa (significand) will be 1
      and the exponent will be this number's exponent. Returns 1 with an
      exponent of 0 if this number is infinity or not-a-number (NaN).
    </summary><returns>An arbitrary-precision decimal number.
    </returns>

</doc>
<doc name="P:PeterO.Numbers.EDecimal.UnsignedMantissa">

            <summary>Gets the absolute value of this object's unscaled value.
    </summary><value>The absolute value of this object's unscaled value.
    </value>

</doc>
<doc name="F:PeterO.Numbers.EDecimal.Zero">

            <summary>Represents the number 0.
    </summary>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.op_Addition(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal)">

            <summary>Adds two arbitrary-precision decimal floating-point numbers and returns
      the result.
    </summary><param name='bthis'>The first arbitrary-precision decimal floating-point number.
    </param><param name='otherValue'>The second decimal binary floating-point number.
    </param><returns>The sum of the two objects.
    </returns><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='bthis'/>
       or
      <paramref name='otherValue'/>
       is null.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.op_Division(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal)">

            <summary>Divides this object by another decimal number and returns the result.
      When possible, the result will be exact.
    </summary><param name='dividend'>The number that will be divided by the divisor.
    </param><param name='divisor'>The number to divide by.
    </param><returns>The quotient of the two numbers. Returns infinity if the divisor is 0 and
      the dividend is nonzero. Returns not-a-number (NaN) if the divisor and the
      dividend are 0. Returns NaN if the result can't be exact because it would
      have a nonterminating decimal expansion.
    </returns><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='dividend'/>
       is null.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.op_Explicit(PeterO.Numbers.EDecimal)~PeterO.Numbers.EInteger">

            <summary>Converts an arbitrary-precision decimal floating-point number to an
      arbitrary-precision integer. Any fractional part in this value will be
      discarded when converting to an arbitrary-precision integer.
    </summary><param name='bigValue'>The number to convert as an arbitrary-precision decimal.
    </param><returns>An arbitrary-precision integer.
    </returns><exception cref='T:System.OverflowException'>This object's value is infinity or not-a-number (NaN).
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.op_Explicit(PeterO.Numbers.EDecimal)~System.Byte">

            <summary>Converts an arbitrary-precision decimal number to a byte (from 0 to 255)
      if it can fit in a byte (from 0 to 255) after truncating to an integer.
    </summary><param name='input'>The number to convert as an arbitrary-precision decimal number.
    </param><returns>The value of
      <paramref name='input'/>
       , truncated to a byte (from 0 to 255).
    </returns><exception cref='T:System.OverflowException'>The parameter
      <paramref name='input'/>
       is infinity or not-a-number, or the truncated integer is less than 0 or
      greater than 255.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.op_Explicit(PeterO.Numbers.EDecimal)~System.Decimal">

            <summary>Converts an arbitrary-precision decimal's value to a
      <c>decimal</c>
       under the Common Language Infrastructure (see
      <see cref='T:PeterO.Numbers.EDecimal'>
         "Forms of numbers"
      </see>
       ), using the half-even rounding mode.
    </summary><param name='bigValue'>The parameter
      <paramref name='bigValue'/>
       is an arbitrary-precision decimal floating-point number.
    </param><returns>A
      <c>decimal</c>
       under the Common Language Infrastructure (usually a .NET Framework
      decimal).
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.op_Explicit(PeterO.Numbers.EDecimal)~System.Double">

            <summary>Converts this value to its closest equivalent as a 64-bit floating-point
      number. The half-even rounding mode is used.
      <para>If this value is a NaN, sets the high bit of the 64-bit floating point
        number's significand area for a quiet NaN, and clears it for a signaling
        NaN. Then the other bits of the significand area are set to the lowest
        bits of this object's unsigned mantissa (significand), and the
        next-highest bit of the significand area is set if those bits are all
        zeros and this is a signaling NaN. Unfortunately, in the .NET
        implementation, the return value of this method may be a quiet NaN even
        if a signaling NaN would otherwise be generated.
      </para>
    </summary><param name='bigValue'>The value to convert to a 64-bit floating-point number.
    </param><returns>The closest 64-bit floating-point number to this value. The return value
      can be positive infinity or negative infinity if this value exceeds the
      range of a 64-bit floating point number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.op_Explicit(PeterO.Numbers.EDecimal)~System.Int16">

            <summary>Converts an arbitrary-precision decimal number to a 16-bit signed integer
      if it can fit in a 16-bit signed integer after truncating to an integer.
    </summary><param name='input'>The number to convert as an arbitrary-precision decimal number.
    </param><returns>The value of
      <paramref name='input'/>
       , truncated to a 16-bit signed integer.
    </returns><exception cref='T:System.OverflowException'>The parameter
      <paramref name='input'/>
       is infinity or not-a-number, or the truncated integer is less than -32768
      or greater than 32767.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.op_Explicit(PeterO.Numbers.EDecimal)~System.Int32">

            <summary>Converts an arbitrary-precision decimal number to a 32-bit signed integer
      if it can fit in a 32-bit signed integer after truncating to an integer.
    </summary><param name='input'>The number to convert as an arbitrary-precision decimal number.
    </param><returns>The value of
      <paramref name='input'/>
       , truncated to a 32-bit signed integer.
    </returns><exception cref='T:System.OverflowException'>The parameter
      <paramref name='input'/>
       is infinity or not-a-number, or the truncated integer is less than
      -2147483648 or greater than 2147483647.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.op_Explicit(PeterO.Numbers.EDecimal)~System.Int64">

            <summary>Converts an arbitrary-precision decimal number to a 64-bit signed integer
      if it can fit in a 64-bit signed integer after truncating to an integer.
    </summary><param name='input'>The number to convert as an arbitrary-precision decimal number.
    </param><returns>The value of
      <paramref name='input'/>
       , truncated to a 64-bit signed integer.
    </returns><exception cref='T:System.OverflowException'>The parameter
      <paramref name='input'/>
       is infinity or not-a-number, or the truncated integer is less than
      -9223372036854775808 or greater than 9223372036854775807.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.op_Explicit(PeterO.Numbers.EDecimal)~System.SByte">

            <summary>Converts an arbitrary-precision decimal number to an 8-bit signed integer
      if it can fit in an 8-bit signed integer after truncating to an integer.
    </summary><param name='input'>The number to convert as an arbitrary-precision decimal number.
    </param><returns>The value of
      <paramref name='input'/>
       , truncated to an 8-bit signed integer.
    </returns><exception cref='T:System.OverflowException'>The parameter
      <paramref name='input'/>
       is infinity or not-a-number, or the truncated integer is less than -128
      or greater than 127.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.op_Explicit(PeterO.Numbers.EDecimal)~System.Single">

            <summary>Converts this value to its closest equivalent as a 32-bit floating-point
      number. The half-even rounding mode is used.
      <para>If this value is a NaN, sets the high bit of the 32-bit floating point
        number's significand area for a quiet NaN, and clears it for a signaling
        NaN. Then the other bits of the significand area are set to the lowest
        bits of this object's unsigned mantissa (significand), and the
        next-highest bit of the significand area is set if those bits are all
        zeros and this is a signaling NaN. Unfortunately, in the .NET
        implementation, the return value of this method may be a quiet NaN even
        if a signaling NaN would otherwise be generated.
      </para>
    </summary><param name='bigValue'>The number to convert as an arbitrary-precision decimal number.
    </param><returns>The closest 32-bit binary floating-point number to this value. The return
      value can be positive infinity or negative infinity if this value exceeds
      the range of a 32-bit floating point number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.op_Explicit(PeterO.Numbers.EDecimal)~System.UInt16">

            <summary>Converts an arbitrary-precision decimal number to a 16-bit unsigned
      integer if it can fit in a 16-bit unsigned integer after truncating to an
      integer.
    </summary><param name='input'>The number to convert as an arbitrary-precision decimal number.
    </param><returns>The value of
      <paramref name='input'/>
       , truncated to a 16-bit unsigned integer.
    </returns><exception cref='T:System.OverflowException'>The parameter
      <paramref name='input'/>
       is infinity or not-a-number, or the truncated integer is less than 0 or
      greater than 65535.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.op_Explicit(PeterO.Numbers.EDecimal)~System.UInt32">

            <summary>Converts an arbitrary-precision decimal number to a 32-bit signed integer
      if it can fit in a 32-bit signed integer after truncating to an integer.
    </summary><param name='input'>The number to convert as an arbitrary-precision decimal number.
    </param><returns>The value of
      <paramref name='input'/>
       , truncated to a 32-bit signed integer.
    </returns><exception cref='T:System.OverflowException'>The parameter
      <paramref name='input'/>
       is infinity or not-a-number, or the truncated integer is less than 0 or
      greater than 4294967295.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.op_Explicit(PeterO.Numbers.EDecimal)~System.UInt64">

            <summary>Converts an arbitrary-precision decimal number to a 64-bit unsigned
      integer if it can fit in a 64-bit unsigned integer after truncating to an
      integer.
    </summary><param name='input'>The number to convert as an arbitrary-precision decimal number.
    </param><returns>The value of
      <paramref name='input'/>
       , truncated to a 64-bit unsigned integer.
    </returns><exception cref='T:System.OverflowException'>The parameter
      <paramref name='input'/>
       is infinity or not-a-number, or the truncated integer is less than 0 or
      greater than 18446744073709551615.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.op_Implicit(PeterO.Numbers.EInteger)~PeterO.Numbers.EDecimal">

            <summary>Converts an arbitrary-precision integer to an arbitrary precision
      decimal.
    </summary><param name='eint'>An arbitrary-precision integer.
    </param><returns>An arbitrary-precision decimal number with the exponent set to 0.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.op_Implicit(System.Byte)~PeterO.Numbers.EDecimal">

            <summary>Converts a byte (from 0 to 255) to an arbitrary-precision decimal number.

    </summary><param name='inputByte'>The number to convert as a byte (from 0 to 255).
    </param><returns>The value of
      <paramref name='inputByte'/>
       as an arbitrary-precision decimal number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.op_Implicit(System.Decimal)~PeterO.Numbers.EDecimal">

            <summary>Converts an arbitrary-precision decimal number to a
      <c>decimal</c>
       under the Common Language Infrastructure (see
      <see cref='T:PeterO.Numbers.EDecimal'>
         "Forms of numbers"
      </see>
       ), using the half-even rounding mode.
    </summary><param name='dec'>The number to convert as an arbitrary-precision decimal floating-point
      number.
    </param><returns>A
      <c>decimal</c>
       under the Common Language Infrastructure (usually a .NET Framework
      decimal).
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.op_Implicit(System.Int16)~PeterO.Numbers.EDecimal">

            <summary>Converts a 16-bit signed integer to an arbitrary-precision decimal
      number.
    </summary><param name='inputInt16'>The number to convert as a 16-bit signed integer.
    </param><returns>The value of
      <paramref name='inputInt16'/>
       as an arbitrary-precision decimal number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.op_Implicit(System.Int32)~PeterO.Numbers.EDecimal">

            <summary>Converts a 32-bit signed integer to an arbitrary-precision decimal
      number.
    </summary><param name='inputInt32'>The number to convert as a 32-bit signed integer.
    </param><returns>The value of
      <paramref name='inputInt32'/>
       as an arbitrary-precision decimal number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.op_Implicit(System.Int64)~PeterO.Numbers.EDecimal">

            <summary>Converts a 64-bit signed integer to an arbitrary-precision decimal
      number.
    </summary><param name='inputInt64'>The number to convert as a 64-bit signed integer.
    </param><returns>The value of
      <paramref name='inputInt64'/>
       as an arbitrary-precision decimal number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.op_Implicit(System.SByte)~PeterO.Numbers.EDecimal">

            <summary>Converts an 8-bit signed integer to an arbitrary-precision decimal
      number.
    </summary><param name='inputSByte'>The number to convert as an 8-bit signed integer.
    </param><returns>The value of
      <paramref name='inputSByte'/>
       as an arbitrary-precision decimal number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.op_Implicit(System.UInt16)~PeterO.Numbers.EDecimal">

            <summary>Converts a 16-bit unsigned integer to an arbitrary-precision decimal
      number.
    </summary><param name='inputUInt16'>The number to convert as a 16-bit unsigned integer.
    </param><returns>The value of
      <paramref name='inputUInt16'/>
       as an arbitrary-precision decimal number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.op_Implicit(System.UInt32)~PeterO.Numbers.EDecimal">

            <summary>Converts a 32-bit signed integer to an arbitrary-precision decimal
      number.
    </summary><param name='inputUInt32'>The number to convert as a 32-bit signed integer.
    </param><returns>The value of
      <paramref name='inputUInt32'/>
       as an arbitrary-precision decimal number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.op_Implicit(System.UInt64)~PeterO.Numbers.EDecimal">

            <summary>Converts a 64-bit unsigned integer to an arbitrary-precision decimal
      number.
    </summary><param name='inputUInt64'>The number to convert as a 64-bit unsigned integer.
    </param><returns>The value of
      <paramref name='inputUInt64'/>
       as an arbitrary-precision decimal number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.op_Modulus(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal)">

            <summary>Finds the remainder when dividing one arbitrary-precision decimal number
      by another.
    </summary><param name='dividend'>The number that will be divided by the divisor.
    </param><param name='divisor'>The number to divide by.
    </param><returns>The result of the operation.
    </returns><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='dividend'/>
       is null.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.op_Multiply(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal)">

            <summary>Multiplies two decimal numbers. The resulting exponent will be the sum of
      the exponents of the two decimal numbers.
    </summary><param name='operand1'>The first operand.
    </param><param name='operand2'>The second operand.
    </param><returns>The product of the two decimal numbers.
    </returns><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='operand1'/>
       or
      <paramref name='operand2'/>
       is null.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.op_Subtraction(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal)">

            <summary>Subtracts one arbitrary-precision decimal number from another and returns
      the result.
    </summary><param name='bthis'>The first operand.
    </param><param name='subtrahend'>The second operand.
    </param><returns>The difference of the two decimal numbers.
    </returns><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='bthis'/>
       or
      <paramref name='subtrahend'/>
       is null.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EDecimal.op_UnaryNegation(PeterO.Numbers.EDecimal)">

            <summary>Gets an arbitrary-precision decimal number with the same value as the
      given one, but with the sign reversed.
    </summary><param name='bigValue'>An arbitrary-precision decimal number to negate.
    </param><returns>An arbitrary-precision decimal number. If this value is positive zero,
      returns negative zero. Returns signaling NaN if this value is signaling
      NaN.
    </returns><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='bigValue'/>
       is null.
    </exception>

</doc>
<doc name="T:PeterO.Numbers.EFloat">

            <summary>Represents an arbitrary-precision binary floating-point number. (The "E"
      stands for "extended", meaning that instances of this class can be values
      other than numbers proper, such as infinity and not-a-number.) Each number
      consists of an integer mantissa (significand) and an integer exponent,
      both arbitrary-precision. The value of the number equals mantissa
      (significand) * 2^exponent. This class also supports values for negative
      zero, not-a-number (NaN) values, and infinity.
      <para>Passing a signaling NaN to any arithmetic operation shown here will
        signal the flag FlagInvalid and return a quiet NaN, even if another
        operand to that operation is a quiet NaN, unless noted otherwise.
      </para>
      <para>Passing a quiet NaN to any arithmetic operation shown here will return
        a quiet NaN, unless noted otherwise.
      </para>
      <para>Unless noted otherwise, passing a null arbitrary-precision binary float
        argument to any method here will throw an exception.
      </para>
      <para>When an arithmetic operation signals the flag FlagInvalid,
        FlagOverflow, or FlagDivideByZero, it will not throw an exception too,
        unless the operation's trap is enabled in the precision context (see
        EContext's Traps property).
      </para>
      <para>An arbitrary-precision binary float value can be serialized in one of
        the following ways:
      </para>
      <list>
        <item>By calling the toString() method. However, not all strings can be
          converted back to an arbitrary-precision binary float without loss,
          especially if the string has a fractional part.
        </item>
        <item>By calling the UnsignedMantissa, Exponent, and IsNegative properties,
          and calling the IsInfinity, IsQuietNaN, and IsSignalingNaN methods.
          The return values combined will uniquely identify a particular
          arbitrary-precision binary float value.
        </item>
      </list>
      <para>If an operation requires creating an intermediate value that might be
        too big to fit in memory (or might require more than 2 gigabytes of
        memory to store -- due to the current use of a 32-bit integer internally
        as a length), the operation may signal an invalid-operation flag and
        return not-a-number (NaN). In certain rare cases, the CompareTo method
        may throw OutOfMemoryException (called OutOfMemoryError in Java) in the
        same circumstances.
      </para>
      <para><b>Thread safety</b>
      </para>
      <para>Instances of this class are immutable, so they are inherently safe for
        use by multiple threads. Multiple instances of this object with the same
        properties are interchangeable, so they should not be compared using the
        "==" operator (which might only check if each side of the operator is
        the same instance).
      </para>
      <para><b>Comparison considerations</b>
      </para>
      <para>This class's natural ordering (under the CompareTo method) is not
        consistent with the Equals method. This means that two values that
        compare as equal under the CompareTo method might not be equal under the
        Equals method. The CompareTo method compares the mathematical values of
        the two instances passed to it (and considers two different NaN values
        as equal), while two instances with the same mathematical value, but
        different exponents, will be considered unequal under the Equals method.

      </para>
      <para><b>Security note</b>
      </para>
      <para>It is not recommended to implement security-sensitive algorithms using
        the methods in this class, for several reasons:
      </para>
      <list>
        <item><c>EFloat</c>
           objects are immutable, so they can't be modified, and the memory they
          occupy is not guaranteed to be cleared in a timely fashion due to
          garbage collection. This is relevant for applications that use
          many-bit-long numbers as secret parameters.
        </item>
        <item>The methods in this class (especially those that involve arithmetic)
          are not guaranteed to run in constant time for all relevant inputs.
          Certain attacks that involve encrypted communications have exploited
          the timing and other aspects of such communications to derive keying
          material or cleartext indirectly.
        </item>
      </list>
      <para>Applications should instead use dedicated security libraries to handle big numbers in security-sensitive algorithms.
      </para>
    </summary>

</doc>
<doc name="M:PeterO.Numbers.EFloat.Abs">

            <summary>Finds the absolute value of this object (if it's negative, it becomes
      positive).
    </summary><returns>An arbitrary-precision binary float. Returns signaling NaN if this value
      is signaling NaN.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.Abs(PeterO.Numbers.EContext)">

            <summary>Finds the absolute value of this object (if it's negative, it becomes
      positive).
    </summary><param name='context'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and no rounding is needed.
    </param><returns>The absolute value of this object. Signals FlagInvalid and returns quiet
      NaN if this value is signaling NaN.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.Add(PeterO.Numbers.EFloat)">

            <summary>Adds this object and another binary float and returns the result.
    </summary><param name='otherValue'>An arbitrary-precision binary float.
    </param><returns>The sum of the two objects.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.Add(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">

            <summary>Finds the sum of this object and another object. The result's exponent is
      set to the lower of the exponents of the two operands.
    </summary><param name='otherValue'>The number to add to.
    </param><param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and no rounding is needed.
    </param><returns>An arbitrary-precision binary floating-point number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.BinaryMathHelper.CreateNewWithFlags(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger,System.Int32)">

            <summary>This is an internal method.
    </summary><param name='mantissa'>The parameter
      <paramref name='mantissa'/>
       is an internal parameter.
    </param><param name='exponent'>The parameter
      <paramref name='exponent'/>
       is an internal parameter.
    </param><param name='flags'>The parameter
      <paramref name='flags'/>
       is an internal parameter.
    </param><returns>An arbitrary-precision binary float.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.BinaryMathHelper.CreateShiftAccumulator(PeterO.Numbers.EInteger)">

            <summary>This is an internal method.
    </summary><param name='bigint'>An arbitrary-precision integer.
    </param><returns>An IShiftAccumulator object.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.BinaryMathHelper.CreateShiftAccumulatorWithDigits(PeterO.Numbers.EInteger,System.Int32,System.Int32)">

            <summary>This is an internal method.
    </summary><param name='bigint'>An arbitrary-precision integer.
    </param><param name='lastDigit'>The parameter
      <paramref name='lastDigit'/>
       is a 32-bit signed integer.
    </param><param name='olderDigits'>The parameter
      <paramref name='olderDigits'/>
       is a 32-bit signed integer.
    </param><returns>An IShiftAccumulator object.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.BinaryMathHelper.DivisionShift(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">

            <summary>This is an internal method.
    </summary><param name='num'>An arbitrary-precision integer.
    </param><param name='den'>Another arbitrary-precision integer.
    </param><returns>A FastInteger object.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.BinaryMathHelper.GetArithmeticSupport">

            <summary>This is an internal method.
    </summary><returns>A 32-bit signed integer.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.BinaryMathHelper.GetExponent(PeterO.Numbers.EFloat)">

            <summary>This is an internal method.
    </summary><param name='value'>An arbitrary-precision binary float.
    </param><returns>An arbitrary-precision integer.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.BinaryMathHelper.GetFlags(PeterO.Numbers.EFloat)">

            <summary>This is an internal method.
    </summary><param name='value'>An arbitrary-precision binary float.
    </param><returns>A 32-bit signed integer.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.BinaryMathHelper.GetMantissa(PeterO.Numbers.EFloat)">

            <summary>This is an internal method.
    </summary><param name='value'>An arbitrary-precision binary float.
    </param><returns>An arbitrary-precision integer.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.BinaryMathHelper.GetRadix">

            <summary>This is an internal method.
    </summary><returns>A 32-bit signed integer.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.BinaryMathHelper.GetSign(PeterO.Numbers.EFloat)">

            <summary>This is an internal method.
    </summary><param name='value'>An arbitrary-precision binary float.
    </param><returns>A 32-bit signed integer.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.BinaryMathHelper.MultiplyByRadixPower(PeterO.Numbers.EInteger,PeterO.Numbers.FastInteger)">

            <summary>This is an internal method.
    </summary><param name='bigint'>Another arbitrary-precision integer.
    </param><param name='power'>A fast integer.
    </param><returns>An arbitrary-precision integer.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.BinaryMathHelper.ValueOf(System.Int32)">

            <summary>This is an internal method.
    </summary><param name='val'>The parameter
      <paramref name='val'/>
       is a 32-bit signed integer.
    </param><returns>An arbitrary-precision binary float.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.CompareTo(PeterO.Numbers.EFloat)">
<summary>Compares the mathematical values of this object and another object,
      accepting NaN values.
      <para>This method is not consistent with the Equals method because two
        different numbers with the same mathematical value, but different
        exponents, will compare as equal.
      </para>
      <para>In this method, negative zero and positive zero are considered equal.
      </para>
      <para>If this object or the other object is a quiet NaN or signaling NaN, this
        method will not trigger an error. Instead, NaN will compare greater than
        any other number, including infinity. Two different NaN values will be
        considered equal.
      </para>
    </summary>
    <param name='other'>An arbitrary-precision binary float.
    </param>
    <returns>Less than 0 if this object's value is less than the other value, or
      greater than 0 if this object's value is greater than the other value or
      if &#x22;other&#x22; is null, or 0 if both values are equal.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.EFloat.CompareToSignal(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">

            <summary>Compares the mathematical values of this object and another object,
      treating quiet NaN as signaling.
      <para>In this method, negative zero and positive zero are considered equal.
      </para>
      <para>If this object or the other object is a quiet NaN or signaling NaN,
        this method will return a quiet NaN and will signal a FlagInvalid flag.
      </para>
    </summary><param name='other'>An arbitrary-precision binary float.
    </param><param name='ctx'>An arithmetic context. The precision, rounding, and exponent range are
      ignored. If
      <c>HasFlags</c>
       of the context is true, will store the flags resulting from the operation
      (the flags are in addition to the pre-existing flags). Can be null.
    </param><returns>Quiet NaN if this object or the other object is NaN, or 0 if both objects
      have the same value, or -1 if this object is less than the other value, or
      1 if this object is greater.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.CompareToTotal(PeterO.Numbers.EFloat)">

            <summary>Compares the values of this object and another object, imposing a total
      ordering on all possible values. In this method:
      <list>
        <item>For objects with the same value, the one with the higher exponent has
          a greater "absolute value".
        </item>
        <item>Negative zero is less than positive zero.
        </item>
        <item>Quiet NaN has a higher "absolute value" than signaling NaN. If both
          objects are quiet NaN or both are signaling NaN, the one with the
          higher diagnostic information has a greater "absolute value".
        </item>
        <item>NaN has a higher "absolute value" than infinity.
        </item>
        <item>Infinity has a higher "absolute value" than any finite number.
        </item>
        <item>Negative numbers are less than positive numbers.
        </item>
      </list>
    </summary><param name='other'>An arbitrary-precision binary float to compare with this one.
    </param><returns>The number 0 if both objects have the same value, or -1 if this object is
      less than the other value, or 1 if this object is greater.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.CompareToTotal(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">

            <summary>Compares the values of this object and another object, imposing a total
      ordering on all possible values. In this method:
      <list>
        <item>For objects with the same value, the one with the higher exponent has
          a greater "absolute value".
        </item>
        <item>Negative zero is less than positive zero.
        </item>
        <item>Quiet NaN has a higher "absolute value" than signaling NaN. If both
          objects are quiet NaN or both are signaling NaN, the one with the
          higher diagnostic information has a greater "absolute value".
        </item>
        <item>NaN has a higher "absolute value" than infinity.
        </item>
        <item>Infinity has a higher "absolute value" than any finite number.
        </item>
        <item>Negative numbers are less than positive numbers.
        </item>
      </list>
    </summary><param name='other'>An arbitrary-precision binary float to compare with this one.
    </param><param name='ctx'>An arithmetic context. Flags will be set in this context only if
      <c>HasFlags</c>
       and
      <c>IsSimplified</c>
       of the context are true and only if an operand needed to be rounded
      before carrying out the operation. Can be null.
    </param><returns>The number 0 if both objects have the same value, or -1 if this object is
      less than the other value, or 1 if this object is greater. Does not signal
      flags if either value is signaling NaN.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.CompareToTotalMagnitude(PeterO.Numbers.EFloat)">

            <summary>Compares the absolute values of this object and another object, imposing
      a total ordering on all possible values (ignoring their signs). In this
      method:
      <list>
        <item>For objects with the same value, the one with the higher exponent has
          a greater "absolute value".
        </item>
        <item>Negative zero and positive zero are considered equal.
        </item>
        <item>Quiet NaN has a higher "absolute value" than signaling NaN. If both
          objects are quiet NaN or both are signaling NaN, the one with the
          higher diagnostic information has a greater "absolute value".
        </item>
        <item>NaN has a higher "absolute value" than infinity.
        </item>
        <item>Infinity has a higher "absolute value" than any finite number.
        </item>
      </list>
    </summary><param name='other'>An arbitrary-precision binary float to compare with this one.
    </param><returns>The number 0 if both objects have the same value, or -1 if this object is
      less than the other value, or 1 if this object is greater.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.CompareToWithContext(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">

            <summary>Compares the mathematical values of this object and another object.
      <para>In this method, negative zero and positive zero are considered equal.
      </para>
      <para>If this object or the other object is a quiet NaN or signaling NaN,
        this method returns a quiet NaN, and will signal a FlagInvalid flag if
        either is a signaling NaN.
      </para>
    </summary><param name='other'>An arbitrary-precision binary float.
    </param><param name='ctx'>An arithmetic context. The precision, rounding, and exponent range are
      ignored. If
      <c>HasFlags</c>
       of the context is true, will store the flags resulting from the operation
      (the flags are in addition to the pre-existing flags). Can be null.
    </param><returns>Quiet NaN if this object or the other object is NaN, or 0 if both objects
      have the same value, or -1 if this object is less than the other value, or
      1 if this object is greater.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.CopySign(PeterO.Numbers.EFloat)">

            <summary>Returns a number with the same value as this one, but copying the sign
      (positive or negative) of another number.
    </summary><param name='other'>A number whose sign will be copied.
    </param><returns>An arbitrary-precision binary float.
    </returns><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='other'/>
       is null.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EFloat.Create(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">

            <summary>Creates a number with the value exponent*2^mantissa (significand).
    </summary><param name='mantissa'>Desired value for the mantissa.
    </param><param name='exponent'>Desired value for the exponent.
    </param><returns>An arbitrary-precision binary floating-point number.
    </returns><exception cref='T:System.ArgumentNullException'>The parameter "mantissa (significand)" or
      <paramref name='exponent'/>
       is null.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EFloat.Create(System.Int32,System.Int32)">

            <summary>Creates a number with the value exponent*2^mantissa (significand).
    </summary><param name='mantissaSmall'>Desired value for the mantissa.
    </param><param name='exponentSmall'>Desired value for the exponent.
    </param><returns>An arbitrary-precision binary floating-point number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.CreateNaN(PeterO.Numbers.EInteger)">

            <summary>Creates a not-a-number arbitrary-precision binary float.
    </summary><param name='diag'>A number to use as diagnostic information associated with this object. If
      none is needed, should be zero.
    </param><returns>A quiet not-a-number.
    </returns><exception cref='T:System.ArgumentException'>The parameter
      <paramref name='diag'/>
       is less than 0.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EFloat.CreateNaN(PeterO.Numbers.EInteger,System.Boolean,System.Boolean,PeterO.Numbers.EContext)">

            <summary>Creates a not-a-number arbitrary-precision binary float.
    </summary><param name='diag'>A number to use as diagnostic information associated with this object. If
      none is needed, should be zero.
    </param><param name='signaling'>Whether the return value will be signaling (true) or quiet (false).
    </param><param name='negative'>Whether the return value is negative.
    </param><param name='ctx'>An arithmetic context to control the precision (in bits) of the diagnostic
      information. The rounding and exponent range of this context will be
      ignored. Can be null. The only flag that can be signaled in this context
      is FlagInvalid, which happens if diagnostic information needs to be
      truncated and too much memory is required to do so.
    </param><returns>An arbitrary-precision binary floating-point number.
    </returns><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='diag'/>
       is null.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EFloat.DivRemNaturalScale(PeterO.Numbers.EFloat)">

            <summary>Calculates the quotient and remainder using the
      DivideToIntegerNaturalScale and the formula in RemainderNaturalScale.
    </summary><param name='divisor'>The number to divide by.
    </param><returns>A 2 element array consisting of the quotient and remainder in that order.

    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.DivRemNaturalScale(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">

            <summary>Calculates the quotient and remainder using the
      DivideToIntegerNaturalScale and the formula in RemainderNaturalScale.
    </summary><param name='divisor'>The number to divide by.
    </param><param name='ctx'>An arithmetic context object to control the precision, rounding, and
      exponent range of the result. This context will be used only in the
      division portion of the remainder calculation; as a result, it's possible
      for the remainder to have a higher precision than given in this context.
      Flags will be set on the given context only if the context's
      <c>HasFlags</c>
       is true and the integer part of the division result doesn't fit the
      precision and exponent range without rounding. Can be null, in which the
      precision is unlimited and no additional rounding, other than the rounding
      down to an integer after division, is needed.
    </param><returns>A 2 element array consisting of the quotient and remainder in that order.

    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.Divide(PeterO.Numbers.EFloat)">

            <summary>Divides this object by another binary float and returns the result. When
      possible, the result will be exact.
    </summary><param name='divisor'>The number to divide by.
    </param><returns>The quotient of the two numbers. Returns infinity if the divisor is 0 and
      the dividend is nonzero. Returns not-a-number (NaN) if the divisor and the
      dividend are 0. Returns NaN if the result can't be exact because it would
      have a nonterminating binary expansion.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.Divide(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">

            <summary>Divides this arbitrary-precision binary float by another
      arbitrary-precision binary float. The preferred exponent for the result is
      this object's exponent minus the divisor's exponent.
    </summary><param name='divisor'>The number to divide by.
    </param><param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and no rounding is needed.
    </param><returns>The quotient of the two objects. Signals FlagDivideByZero and returns
      infinity if the divisor is 0 and the dividend is nonzero. Signals
      FlagInvalid and returns not-a-number (NaN) if the divisor and the dividend
      are 0; or, either
      <paramref name='ctx'/>
       is null or
      <paramref name='ctx'/>
       's precision is 0, and the result would have a nonterminating binary
      expansion; or, the rounding mode is ERounding.None and the result is not
      exact.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.DivideAndRemainderNaturalScale(PeterO.Numbers.EFloat)">

            <summary>Calculates the quotient and remainder using the
      DivideToIntegerNaturalScale and the formula in RemainderNaturalScale.
    </summary><param name='divisor'>The number to divide by.
    </param><returns>A 2 element array consisting of the quotient and remainder in that order.

    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.DivideAndRemainderNaturalScale(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">

            <summary>Calculates the quotient and remainder using the
      DivideToIntegerNaturalScale and the formula in RemainderNaturalScale.
    </summary><param name='divisor'>The number to divide by.
    </param><param name='ctx'>An arithmetic context object to control the precision, rounding, and
      exponent range of the result. This context will be used only in the
      division portion of the remainder calculation; as a result, it's possible
      for the remainder to have a higher precision than given in this context.
      Flags will be set on the given context only if the context's
      <c>HasFlags</c>
       is true and the integer part of the division result doesn't fit the
      precision and exponent range without rounding. Can be null, in which the
      precision is unlimited and no additional rounding, other than the rounding
      down to an integer after division, is needed.
    </param><returns>A 2 element array consisting of the quotient and remainder in that order.

    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.DivideToExponent(PeterO.Numbers.EFloat,PeterO.Numbers.EInteger,PeterO.Numbers.EContext)">

            <summary>Divides two arbitrary-precision binary floats, and gives a particular
      exponent to the result.
    </summary><param name='divisor'>The number to divide by.
    </param><param name='exponent'>The desired exponent. A negative number places the cutoff point to the
      right of the usual radix point (so a negative number means the number of
      binary digit places to round to). A positive number places the cutoff
      point to the left of the usual radix point.
    </param><param name='ctx'>An arithmetic context object to control the rounding mode to use if the
      result must be scaled down to have the same exponent as this value. If the
      precision given in the context is other than 0, calls the Quantize method
      with both arguments equal to the result of the operation (and can signal
      FlagInvalid and return NaN if the result doesn't fit the given precision).
      If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the default rounding mode is HalfEven.
    </param><returns>The quotient of the two objects. Signals FlagDivideByZero and returns
      infinity if the divisor is 0 and the dividend is nonzero. Signals
      FlagInvalid and returns not-a-number (NaN) if the divisor and the dividend
      are 0. Signals FlagInvalid and returns not-a-number (NaN) if the context
      defines an exponent range and the desired exponent is outside that range.
      Signals FlagInvalid and returns not-a-number (NaN) if the rounding mode is
      ERounding.None and the result is not exact.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.DivideToExponent(PeterO.Numbers.EFloat,PeterO.Numbers.EInteger,PeterO.Numbers.ERounding)">

            <summary>Divides two arbitrary-precision binary floats, and gives a particular
      exponent to the result.
    </summary><param name='divisor'>The number to divide by.
    </param><param name='desiredExponent'>The desired exponent. A negative number places the cutoff point to the
      right of the usual radix point (so a negative number means the number of
      binary digit places to round to). A positive number places the cutoff
      point to the left of the usual radix point.
    </param><param name='rounding'>The rounding mode to use if the result must be scaled down to have the
      same exponent as this value.
    </param><returns>The quotient of the two objects. Signals FlagDivideByZero and returns
      infinity if the divisor is 0 and the dividend is nonzero. Returns
      not-a-number (NaN) if the divisor and the dividend are 0. Returns NaN if
      the rounding mode is ERounding.None and the result is not exact.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.DivideToExponent(PeterO.Numbers.EFloat,System.Int64,PeterO.Numbers.EContext)">

            <summary>Divides two arbitrary-precision binary floats, and gives a particular
      exponent to the result.
    </summary><param name='divisor'>The number to divide by.
    </param><param name='desiredExponentSmall'>The desired exponent. A negative number places the cutoff point to the
      right of the usual radix point (so a negative number means the number of
      binary digit places to round to). A positive number places the cutoff
      point to the left of the usual radix point.
    </param><param name='ctx'>An arithmetic context object to control the rounding mode to use if the
      result must be scaled down to have the same exponent as this value. If the
      precision given in the context is other than 0, calls the Quantize method
      with both arguments equal to the result of the operation (and can signal
      FlagInvalid and return NaN if the result doesn't fit the given precision).
      If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the default rounding mode is HalfEven.
    </param><returns>The quotient of the two objects. Signals FlagDivideByZero and returns
      infinity if the divisor is 0 and the dividend is nonzero. Signals
      FlagInvalid and returns not-a-number (NaN) if the divisor and the dividend
      are 0. Signals FlagInvalid and returns not-a-number (NaN) if the context
      defines an exponent range and the desired exponent is outside that range.
      Signals FlagInvalid and returns not-a-number (NaN) if the rounding mode is
      ERounding.None and the result is not exact.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.DivideToExponent(PeterO.Numbers.EFloat,System.Int64,PeterO.Numbers.ERounding)">

            <summary>Divides two arbitrary-precision binary floats, and gives a particular
      exponent to the result.
    </summary><param name='divisor'>The number to divide by.
    </param><param name='desiredExponentSmall'>The desired exponent. A negative number places the cutoff point to the
      right of the usual radix point (so a negative number means the number of
      binary digit places to round to). A positive number places the cutoff
      point to the left of the usual radix point.
    </param><param name='rounding'>The rounding mode to use if the result must be scaled down to have the
      same exponent as this value.
    </param><returns>The quotient of the two objects. Signals FlagDivideByZero and returns
      infinity if the divisor is 0 and the dividend is nonzero. Signals
      FlagInvalid and returns not-a-number (NaN) if the divisor and the dividend
      are 0. Signals FlagInvalid and returns not-a-number (NaN) if the rounding
      mode is ERounding.None and the result is not exact.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.DivideToIntegerNaturalScale(PeterO.Numbers.EFloat)">

            <summary>Divides two arbitrary-precision binary floats, and returns the integer
      part of the result, rounded down, with the preferred exponent set to this
      value's exponent minus the divisor's exponent.
    </summary><param name='divisor'>The number to divide by.
    </param><returns>The integer part of the quotient of the two objects. Signals
      FlagDivideByZero and returns infinity if the divisor is 0 and the dividend
      is nonzero. Signals FlagInvalid and returns not-a-number (NaN) if the
      divisor and the dividend are 0.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.DivideToIntegerNaturalScale(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">

            <summary>Divides this object by another object, and returns the integer part of
      the result (which is initially rounded down), with the preferred exponent
      set to this value's exponent minus the divisor's exponent.
    </summary><param name='divisor'>An arbitrary-precision binary floating-point number.
    </param><param name='ctx'>The parameter
      <paramref name='ctx'/>
       is an EContext object.
    </param><returns>The integer part of the quotient of the two objects. Signals FlagInvalid
      and returns not-a-number (NaN) if the return value would overflow the
      exponent range. Signals FlagDivideByZero and returns infinity if the
      divisor is 0 and the dividend is nonzero. Signals FlagInvalid and returns
      not-a-number (NaN) if the divisor and the dividend are 0. Signals
      FlagInvalid and returns not-a-number (NaN) if the rounding mode is
      ERounding.None and the result is not exact.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.DivideToIntegerZeroScale(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">

            <summary>Divides this object by another object, and returns the integer part of
      the result, with the exponent set to 0.
    </summary><param name='divisor'>The number to divide by.
    </param><param name='ctx'>An arithmetic context object to control the precision. The rounding and
      exponent range settings of this context are ignored. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited.
    </param><returns>The integer part of the quotient of the two objects. The exponent will be
      set to 0. Signals FlagDivideByZero and returns infinity if the divisor is
      0 and the dividend is nonzero. Signals FlagInvalid and returns
      not-a-number (NaN) if the divisor and the dividend are 0, or if the result
      doesn't fit the given precision.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.DivideToSameExponent(PeterO.Numbers.EFloat,PeterO.Numbers.ERounding)">

            <summary>Divides this object by another binary float and returns a result with the
      same exponent as this object (the dividend).
    </summary><param name='divisor'>The number to divide by.
    </param><param name='rounding'>The rounding mode to use if the result must be scaled down to have the
      same exponent as this value.
    </param><returns>The quotient of the two numbers. Signals FlagDivideByZero and returns
      infinity if the divisor is 0 and the dividend is nonzero. Signals
      FlagInvalid and returns not-a-number (NaN) if the divisor and the dividend
      are 0. Signals FlagInvalid and returns not-a-number (NaN) if the rounding
      mode is ERounding.None and the result is not exact.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.Equals(PeterO.Numbers.EFloat)">

            <summary>Determines whether this object's mantissa (significand), exponent, and
      properties are equal to those of another object. Not-a-number values are
      considered equal if the rest of their properties are equal.
    </summary><param name='other'>An arbitrary-precision binary float.
    </param><returns><c>true</c>
       if this object's mantissa (significand) and exponent are equal to those
      of another object; otherwise, <c>false</c>
       .
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.Equals(System.Object)">

            <summary>Determines whether this object's mantissa (significand), exponent, and
      properties are equal to those of another object and that other object is
      an arbitrary-precision binary float. Not-a-number values are considered
      equal if the rest of their properties are equal.
    </summary><param name='obj'>The parameter
      <paramref name='obj'/>
       is an arbitrary object.
    </param><returns><c>true</c>
       if the objects are equal; otherwise, <c>false</c>
       .
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.EqualsInternal(PeterO.Numbers.EFloat)">

            <summary>Determines whether this object's mantissa (significand) and exponent are
      equal to those of another object.
    </summary><param name='otherValue'>An arbitrary-precision binary float.
    </param><returns><c>true</c>
       if this object's mantissa (significand) and exponent are equal to those
      of another object; otherwise, <c>false</c>
       .
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.Exp(PeterO.Numbers.EContext)">
<summary>Finds e (the base of natural logarithms) raised to the power of this
      object's value.
    </summary>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags).
      <i>
         This parameter can't be null, as the exponential function's results are
        generally not exact.
      </i>
       (Unlike in the General Binary Arithmetic Specification, any rounding mode
      is allowed.).
    </param>
    <returns>Exponential of this object. If this object's value is 1, returns an
      approximation to " e" within the given precision. Signals FlagInvalid and
      returns not-a-number (NaN) if the parameter &#x22;ctx&#x22; is null or the
      precision is unlimited (the context's Precision property is 0).
    </returns>
</doc>
<doc name="P:PeterO.Numbers.EFloat.Exponent">

            <summary>Gets this object's exponent. This object's value will be an integer if
      the exponent is positive or zero.
    </summary><value>This object's exponent. This object' s value will be an integer if the
      exponent is positive or zero.
    </value>

</doc>
<doc name="M:PeterO.Numbers.EFloat.FromByte(System.Byte)">

            <summary>Converts a byte (from 0 to 255) to an arbitrary-precision binary float.
    </summary><param name='inputByte'>The number to convert as a byte (from 0 to 255).
    </param><returns>This number's value as an arbitrary-precision binary float.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.FromDouble(System.Double)">
<summary>Creates a binary float from a 64-bit floating-point number. This method
      computes the exact value of the floating point number, not an
      approximation, as is often the case by converting the floating point
      number to a string first.
    </summary>
    <param name='dbl'>The parameter
      <paramref name='dbl'/>
       is a 64-bit floating-point number.
    </param>
    <returns>A binary float with the same value as &#x22;dbl&#x22;.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.EFloat.FromEInteger(PeterO.Numbers.EInteger)">

            <summary>Converts an arbitrary-precision integer to the same value as a binary
      float.
    </summary><param name='bigint'>An arbitrary-precision integer.
    </param><returns>An arbitrary-precision binary float.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.FromInt16(System.Int16)">

            <summary>Converts a 16-bit signed integer to an arbitrary-precision binary float.
    </summary><param name='inputInt16'>The number to convert as a 16-bit signed integer.
    </param><returns>This number's value as an arbitrary-precision binary float.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.FromInt32(System.Int32)">

            <summary>Converts a 32-bit signed integer to an arbitrary-precision binary float.
    </summary><param name='inputInt32'>The number to convert as a 32-bit signed integer.
    </param><returns>This number's value as an arbitrary-precision binary float.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.FromInt64(System.Int64)">

            <summary>Converts a 64-bit signed integer to an arbitrary-precision binary float.
    </summary><param name='inputInt64'>The number to convert as a 64-bit signed integer.
    </param><returns>This number's value as an arbitrary-precision binary float.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.FromSByte(System.SByte)">

            <summary>Converts an 8-bit signed integer to an arbitrary-precision binary float.
    </summary><param name='inputSByte'>The number to convert as an 8-bit signed integer.
    </param><returns>This number's value as an arbitrary-precision binary float.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.FromSingle(System.Single)">
<summary>Creates a binary float from a 32-bit floating-point number. This method
      computes the exact value of the floating point number, not an
      approximation, as is often the case by converting the floating point
      number to a string first.
    </summary>
    <param name='flt'>The parameter
      <paramref name='flt'/>
       is a 32-bit binary floating-point number.
    </param>
    <returns>A binary float with the same value as &#x22;flt&#x22;.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.EFloat.FromString(System.String)">

            <summary>Creates a binary float from a text string that represents a number, using
      an unlimited precision context. For more information, see the
      <c>FromString(String, int, int, EContext)</c>
       method.
    </summary><param name='str'>A text string to convert to a binary float.
    </param><returns>The parsed number, converted to arbitrary-precision binary float.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.FromString(System.String,PeterO.Numbers.EContext)">

            <summary>Creates a binary float from a text string that represents a number. For
      more information, see the
      <c>FromString(String, int, int, EContext)</c>
       method.
    </summary><param name='str'>A text string to convert to a binary float.
    </param><param name='ctx'>A precision context specifying the precision, rounding, and exponent range
      to apply to the parsed number. Can be null.
    </param><returns>The parsed number, converted to arbitrary-precision binary float.
    </returns><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       is null.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EFloat.FromString(System.String,System.Int32,System.Int32)">
<summary>Creates a binary float from a text string that represents a number. For
      more information, see the
      <c>FromString(String, int, int, EContext)</c>
       method.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
    <param name='offset'>A zero-based index showing where the desired portion of
      <paramref name='str'/>
       begins.
    </param>
    <param name='length'>The length, in code units, of the desired portion of
      <paramref name='str'/>
       (but not more than
      <paramref name='str'/>
       's length).
    </param>
    <returns>An arbitrary-precision binary float.
    </returns>
    <exception cref=' T:System.ArgumentException'>Either
      <paramref name=' offset'/>
       or
      <paramref name=' length'/>
       is less than 0 or greater than
      <paramref name='str'/>
       's length, or
      <paramref name='
            str'/>
       ' s length minus
      <paramref name='offset'/>
       is less than
      <paramref name='length'/>
       .
    </exception>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       is null.
    </exception>
    <exception cref='T:System.ArgumentException'>Either &#x22;offset&#x22; or &#x22;length&#x22; is less than 0 or greater
      than &#x22;str&#x22;&#x27;s length, or &#x22;str&#x22;&#x27;s length minus
      &#x22;offset&#x22; is less than &#x22;length&#x22;.
    </exception>
</doc>
<doc name="M:PeterO.Numbers.EFloat.FromString(System.String,System.Int32,System.Int32,PeterO.Numbers.EContext)">

            <summary>Creates a binary float from a text string that represents a number. Note
      that if the string contains a negative exponent, the resulting value might
      not be exact, in which case the resulting binary float will be an
      approximation of this decimal number's value.
      <para>The format of the string generally consists of:
      </para>
      <list type=''>
        <item>An optional plus sign ("+" , U+002B) or minus sign ("-", U+002D) (if
          '-' , the value is negative.)
        </item>
        <item>One or more digits, with a single optional decimal point after the
          first digit and before the last digit.
        </item>
        <item>Optionally, "E+"/"e+" (positive exponent) or "E-"/"e-" (negative
          exponent) plus one or more digits specifying the exponent.
        </item>
      </list>
      <para>The string can also be "-INF", "-Infinity", "Infinity", "INF", quiet
        NaN ("NaN") followed by any number of digits, or signaling NaN ("sNaN")
        followed by any number of digits, all in any combination of upper and
        lower case.
      </para>
      <para>All characters mentioned above are the corresponding characters in the
        Basic Latin range. In particular, the digits must be the basic digits 0
        to 9 (U+0030 to U+0039). The string is not allowed to contain white
        space characters, including spaces.
      </para>
    </summary><param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param><param name='offset'>A zero-based index showing where the desired portion of
      <paramref name='str'/>
       begins.
    </param><param name='length'>The length, in code units, of the desired portion of
      <paramref name='str'/>
       (but not more than
      <paramref name='str'/>
       's length).
    </param><param name='ctx'>The parameter
      <paramref name='ctx'/>
       is an EContext object.
    </param><returns>The parsed number, converted to arbitrary-precision binary float.
    </returns><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       is null.
    </exception><exception cref='T:System.ArgumentException'>Either
      <paramref name='offset'/>
       or
      <paramref name='length'/>
       is less than 0 or greater than
      <paramref name='str'/>
       's length, or
      <paramref name='             str'/>
       ' s length minus
      <paramref name='offset'/>
       is less than
      <paramref name='length'/>
       .
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EFloat.FromUInt16(System.UInt16)">

            <summary>Converts a 16-bit unsigned integer to an arbitrary-precision binary
      float.
    </summary><param name='inputUInt16'>The number to convert as a 16-bit unsigned integer.
    </param><returns>This number's value as an arbitrary-precision binary float.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.FromUInt32(System.UInt32)">

            <summary>Converts a 32-bit signed integer to an arbitrary-precision binary float.
    </summary><param name='inputUInt32'>The number to convert as a 32-bit signed integer.
    </param><returns>This number's value as an arbitrary-precision binary float.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.FromUInt64(System.UInt64)">

            <summary>Converts a 64-bit unsigned integer to an arbitrary-precision binary
      float.
    </summary><param name='inputUInt64'>The number to convert as a 64-bit unsigned integer.
    </param><returns>This number's value as an arbitrary-precision binary float.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.GetHashCode">

            <summary>Calculates this object's hash code. No application or process IDs are
      used in the hash code calculation.
    </summary><returns>A 32-bit signed integer.
    </returns>

</doc>
<doc name="P:PeterO.Numbers.EFloat.IsFinite">

            <summary>Gets a value indicating whether this object is finite (not infinity or
      NaN).
    </summary><value><c>true</c>
       if this object is finite (not infinity or NaN); otherwise, <c>false</c>
       .
    </value>

</doc>
<doc name="M:PeterO.Numbers.EFloat.IsInfinity">

            <summary>Gets a value indicating whether this object is positive or negative
      infinity.
    </summary><returns><c>true</c>
       if this object is positive or negative infinity; otherwise, <c>false</c>
       .
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.IsNaN">

            <summary>Gets a value indicating whether this object is not a number (NaN).
    </summary><returns><c>true</c>
       if this object is not a number (NaN); otherwise, <c>false</c>
       .
    </returns>

</doc>
<doc name="P:PeterO.Numbers.EFloat.IsNegative">

            <summary>Gets a value indicating whether this object is negative, including
      negative zero.
    </summary><value><c>true</c>
       if this object is negative, including negative zero; otherwise, <c>false</c>
       .
    </value>

</doc>
<doc name="M:PeterO.Numbers.EFloat.IsNegativeInfinity">

            <summary>Returns whether this object is negative infinity.
    </summary><returns><c>true</c>
       if this object is negative infinity; otherwise, <c>false</c>
       .
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.IsPositiveInfinity">

            <summary>Returns whether this object is positive infinity.
    </summary><returns><c>true</c>
       if this object is positive infinity; otherwise, <c>false</c>
       .
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.IsQuietNaN">

            <summary>Gets a value indicating whether this object is a quiet not-a-number
      value.
    </summary><returns><c>true</c>
       if this object is a quiet not-a-number value; otherwise, <c>false</c>
       .
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.IsSignalingNaN">

            <summary>Gets a value indicating whether this object is a signaling not-a-number
      value.
    </summary><returns><c>true</c>
       if this object is a signaling not-a-number value; otherwise, <c>false</c>
       .
    </returns>

</doc>
<doc name="P:PeterO.Numbers.EFloat.IsZero">

            <summary>Gets a value indicating whether this object's value equals 0.
    </summary><value><c>true</c>
       if this object's value equals 0; otherwise, <c>false</c>
       .
      <c>true</c>
       if this object' s value equals 0; otherwise, .
      <c>false</c>
       .
    </value>

</doc>
<doc name="M:PeterO.Numbers.EFloat.Log(PeterO.Numbers.EContext)">
<summary>Finds the natural logarithm of this object, that is, the power (exponent)
      that e (the base of natural logarithms) must be raised to in order to
      equal this object's value.
    </summary>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags).
      <i>
         This parameter can't be null, as the ln function's results are
        generally not exact.
      </i>
       (Unlike in the General Binary Arithmetic Specification, any rounding mode
      is allowed.).
    </param>
    <returns>Ln(this object). Signals the flag FlagInvalid and returns NaN if this
      object is less than 0 (the result would be a complex number with a real
      part equal to Ln of this object's absolute value and an imaginary part
      equal to pi, but the return value is still NaN.). Signals FlagInvalid and
      returns not-a-number (NaN) if the parameter &#x22;ctx&#x22; is null or the
      precision is unlimited (the context's Precision property is 0). Signals no
      flags and returns negative infinity if this object's value is 0.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.EFloat.Log10(PeterO.Numbers.EContext)">
<summary>Finds the base-10 logarithm of this object, that is, the power (exponent)
      that the number 10 must be raised to in order to equal this object's
      value.
    </summary>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags).
      <i>
         This parameter can't be null, as the ln function's results are
        generally not exact.
      </i>
       (Unlike in the General Binary Arithmetic Specification, any rounding mode
      is allowed.).
    </param>
    <returns>Ln(this object)/Ln(10). Signals the flag FlagInvalid and returns
      not-a-number (NaN) if this object is less than 0. Signals FlagInvalid and
      returns not-a-number (NaN) if the parameter &#x22;ctx&#x22; is null or the
      precision is unlimited (the context's Precision property is 0).
    </returns>
</doc>
<doc name="P:PeterO.Numbers.EFloat.Mantissa">

            <summary>Gets this object's unscaled value.
    </summary><value>This object' s unscaled value. Will be negative if this object's value is
      negative (including a negative NaN).
    </value>

</doc>
<doc name="M:PeterO.Numbers.EFloat.Max(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat)">

            <summary>Gets the greater value between two binary floats.
    </summary><param name='first'>An arbitrary-precision binary float.
    </param><param name='second'>Another arbitrary-precision binary float.
    </param><returns>An arbitrary-precision binary floating-point number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.Max(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">

            <summary>Gets the greater value between two binary floats.
    </summary><param name='first'>The first value to compare.
    </param><param name='second'>The second value to compare.
    </param><param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and rounding isn't needed.
    </param><returns>The larger value of the two numbers.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.MaxMagnitude(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat)">

            <summary>Gets the greater value between two values, ignoring their signs. If the
      absolute values are equal, has the same effect as Max.
    </summary><param name='first'>The first value to compare.
    </param><param name='second'>The second value to compare.
    </param><returns>An arbitrary-precision binary floating-point number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.MaxMagnitude(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">

            <summary>Gets the greater value between two values, ignoring their signs. If the
      absolute values are equal, has the same effect as Max.
    </summary><param name='first'>The first value to compare.
    </param><param name='second'>The second value to compare.
    </param><param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and rounding isn't needed.
    </param><returns>An arbitrary-precision binary float.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.Min(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat)">

            <summary>Gets the lesser value between two binary floats.
    </summary><param name='first'>The first value to compare.
    </param><param name='second'>The second value to compare.
    </param><returns>An arbitrary-precision binary floating-point number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.Min(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">

            <summary>Gets the lesser value between two binary floats.
    </summary><param name='first'>The first value to compare.
    </param><param name='second'>The second value to compare.
    </param><param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and rounding isn't needed.
    </param><returns>The smaller value of the two numbers.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.MinMagnitude(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat)">

            <summary>Gets the lesser value between two values, ignoring their signs. If the
      absolute values are equal, has the same effect as Min.
    </summary><param name='first'>The first value to compare.
    </param><param name='second'>The second value to compare.
    </param><returns>An arbitrary-precision binary floating-point number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.MinMagnitude(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">

            <summary>Gets the lesser value between two values, ignoring their signs. If the
      absolute values are equal, has the same effect as Min.
    </summary><param name='first'>The first value to compare.
    </param><param name='second'>The second value to compare.
    </param><param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and rounding isn't needed.
    </param><returns>An arbitrary-precision binary float.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.MovePointLeft(PeterO.Numbers.EInteger)">
<summary>Returns a number similar to this number but with the radix point moved to
      the left.
    </summary>
    <param name='bigPlaces'>The number of binary digit places to move the radix point to the left. If
      this number is negative, instead moves the radix point to the right by
      this number's absolute value.
    </param>
    <returns>A number whose exponent is decreased by &#x22;bigPlaces&#x22;, but not to
      more than 0.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.EFloat.MovePointLeft(PeterO.Numbers.EInteger,PeterO.Numbers.EContext)">

            <summary>Returns a number similar to this number but with the radix point moved to
      the left.
    </summary><param name='bigPlaces'>The number of binary digit places to move the radix point to the left. If
      this number is negative, instead moves the radix point to the right by
      this number's absolute value.
    </param><param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and rounding isn't needed.
    </param><returns>A number whose exponent is decreased by
      <paramref name='bigPlaces'/>
       , but not to more than 0.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.MovePointLeft(System.Int32)">
<summary>Returns a number similar to this number but with the radix point moved to
      the left.
    </summary>
    <param name='places'>The number of binary digit places to move the radix point to the left. If
      this number is negative, instead moves the radix point to the right by
      this number's absolute value.
    </param>
    <returns>A number whose exponent is decreased by &#x22;places&#x22;, but not to
      more than 0.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.EFloat.MovePointLeft(System.Int32,PeterO.Numbers.EContext)">

            <summary>Returns a number similar to this number but with the radix point moved to
      the left.
    </summary><param name='places'>The number of binary digit places to move the radix point to the left. If
      this number is negative, instead moves the radix point to the right by
      this number's absolute value.
    </param><param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and rounding isn't needed.
    </param><returns>A number whose exponent is decreased by
      <paramref name='places'/>
       , but not to more than 0.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.MovePointRight(PeterO.Numbers.EInteger)">
<summary>Returns a number similar to this number but with the radix point moved to
      the right.
    </summary>
    <param name='bigPlaces'>The number of binary digit places to move the radix point to the right. If
      this number is negative, instead moves the radix point to the left by this
      number's absolute value.
    </param>
    <returns>A number whose exponent is increased by &#x22;bigPlaces&#x22;, but not to
      more than 0.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.EFloat.MovePointRight(PeterO.Numbers.EInteger,PeterO.Numbers.EContext)">

            <summary>Returns a number similar to this number but with the radix point moved to
      the right.
    </summary><param name='bigPlaces'>The number of binary digit places to move the radix point to the right. If
      this number is negative, instead moves the radix point to the left by this
      number's absolute value.
    </param><param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and rounding isn't needed.
    </param><returns>A number whose exponent is increased by
      <paramref name='bigPlaces'/>
       , but not to more than 0.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.MovePointRight(System.Int32)">
<summary>Returns a number similar to this number but with the radix point moved to
      the right.
    </summary>
    <param name='places'>The number of binary digit places to move the radix point to the right. If
      this number is negative, instead moves the radix point to the left by this
      number's absolute value.
    </param>
    <returns>A number whose exponent is increased by &#x22;places&#x22;, but not to
      more than 0.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.EFloat.MovePointRight(System.Int32,PeterO.Numbers.EContext)">

            <summary>Returns a number similar to this number but with the radix point moved to
      the right.
    </summary><param name='places'>The number of binary digit places to move the radix point to the right. If
      this number is negative, instead moves the radix point to the left by this
      number's absolute value.
    </param><param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and rounding isn't needed.
    </param><returns>A number whose exponent is increased by
      <paramref name='places'/>
       , but not to more than 0.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.Multiply(PeterO.Numbers.EFloat)">

            <summary>Multiplies two binary floats. The resulting exponent will be the sum of
      the exponents of the two binary floats.
    </summary><param name='otherValue'>Another binary float.
    </param><returns>The product of the two binary floats.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.Multiply(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">

            <summary>Multiplies two binary floats. The resulting scale will be the sum of the
      scales of the two binary floats. The result's sign is positive if both
      operands have the same sign, and negative if they have different signs.
    </summary><param name='op'>Another binary float.
    </param><param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and rounding isn't needed.
    </param><returns>An arbitrary-precision binary floating-point number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.MultiplyAndAdd(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat)">

            <summary>Multiplies by one binary float, and then adds another binary float.
    </summary><param name='multiplicand'>The value to multiply.
    </param><param name='augend'>The value to add.
    </param><returns>An arbitrary-precision binary floating-point number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.MultiplyAndAdd(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">

            <summary>Multiplies by one value, and then adds another value.
    </summary><param name='op'>The value to multiply.
    </param><param name='augend'>The value to add.
    </param><param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and rounding isn't needed.
      If the precision doesn't indicate a simplified arithmetic, rounding and
      precision/exponent adjustment is done only once, namely, after multiplying
      and adding.
    </param><returns>The result thisValue * multiplicand + augend.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.MultiplyAndSubtract(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">

            <summary>Multiplies by one value, and then subtracts another value.
    </summary><param name='op'>The value to multiply.
    </param><param name='subtrahend'>The value to subtract.
    </param><param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and rounding isn't needed.
      If the precision doesn't indicate a simplified arithmetic, rounding and
      precision/exponent adjustment is done only once, namely, after multiplying
      and subtracting.
    </param><returns>The result thisValue * multiplicand - subtrahend.
    </returns><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='op'/>
       or
      <paramref name='subtrahend'/>
       is null.
    </exception>

</doc>
<doc name="F:PeterO.Numbers.EFloat.NaN">

            <summary>A not-a-number value.
    </summary>

</doc>
<doc name="M:PeterO.Numbers.EFloat.Negate">

            <summary>Gets an object with the same value as this one, but with the sign
      reversed.
    </summary><returns>An arbitrary-precision binary float. If this value is positive zero,
      returns negative zero. Returns signaling NaN if this value is signaling
      NaN.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.Negate(PeterO.Numbers.EContext)">

            <summary>Returns a binary float with the same value as this object but with the
      sign reversed.
    </summary><param name='context'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and rounding isn't needed.
    </param><returns>An arbitrary-precision binary float. If this value is positive zero,
      returns positive zero. Signals FlagInvalid and returns quiet NaN if this
      value is signaling NaN.
    </returns>

</doc>
<doc name="F:PeterO.Numbers.EFloat.NegativeInfinity">

            <summary>Negative infinity, less than any other number.
    </summary>

</doc>
<doc name="F:PeterO.Numbers.EFloat.NegativeZero">

            <summary>Represents the number negative zero.
    </summary>

</doc>
<doc name="M:PeterO.Numbers.EFloat.NextMinus(PeterO.Numbers.EContext)">
<summary>Finds the largest value that's smaller than the given value.
    </summary>
    <param name='ctx'>An arithmetic context object to control the precision and exponent range
      of the result. The rounding mode from this context is ignored. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags).
    </param>
    <returns>Returns the largest value that's less than the given value. Returns
      negative infinity if the result is negative infinity. Signals FlagInvalid
      and returns not-a-number (NaN) if the parameter &#x22;ctx&#x22; is null,
      the precision is 0, or &#x22;ctx&#x22; has an unlimited exponent range.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.EFloat.NextPlus(PeterO.Numbers.EContext)">
<summary>Finds the smallest value that's greater than the given value.
    </summary>
    <param name='ctx'>An arithmetic context object to control the precision and exponent range
      of the result. The rounding mode from this context is ignored. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags).
    </param>
    <returns>Returns the smallest value that's greater than the given value.Signals
      FlagInvalid and returns not-a-number (NaN) if the parameter
      &#x22;ctx&#x22; is null, the precision is 0, or &#x22;ctx&#x22; has an
      unlimited exponent range.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.EFloat.NextToward(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">

            <summary>Finds the next value that is closer to the other object's value than this
      object's value. Returns a copy of this value with the same sign as the
      other value if both values are equal.
    </summary><param name='otherValue'>An arbitrary-precision binary float that the return value will approach.
    </param><param name='ctx'>An arithmetic context object to control the precision and exponent range
      of the result. The rounding mode from this context is ignored. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags).
    </param><returns>Returns the next value that is closer to the other object' s value than
      this object's value. Signals FlagInvalid and returns NaN if the parameter
      <paramref name='ctx'/>
       is null, the precision is 0, or
      <paramref name='ctx'/>
       has an unlimited exponent range.
    </returns>

</doc>
<doc name="F:PeterO.Numbers.EFloat.One">

            <summary>Represents the number 1.
    </summary>

</doc>
<doc name="M:PeterO.Numbers.EFloat.PI(PeterO.Numbers.EContext)">
<summary>Finds the constant , the circumference of a circle divided by its
      diameter.
    </summary>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags).
      <i>
         This parameter can't be null, as &#x3c0; can never be represented
        exactly.
      </i>
       .
    </param>
    <returns>The constant  rounded to the given precision. Signals FlagInvalid and
      returns not-a-number (NaN) if the parameter &#x22;ctx&#x22; is null or the
      precision is unlimited (the context's Precision property is 0).
    </returns>
</doc>
<doc name="M:PeterO.Numbers.EFloat.Plus(PeterO.Numbers.EContext)">
<summary>Rounds this object's value to a given precision, using the given rounding
      mode and range of exponent, and also converts negative zero to positive
      zero.
    </summary>
    <param name='ctx'>A context for controlling the precision, rounding mode, and exponent
      range. Can be null, in which case the precision is unlimited and rounding
      isn't needed.
    </param>
    <returns>The closest value to this object's value, rounded to the specified
      precision. Returns the same value as this object if &#x22;ctx&#x22; is
      null or the precision and exponent range are unlimited.
    </returns>
</doc>
<doc name="F:PeterO.Numbers.EFloat.PositiveInfinity">

            <summary>Positive infinity, greater than any other number.
    </summary>

</doc>
<doc name="M:PeterO.Numbers.EFloat.Pow(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">

            <summary>Raises this object's value to the given exponent.
    </summary><param name='exponent'>An arbitrary-precision binary float expressing the exponent to raise this
      object's value to.
    </param><param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and rounding isn't needed.
    </param><returns>This^exponent. Signals the flag FlagInvalid and returns NaN if this
      object and exponent are both 0; or if this value is less than 0 and the
      exponent either has a fractional part or is infinity. Signals FlagInvalid
      and returns not-a-number (NaN) if the parameter
      <paramref name='ctx'/>
       is null or the precision is unlimited (the context's Precision property
      is 0), and the exponent has a fractional part.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.Pow(System.Int32)">

            <summary>Raises this object's value to the given exponent.
    </summary><param name='exponentSmall'>The exponent to raise this object's value to.
    </param><returns>This^exponent. Returns not-a-number (NaN) if this object and exponent are
      both 0.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.Pow(System.Int32,PeterO.Numbers.EContext)">

            <summary>Raises this object's value to the given exponent.
    </summary><param name='exponentSmall'>The exponent to raise this object's value to.
    </param><param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and rounding isn't needed.
    </param><returns>This^exponent. Signals the flag FlagInvalid and returns NaN if this
      object and exponent are both 0.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.Precision">

            <summary>Finds the number of digits in this number's mantissa (significand).
      Returns 1 if this value is 0, and 0 if this value is infinity or
      not-a-number (NaN).
    </summary><returns>An arbitrary-precision integer.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.Quantize(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">

            <summary>Returns a binary float with the same value as this object but with the
      same exponent as another binary float.
      <para>Note that this is not always the same as rounding to a given number of
        binary digit places, since it can fail if the difference between this
        value's exponent and the desired exponent is too big, depending on the
        maximum precision. If rounding to a number of binary digit places is
        desired, it's better to use the RoundToExponent and RoundToIntegral
        methods instead.
      </para>
      <para><b>Remark:</b>
         This method can be used to implement fixed-point binary arithmetic, in
        which a fixed number of digits come after the radix point. A fixed-point
        binary arithmetic in which no digits come after the radix point (a
        desired exponent of 0) is considered an "integer arithmetic" .
      </para>
    </summary><param name='otherValue'>A binary float containing the desired exponent of the result. The mantissa
      (significand) is ignored. The exponent is the number of fractional digits
      in the result, expressed as a negative number. Can also be positive, which
      eliminates lower-order places from the number. For example, -3 means round
      to the sixteenth (10b^-3, 0.0001b), and 3 means round to the sixteen-place
      (10b^3, 1000b). A value of 0 rounds the number to an integer.
    </param><param name='ctx'>An arithmetic context to control precision and rounding of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the default rounding mode is HalfEven.
    </param><returns>A binary float with the same value as this object but with the exponent
      changed. Signals FlagInvalid and returns not-a-number (NaN) if the result
      can't fit the given precision without rounding, or if the arithmetic
      context defines an exponent range and the given exponent is outside that
      range.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.Quantize(PeterO.Numbers.EInteger,PeterO.Numbers.EContext)">

            <summary>Returns a binary float with the same value but a new exponent.
      <para>Note that this is not always the same as rounding to a given number of
        binary digit places, since it can fail if the difference between this
        value's exponent and the desired exponent is too big, depending on the
        maximum precision. If rounding to a number of binary digit places is
        desired, it's better to use the RoundToExponent and RoundToIntegral
        methods instead.
      </para>
      <para><b>Remark:</b>
         This method can be used to implement fixed-point binary arithmetic, in
        which each binary float has a fixed number of digits after the radix
        point. The following code example returns a fixed-point number with up
        to 20 digits before and exactly 5 digits after the radix point:
      </para>
      <code>// After performing arithmetic operations, adjust // the number to 5 //
        digits after the radix point number = number.Quantize(
        EInteger.FromInt32(-5), // five digits after the radix point
        EContext.ForPrecision(25) // 25-digit precision);
      </code>
      <para>A fixed-point binary arithmetic in which no digits come after the radix
        point (a desired exponent of 0) is considered an "integer arithmetic".
      </para>
    </summary><param name='desiredExponent'>The desired exponent for the result. The exponent is the number of
      fractional digits in the result, expressed as a negative number. Can also
      be positive, which eliminates lower-order places from the number. For
      example, -3 means round to the thousandth (10^-3, 0.0001), and 3 means
      round to the thousand (10^3, 1000). A value of 0 rounds the number to an
      integer.
    </param><param name='ctx'>An arithmetic context to control precision and rounding of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the default rounding mode is HalfEven.
    </param><returns>A binary float with the same value as this object but with the exponent
      changed. Signals FlagInvalid and returns not-a-number (NaN) if this object
      is infinity, if the rounded result can't fit the given precision, or if
      the context defines an exponent range and the given exponent is outside
      that range.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.Quantize(System.Int32,PeterO.Numbers.EContext)">

            <summary>Returns a binary float with the same value but a new exponent.
      <para>Note that this is not always the same as rounding to a given number of
        binary digit places, since it can fail if the difference between this
        value's exponent and the desired exponent is too big, depending on the
        maximum precision. If rounding to a number of binary digit places is
        desired, it's better to use the RoundToExponent and RoundToIntegral
        methods instead.
      </para>
      <para><b>Remark:</b>
         This method can be used to implement fixed-point binary arithmetic, in
        which each binary float has a fixed number of digits after the radix
        point. The following code example returns a fixed-point number with up
        to 20 digits before and exactly 5 digits after the radix point:
      </para>
      <code>// After performing arithmetic operations, adjust // the number to 5
        digits after the radix point number = number.Quantize(-5, // five digits
        after the radix point EContext.ForPrecision(25) // 25-digit precision);
      </code>
      <para>A fixed-point binary arithmetic in which no digits come after the radix
        point (a desired exponent of 0) is considered an "integer arithmetic".
      </para>
    </summary><param name='desiredExponentInt'>The desired exponent for the result. The exponent is the number of
      fractional digits in the result, expressed as a negative number. Can also
      be positive, which eliminates lower-order places from the number. For
      example, -3 means round to the thousandth (10^-3, 0.0001), and 3 means
      round to the thousand (10^3, 1000). A value of 0 rounds the number to an
      integer.
    </param><param name='ctx'>An arithmetic context to control precision and rounding of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the default rounding mode is HalfEven.
    </param><returns>A binary float with the same value as this object but with the exponent
      changed. Signals FlagInvalid and returns not-a-number (NaN) if this object
      is infinity, if the rounded result can't fit the given precision, or if
      the context defines an exponent range and the given exponent is outside
      that range.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.Reduce(PeterO.Numbers.EContext)">

            <summary>Removes trailing zeros from this object's mantissa (significand). For
      example, 1.00 becomes 1.
      <para>If this object's value is 0, changes the exponent to 0.
      </para>
    </summary><param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and rounding isn't needed.
    </param><returns>This value with trailing zeros removed. Note that if the result has a
      very high exponent and the context says to clamp high exponents, there may
      still be some trailing zeros in the mantissa (significand).
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.Remainder(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">

            <summary>Finds the remainder that results when dividing two arbitrary-precision
      binary floats. The remainder is the value that remains when the absolute
      value of this object is divided by the absolute value of the other object;
      the remainder has the same sign (positive or negative) as this object's
      value.
    </summary><param name='divisor'>An arbitrary-precision binary floating-point number.
    </param><param name='ctx'>The parameter
      <paramref name='ctx'/>
       is an EContext object.
    </param><returns>The remainder of the two numbers. Signals FlagInvalid and returns
      not-a-number (NaN) if the divisor is 0, or if the result doesn't fit the
      given precision.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.RemainderNaturalScale(PeterO.Numbers.EFloat)">

            <summary>Calculates the remainder of a number by the formula
      <c>"this" - (("this" / "divisor") * "divisor")</c>
    </summary><param name='divisor'>The number to divide by.
    </param><returns>An arbitrary-precision binary float.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.RemainderNaturalScale(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">

            <summary>Calculates the remainder of a number by the formula "this" - (("this" /
      "divisor") * "divisor").
    </summary><param name='divisor'>The number to divide by.
    </param><param name='ctx'>An arithmetic context object to control the precision, rounding, and
      exponent range of the result. This context will be used only in the
      division portion of the remainder calculation; as a result, it's possible
      for the return value to have a higher precision than given in this
      context. Flags will be set on the given context only if the context's
      <c>HasFlags</c>
       is true and the integer part of the division result doesn't fit the
      precision and exponent range without rounding. Can be null, in which the
      precision is unlimited and no additional rounding, other than the rounding
      down to an integer after division, is needed.
    </param><returns>An arbitrary-precision binary floating-point number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.RemainderNear(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">

            <summary>Finds the distance to the closest multiple of the given divisor, based on
      the result of dividing this object's value by another object's value.
      <list type=''>
        <item>If this and the other object divide evenly, the result is 0.
        </item>
        <item>If the remainder's absolute value is less than half of the divisor's
          absolute value, the result has the same sign as this object and will
          be the distance to the closest multiple.
        </item>
        <item>If the remainder's absolute value is more than half of the divisor' s
          absolute value, the result has the opposite sign of this object and
          will be the distance to the closest multiple.
        </item>
        <item>If the remainder's absolute value is exactly half of the divisor's
          absolute value, the result has the opposite sign of this object if the
          quotient, rounded down, is odd, and has the same sign as this object
          if the quotient, rounded down, is even, and the result's absolute
          value is half of the divisor's absolute value.
        </item>
      </list>
       This function is also known as the "IEEE Remainder" function.
    </summary><param name='divisor'>The number to divide by.
    </param><param name='ctx'>An arithmetic context object to control the precision. The rounding and
      exponent range settings of this context are ignored (the rounding mode is
      always treated as HalfEven). If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which the precision is unlimited.
    </param><returns>The distance of the closest multiple. Signals FlagInvalid and returns
      not-a-number (NaN) if the divisor is 0, or either the result of integer
      division (the quotient) or the remainder wouldn't fit the given precision.

    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.RoundToExponent(PeterO.Numbers.EInteger,PeterO.Numbers.EContext)">

            <summary>Returns a binary float with the same value as this object but rounded to
      a new exponent if necessary.
    </summary><param name='exponent'>The minimum exponent the result can have. This is the maximum number of
      fractional digits in the result, expressed as a negative number. Can also
      be positive, which eliminates lower-order places from the number. For
      example, -3 means round to the thousandth (10^-3, 0.0001), and 3 means
      round to the thousand (10^3, 1000). A value of 0 rounds the number to an
      integer.
    </param><param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the default rounding mode is HalfEven.
    </param><returns>A binary float rounded to the closest value representable in the given
      precision. If the result can't fit the precision, additional digits are
      discarded to make it fit. Signals FlagInvalid and returns not-a-number
      (NaN) if the precision context defines an exponent range, the new exponent
      must be changed to the given exponent when rounding, and the given
      exponent is outside of the valid range of the arithmetic context.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.RoundToExponent(System.Int32,PeterO.Numbers.EContext)">

            <summary>Returns a binary float with the same value as this object but rounded to
      a new exponent if necessary.
    </summary><param name='exponentSmall'>The minimum exponent the result can have. This is the maximum number of
      fractional digits in the result, expressed as a negative number. Can also
      be positive, which eliminates lower-order places from the number. For
      example, -3 means round to the thousandth (10^-3, 0.0001), and 3 means
      round to the thousand (10^3, 1000). A value of 0 rounds the number to an
      integer.
    </param><param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the default rounding mode is HalfEven.
    </param><returns>A binary float rounded to the closest value representable in the given
      precision. If the result can't fit the precision, additional digits are
      discarded to make it fit. Signals FlagInvalid and returns not-a-number
      (NaN) if the precision context defines an exponent range, the new exponent
      must be changed to the given exponent when rounding, and the given
      exponent is outside of the valid range of the arithmetic context.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.RoundToExponentExact(PeterO.Numbers.EInteger,PeterO.Numbers.EContext)">

            <summary>Returns a binary float with the same value as this object but rounded to
      the given exponent, and signals an inexact flag if the result would be
      inexact.
    </summary><param name='exponent'>The minimum exponent the result can have. This is the maximum number of
      fractional digits in the result, expressed as a negative number. Can also
      be positive, which eliminates lower-order places from the number. For
      example, -3 means round to the thousandth (10^-3, 0.0001), and 3 means
      round to the thousand (10^3, 1000). A value of 0 rounds the number to an
      integer.
    </param><param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the default rounding mode is HalfEven.
    </param><returns>A binary float rounded to the closest value representable in the given
      precision. Signals FlagInvalid and returns not-a-number (NaN) if the
      result can't fit the given precision without rounding. Signals FlagInvalid
      and returns not-a-number (NaN) if the arithmetic context defines an
      exponent range, the new exponent must be changed to the given exponent
      when rounding, and the given exponent is outside of the valid range of the
      arithmetic context.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.RoundToExponentExact(PeterO.Numbers.EInteger,PeterO.Numbers.ERounding)">

            <summary>Returns a binary number with the same value as this object but rounded to
      the given exponent.
    </summary><param name='exponent'>The minimum exponent the result can have. This is the maximum number of
      fractional digits in the result, expressed as a negative number. Can also
      be positive, which eliminates lower-order places from the number. For
      example, -3 means round to the eighth (10^-1, 1/8), and 3 means round to
      the eight (2^3, 8). A value of 0 rounds the number to an integer.
    </param><param name='rounding'>Desired mode for rounding this object's value.
    </param><returns>A binary number rounded to the closest value representable in the given
      precision.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.RoundToExponentExact(System.Int32,PeterO.Numbers.EContext)">

            <summary>Returns a binary float with the same value as this object but rounded to
      an integer, and signals an inexact flag if the result would be inexact.
    </summary><param name='exponentSmall'>The minimum exponent the result can have. This is the maximum number of
      fractional digits in the result, expressed as a negative number. Can also
      be positive, which eliminates lower-order places from the number. For
      example, -3 means round to the thousandth (10^-3, 0.0001), and 3 means
      round to the thousand (10^3, 1000). A value of 0 rounds the number to an
      integer.
    </param><param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the default rounding mode is HalfEven.
    </param><returns>A binary float rounded to the closest value representable in the given
      precision. Signals FlagInvalid and returns not-a-number (NaN) if the
      result can't fit the given precision without rounding. Signals FlagInvalid
      and returns not-a-number (NaN) if the arithmetic context defines an
      exponent range, the new exponent must be changed to the given exponent
      when rounding, and the given exponent is outside of the valid range of the
      arithmetic context.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.RoundToIntegerExact(PeterO.Numbers.EContext)">

            <summary>Returns a binary float with the same value as this object but rounded to
      an integer, and signals an inexact flag if the result would be inexact.
    </summary><param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the default rounding mode is HalfEven.
    </param><returns>A binary float rounded to the closest integer representable in the given
      precision. Signals FlagInvalid and returns not-a-number (NaN) if the
      result can't fit the given precision without rounding. Signals FlagInvalid
      and returns not-a-number (NaN) if the arithmetic context defines an
      exponent range, the new exponent must be changed to 0 when rounding, and 0
      is outside of the valid range of the arithmetic context.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.RoundToIntegerNoRoundedFlag(PeterO.Numbers.EContext)">

            <summary>Returns a binary float with the same value as this object but rounded to
      an integer, without adding the
      <c>FlagInexact</c>
       or
      <c>FlagRounded</c>
       flags.
    </summary><param name='ctx'>An arithmetic context to control precision and rounding of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags), except
      that this function will never add the
      <c>FlagRounded</c>
       and
      <c>FlagInexact</c>
       flags (the only difference between this and RoundToExponentExact). Can be
      null, in which case the default rounding mode is HalfEven.
    </param><returns>A binary float rounded to the closest integer representable in the given
      precision. If the result can't fit the precision, additional digits are
      discarded to make it fit. Signals FlagInvalid and returns not-a-number
      (NaN) if the precision context defines an exponent range, the new exponent
      must be changed to 0 when rounding, and 0 is outside of the valid range of
      the arithmetic context.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.RoundToIntegralExact(PeterO.Numbers.EContext)">

            <summary>Returns a binary float with the same value as this object but rounded to
      an integer, and signals an inexact flag if the result would be inexact.
    </summary><param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the default rounding mode is HalfEven.
    </param><returns>A binary float rounded to the closest integer representable in the given
      precision. Signals FlagInvalid and returns not-a-number (NaN) if the
      result can't fit the given precision without rounding. Signals FlagInvalid
      and returns not-a-number (NaN) if the arithmetic context defines an
      exponent range, the new exponent must be changed to 0 when rounding, and 0
      is outside of the valid range of the arithmetic context.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.RoundToIntegralNoRoundedFlag(PeterO.Numbers.EContext)">

            <summary>Returns a binary float with the same value as this object but rounded to
      an integer, without adding the
      <c>FlagInexact</c>
       or
      <c>FlagRounded</c>
       flags.
    </summary><param name='ctx'>An arithmetic context to control precision and rounding of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags), except
      that this function will never add the
      <c>FlagRounded</c>
       and
      <c>FlagInexact</c>
       flags (the only difference between this and RoundToExponentExact). Can be
      null, in which case the default rounding mode is HalfEven.
    </param><returns>A binary float rounded to the closest integer representable in the given
      precision. If the result can't fit the precision, additional digits are
      discarded to make it fit. Signals FlagInvalid and returns not-a-number
      (NaN) if the precision context defines an exponent range, the new exponent
      must be changed to 0 when rounding, and 0 is outside of the valid range of
      the arithmetic context.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.RoundToPrecision(PeterO.Numbers.EContext)">
<summary>Rounds this object's value to a given precision, using the given rounding
      mode and range of exponent.
    </summary>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and no rounding is needed.
    </param>
    <returns>The closest value to this object's value, rounded to the specified
      precision. Returns the same value as this object if &#x22;ctx&#x22; is
      null or the precision and exponent range are unlimited.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.EFloat.ScaleByPowerOfTwo(PeterO.Numbers.EInteger)">
<summary>Returns a number similar to this number but with the scale adjusted.
    </summary>
    <param name='bigPlaces'>An arbitrary-precision integer.
    </param>
    <returns>A number whose exponent is increased by &#x22;bigPlaces&#x22;.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.EFloat.ScaleByPowerOfTwo(PeterO.Numbers.EInteger,PeterO.Numbers.EContext)">

            <summary>Returns a number similar to this number but with its scale adjusted.
    </summary><param name='bigPlaces'>An arbitrary-precision integer.
    </param><param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null.
    </param><returns>An arbitrary-precision binary floating-point number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.ScaleByPowerOfTwo(System.Int32)">

            <summary>Returns a number similar to this number but with the scale adjusted.
    </summary><param name='places'>The parameter
      <paramref name='places'/>
       is a 32-bit signed integer.
    </param><returns>An arbitrary-precision binary float.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.ScaleByPowerOfTwo(System.Int32,PeterO.Numbers.EContext)">

            <summary>Returns a number similar to this number but with the scale adjusted.
    </summary><param name='places'>The parameter
      <paramref name='places'/>
       is a 32-bit signed integer.
    </param><param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null.
    </param><returns>An arbitrary-precision binary floating-point number.
    </returns>

</doc>
<doc name="P:PeterO.Numbers.EFloat.Sign">

            <summary>Gets this value's sign: -1 if negative; 1 if positive; 0 if zero.
    </summary><value>This value's sign: -1 if negative; 1 if positive; 0 if zero.
    </value>

</doc>
<doc name="F:PeterO.Numbers.EFloat.SignalingNaN">

            <summary>A not-a-number value that signals an invalid operation flag when it's
      passed as an argument to any arithmetic operation in arbitrary-precision
      binary float.
    </summary>

</doc>
<doc name="M:PeterO.Numbers.EFloat.Sqrt(PeterO.Numbers.EContext)">
<summary>Finds the square root of this object's value.
    </summary>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags).
      <i>
         This parameter can't be null, as the square root function's results are
        generally not exact for many inputs.
      </i>
       (Unlike in the General Binary Arithmetic Specification, any rounding mode
      is allowed.).
    </param>
    <returns>The square root. Signals the flag FlagInvalid and returns NaN if this
      object is less than 0 (the square root would be a complex number, but the
      return value is still NaN). Signals FlagInvalid and returns not-a-number
      (NaN) if the parameter &#x22;ctx&#x22; is null or the precision is
      unlimited (the context's Precision property is 0).
    </returns>
</doc>
<doc name="M:PeterO.Numbers.EFloat.SquareRoot(PeterO.Numbers.EContext)">
<summary>Finds the square root of this object's value.
    </summary>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags).
      <i>
         This parameter can't be null, as the square root function's results are
        generally not exact for many inputs.
      </i>
       (Unlike in the General Binary Arithmetic Specification, any rounding mode
      is allowed.).
    </param>
    <returns>The square root. Signals the flag FlagInvalid and returns NaN if this
      object is less than 0 (the square root would be a complex number, but the
      return value is still NaN). Signals FlagInvalid and returns not-a-number
      (NaN) if the parameter &#x22;ctx&#x22; is null or the precision is
      unlimited (the context's Precision property is 0).
    </returns>
</doc>
<doc name="M:PeterO.Numbers.EFloat.Subtract(PeterO.Numbers.EFloat)">

            <summary>Subtracts an arbitrary-precision binary float from this instance and
      returns the result.
    </summary><param name='otherValue'>The number to subtract from this instance's value.
    </param><returns>The difference of the two objects.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.Subtract(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">

            <summary>Subtracts an arbitrary-precision binary float from this instance.
    </summary><param name='otherValue'>The number to subtract from this instance's value.
    </param><param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and no rounding is needed.
    </param><returns>An arbitrary-precision binary floating-point number.
    </returns><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='otherValue'/>
       is null.
    </exception>

</doc>
<doc name="F:PeterO.Numbers.EFloat.Ten">

            <summary>Represents the number 10.
    </summary>

</doc>
<doc name="M:PeterO.Numbers.EFloat.ToByteChecked">

            <summary>Converts this number's value to a byte (from 0 to 255) if it can fit in a
      byte (from 0 to 255) after truncating to an integer.
    </summary><returns>This number's value, truncated to a byte (from 0 to 255).
    </returns><exception cref='T:System.OverflowException'>This value is infinity or not-a-number, or the truncated integer is less
      than 0 or greater than 255.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EFloat.ToByteIfExact">

            <summary>Converts this number's value to a byte (from 0 to 255) if it can fit in a
      byte (from 0 to 255) without rounding to a different numerical value.
    </summary><returns>This number's value as a byte (from 0 to 255).
    </returns><exception cref='T:System.ArithmeticException'>This value is infinity or not-a-number, is not an exact integer, or is
      less than 0 or greater than 255.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EFloat.ToByteUnchecked">

            <summary>Truncates this number's value to an integer and returns the
      least-significant bits of its two's-complement form as a byte (from 0 to
      255).
    </summary><returns>This number, converted to a byte (from 0 to 255). Returns 0 if this value
      is infinity or not-a-number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.ToDouble">

            <summary>Converts this value to a 64-bit floating-point number.
    </summary><returns>This number, converted to a 64-bit floating-point number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.ToEDecimal">

            <summary>Converts this value to an arbitrary-precision decimal number.
    </summary><returns>This number, converted to an arbitrary-precision decimal number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.ToEInteger">

            <summary>Converts this value to an arbitrary-precision integer. Any fractional
      part of this value will be discarded when converting to an
      arbitrary-precision integer.
    </summary><returns>An arbitrary-precision integer.
    </returns><exception cref='T:System.OverflowException'>This object's value is infinity or not-a-number (NaN).
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EFloat.ToEIntegerExact">

            <summary>Converts this value to an arbitrary-precision integer, checking whether
      the value contains a fractional part.
    </summary><returns>An arbitrary-precision integer.
    </returns><exception cref='T:System.OverflowException'>This object's value is infinity or not-a-number (NaN).
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EFloat.ToEIntegerIfExact">

            <summary>Converts this value to an arbitrary-precision integer, checking whether
      the value contains a fractional part.
    </summary><returns>An arbitrary-precision integer.
    </returns><exception cref='T:System.OverflowException'>This object's value is infinity or not-a-number (NaN).
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EFloat.ToEngineeringString">

            <summary>Converts this value to an arbitrary-precision decimal number, then
      returns the value of that decimal's ToEngineeringString method.
    </summary><returns>A text string.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.ToExtendedDecimal">

            <summary>Converts this value to an arbitrary-precision decimal number.
    </summary><returns>An arbitrary-precision decimal number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.ToInt16Checked">

            <summary>Converts this number's value to a 16-bit signed integer if it can fit in
      a 16-bit signed integer after truncating to an integer.
    </summary><returns>This number's value, truncated to a 16-bit signed integer.
    </returns><exception cref='T:System.OverflowException'>This value is infinity or not-a-number, or the truncated integer is less
      than -32768 or greater than 32767.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EFloat.ToInt16IfExact">

            <summary>Converts this number's value to a 16-bit signed integer if it can fit in
      a 16-bit signed integer without rounding to a different numerical value.
    </summary><returns>This number's value as a 16-bit signed integer.
    </returns><exception cref='T:System.ArithmeticException'>This value is infinity or not-a-number, is not an exact integer, or is
      less than -32768 or greater than 32767.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EFloat.ToInt16Unchecked">

            <summary>Truncates this number's value to an integer and returns the
      least-significant bits of its two's-complement form as a 16-bit signed
      integer.
    </summary><returns>This number, converted to a 16-bit signed integer. Returns 0 if this
      value is infinity or not-a-number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.ToInt32Checked">

            <summary>Converts this number's value to a 32-bit signed integer if it can fit in
      a 32-bit signed integer after truncating to an integer.
    </summary><returns>This number's value, truncated to a 32-bit signed integer.
    </returns><exception cref='T:System.OverflowException'>This value is infinity or not-a-number, or the truncated integer is less
      than -2147483648 or greater than 2147483647.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EFloat.ToInt32IfExact">

            <summary>Converts this number's value to a 32-bit signed integer if it can fit in
      a 32-bit signed integer without rounding to a different numerical value.
    </summary><returns>This number's value as a 32-bit signed integer.
    </returns><exception cref='T:System.ArithmeticException'>This value is infinity or not-a-number, is not an exact integer, or is
      less than -2147483648 or greater than 2147483647.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EFloat.ToInt32Unchecked">

            <summary>Truncates this number's value to an integer and returns the
      least-significant bits of its two's-complement form as a 32-bit signed
      integer.
    </summary><returns>This number, converted to a 32-bit signed integer. Returns 0 if this
      value is infinity or not-a-number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.ToInt64Checked">

            <summary>Converts this number's value to a 64-bit signed integer if it can fit in
      a 64-bit signed integer after truncating to an integer.
    </summary><returns>This number's value, truncated to a 64-bit signed integer.
    </returns><exception cref='T:System.OverflowException'>This value is infinity or not-a-number, or the truncated integer is less
      than -9223372036854775808 or greater than 9223372036854775807.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EFloat.ToInt64IfExact">

            <summary>Converts this number's value to a 64-bit signed integer if it can fit in
      a 64-bit signed integer without rounding to a different numerical value.
    </summary><returns>This number's value as a 64-bit signed integer.
    </returns><exception cref='T:System.ArithmeticException'>This value is infinity or not-a-number, is not an exact integer, or is
      less than -9223372036854775808 or greater than 9223372036854775807.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EFloat.ToInt64Unchecked">

            <summary>Truncates this number's value to an integer and returns the
      least-significant bits of its two's-complement form as a 64-bit signed
      integer.
    </summary><returns>This number, converted to a 64-bit signed integer. Returns 0 if this
      value is infinity or not-a-number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.ToPlainString">

            <summary>Converts this value to a string, but without exponential notation.
    </summary><returns>A text string.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.ToSByteChecked">

            <summary>Converts this number's value to an 8-bit signed integer if it can fit in
      an 8-bit signed integer after truncating to an integer.
    </summary><returns>This number's value, truncated to an 8-bit signed integer.
    </returns><exception cref='T:System.OverflowException'>This value is infinity or not-a-number, or the truncated integer is less
      than -128 or greater than 127.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EFloat.ToSByteIfExact">

            <summary>Converts this number's value to an 8-bit signed integer if it can fit in
      an 8-bit signed integer without rounding to a different numerical value.
    </summary><returns>This number's value as an 8-bit signed integer.
    </returns><exception cref='T:System.ArithmeticException'>This value is infinity or not-a-number, is not an exact integer, or is
      less than -128 or greater than 127.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EFloat.ToSByteUnchecked">

            <summary>Truncates this number's value to an integer and returns the
      least-significant bits of its two's-complement form as an 8-bit signed
      integer.
    </summary><returns>This number, converted to an 8-bit signed integer. Returns 0 if this
      value is infinity or not-a-number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.ToShortestString(PeterO.Numbers.EContext)">

            <summary>Returns a string representation of this number's value after rounding to
      the given precision (using the given arithmetic context). If the number
      after rounding is neither infinity nor not-a-number (NaN), returns the
      shortest decimal form (in terms of nonzero decimal digits) of this
      number's value that results in the rounded number after the decimal form
      is converted to binary floating-point format (using the given arithmetic
      context).
    </summary><param name='ctx'>An arithmetic context to control precision (in bits), rounding, and
      exponent range of the rounded number. If
      <c>HasFlags</c>
       of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null. If this parameter is null or defines no maximum precision, returns
      the same value as the ToString() method.
    </param><returns>Shortest decimal form of this number's value for the given arithmetic
      context. The text string will be in exponential notation if the number's
      first nonzero decimal digit is more than five digits after the decimal
      point, or if the number's exponent is greater than 0 and its value is 10,
      000, 000 or greater.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.ToSingle">

            <summary>Converts this value to its closest equivalent as 32-bit floating-point
      number. The half-even rounding mode is used.
      <para>If this value is a NaN, sets the high bit of the 32-bit floating point
        number's significand area for a quiet NaN, and clears it for a signaling
        NaN. Then the other bits of the significand area are set to the lowest
        bits of this object's unsigned mantissa (significand), and the
        next-highest bit of the significand area is set if those bits are all
        zeros and this is a signaling NaN. Unfortunately, in the .NET
        implementation, the return value of this method may be a quiet NaN even
        if a signaling NaN would otherwise be generated.
      </para>
    </summary><returns>The closest 32-bit binary floating-point number to this value. The return
      value can be positive infinity or negative infinity if this value exceeds
      the range of a 32-bit floating point number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.ToString">

            <summary>Converts this number's value to a text string.
    </summary><returns>A string representation of this object. The value is converted to decimal
      and the decimal form of this number's value is returned. The text string
      will be in exponential notation if the converted number's scale is
      positive or if the number's first nonzero decimal digit is more than five
      digits after the decimal point.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.ToUInt16Checked">

            <summary>Converts this number's value to a 16-bit unsigned integer if it can fit
      in a 16-bit unsigned integer after truncating to an integer.
    </summary><returns>This number's value, truncated to a 16-bit unsigned integer.
    </returns><exception cref='T:System.OverflowException'>This value is infinity or not-a-number, or the truncated integer is less
      than 0 or greater than 65535.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EFloat.ToUInt16IfExact">

            <summary>Converts this number's value to a 16-bit unsigned integer if it can fit
      in a 16-bit unsigned integer without rounding to a different numerical
      value.
    </summary><returns>This number's value as a 16-bit unsigned integer.
    </returns><exception cref='T:System.ArithmeticException'>This value is infinity or not-a-number, is not an exact integer, or is
      less than 0 or greater than 65535.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EFloat.ToUInt16Unchecked">

            <summary>Truncates this number's value to an integer and returns the
      least-significant bits of its two's-complement form as a 16-bit unsigned
      integer.
    </summary><returns>This number, converted to a 16-bit unsigned integer. Returns 0 if this
      value is infinity or not-a-number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.ToUInt32Checked">

            <summary>Converts this number's value to a 32-bit signed integer if it can fit in
      a 32-bit signed integer after truncating to an integer.
    </summary><returns>This number's value, truncated to a 32-bit signed integer.
    </returns><exception cref='T:System.OverflowException'>This value is infinity or not-a-number, or the truncated integer is less
      than 0 or greater than 4294967295.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EFloat.ToUInt32IfExact">

            <summary>Converts this number's value to a 32-bit signed integer if it can fit in
      a 32-bit signed integer without rounding to a different numerical value.
    </summary><returns>This number's value as a 32-bit signed integer.
    </returns><exception cref='T:System.ArithmeticException'>This value is infinity or not-a-number, is not an exact integer, or is
      less than 0 or greater than 4294967295.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EFloat.ToUInt32Unchecked">

            <summary>Truncates this number's value to an integer and returns the
      least-significant bits of its two's-complement form as a 32-bit signed
      integer.
    </summary><returns>This number, converted to a 32-bit signed integer. Returns 0 if this
      value is infinity or not-a-number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.ToUInt64Checked">

            <summary>Converts this number's value to a 64-bit unsigned integer if it can fit
      in a 64-bit unsigned integer after truncating to an integer.
    </summary><returns>This number's value, truncated to a 64-bit unsigned integer.
    </returns><exception cref='T:System.OverflowException'>This value is infinity or not-a-number, or the truncated integer is less
      than 0 or greater than 18446744073709551615.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EFloat.ToUInt64IfExact">

            <summary>Converts this number's value to a 64-bit unsigned integer if it can fit
      in a 64-bit unsigned integer without rounding to a different numerical
      value.
    </summary><returns>This number's value as a 64-bit unsigned integer.
    </returns><exception cref='T:System.ArithmeticException'>This value is infinity or not-a-number, is not an exact integer, or is
      less than 0 or greater than 18446744073709551615.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EFloat.ToUInt64Unchecked">

            <summary>Truncates this number's value to an integer and returns the
      least-significant bits of its two's-complement form as a 64-bit unsigned
      integer.
    </summary><returns>This number, converted to a 64-bit unsigned integer. Returns 0 if this
      value is infinity or not-a-number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.Ulp">

            <summary>Returns the unit in the last place. The mantissa (significand) will be 1
      and the exponent will be this number's exponent. Returns 1 with an
      exponent of 0 if this number is infinity or not-a-number (NaN).
    </summary><returns>An arbitrary-precision binary floating-point number.
    </returns>

</doc>
<doc name="P:PeterO.Numbers.EFloat.UnsignedMantissa">

            <summary>Gets the absolute value of this object's unscaled value.
    </summary><value>The absolute value of this object's unscaled value.
    </value>

</doc>
<doc name="F:PeterO.Numbers.EFloat.Zero">

            <summary>Represents the number 0.
    </summary>

</doc>
<doc name="M:PeterO.Numbers.EFloat.op_Addition(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat)">

            <summary>Adds two arbitrary-precision binary floating-point numbers and returns
      the result.
    </summary><param name='bthis'>The first arbitrary-precision binary floating-point number.
    </param><param name='otherValue'>The second arbitrary-precision binary floating-point number.
    </param><returns>The sum of the two objects.
    </returns><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='bthis'/>
       or
      <paramref name='otherValue'/>
       is null.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EFloat.op_Division(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat)">

            <summary>Divides one binary float by another and returns the result. When
      possible, the result will be exact.
    </summary><param name='dividend'>The number that will be divided by the divisor.
    </param><param name='divisor'>The number to divide by.
    </param><returns>The quotient of the two numbers. Returns infinity if the divisor is 0 and
      the dividend is nonzero. Returns not-a-number (NaN) if the divisor and the
      dividend are 0. Returns NaN if the result can't be exact because it would
      have a nonterminating binary expansion.
    </returns><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='dividend'/>
       is null.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EFloat.op_Explicit(PeterO.Numbers.EFloat)~PeterO.Numbers.EInteger">

            <summary>Converts an arbitrary-precision binary float to a value to an
      arbitrary-precision integer. Any fractional part in this value will be
      discarded when converting to an arbitrary-precision integer.
    </summary><param name='bigValue'>The number to convert as an arbitrary-precision binary float.
    </param><returns>An arbitrary-precision integer.
    </returns><exception cref='T:System.OverflowException'>This object's value is infinity or not-a-number (NaN).
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EFloat.op_Explicit(PeterO.Numbers.EFloat)~System.Byte">

            <summary>Converts an arbitrary-precision binary float to a byte (from 0 to 255) if
      it can fit in a byte (from 0 to 255) after truncating to an integer.
    </summary><param name='input'>The number to convert as an arbitrary-precision binary float.
    </param><returns>The value of
      <paramref name='input'/>
       , truncated to a byte (from 0 to 255).
    </returns><exception cref='T:System.OverflowException'>The parameter
      <paramref name='input'/>
       is infinity or not-a-number, or the truncated integer is less than 0 or
      greater than 255.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EFloat.op_Explicit(PeterO.Numbers.EFloat)~System.Double">

            <summary>Converts this value to its closest equivalent as a 64-bit floating-point
      number. The half-even rounding mode is used.
      <para>If this value is a NaN, sets the high bit of the 64-bit floating point
        number's significand area for a quiet NaN, and clears it for a signaling
        NaN. Then the other bits of the significand area are set to the lowest
        bits of this object's unsigned mantissa (significand), and the
        next-highest bit of the significand area is set if those bits are all
        zeros and this is a signaling NaN. Unfortunately, in the .NET
        implementation, the return value of this method may be a quiet NaN even
        if a signaling NaN would otherwise be generated.
      </para>
    </summary><param name='bigValue'>The value to convert to a 64-bit floating-point number.
    </param><returns>The closest 64-bit floating-point number to this value. The return value
      can be positive infinity or negative infinity if this value exceeds the
      range of a 64-bit floating point number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.op_Explicit(PeterO.Numbers.EFloat)~System.Int16">

            <summary>Converts an arbitrary-precision binary float to a 16-bit signed integer
      if it can fit in a 16-bit signed integer after truncating to an integer.
    </summary><param name='input'>The number to convert as an arbitrary-precision binary float.
    </param><returns>The value of
      <paramref name='input'/>
       , truncated to a 16-bit signed integer.
    </returns><exception cref='T:System.OverflowException'>The parameter
      <paramref name='input'/>
       is infinity or not-a-number, or the truncated integer is less than -32768
      or greater than 32767.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EFloat.op_Explicit(PeterO.Numbers.EFloat)~System.Int32">

            <summary>Converts an arbitrary-precision binary float to a 32-bit signed integer
      if it can fit in a 32-bit signed integer after truncating to an integer.
    </summary><param name='input'>The number to convert as an arbitrary-precision binary float.
    </param><returns>The value of
      <paramref name='input'/>
       , truncated to a 32-bit signed integer.
    </returns><exception cref='T:System.OverflowException'>The parameter
      <paramref name='input'/>
       is infinity or not-a-number, or the truncated integer is less than
      -2147483648 or greater than 2147483647.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EFloat.op_Explicit(PeterO.Numbers.EFloat)~System.Int64">

            <summary>Converts an arbitrary-precision binary float to a 64-bit signed integer
      if it can fit in a 64-bit signed integer after truncating to an integer.
    </summary><param name='input'>The number to convert as an arbitrary-precision binary float.
    </param><returns>The value of
      <paramref name='input'/>
       , truncated to a 64-bit signed integer.
    </returns><exception cref='T:System.OverflowException'>The parameter
      <paramref name='input'/>
       is infinity or not-a-number, or the truncated integer is less than
      -9223372036854775808 or greater than 9223372036854775807.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EFloat.op_Explicit(PeterO.Numbers.EFloat)~System.SByte">

            <summary>Converts an arbitrary-precision binary float to an 8-bit signed integer
      if it can fit in an 8-bit signed integer after truncating to an integer.
    </summary><param name='input'>The number to convert as an arbitrary-precision binary float.
    </param><returns>The value of
      <paramref name='input'/>
       , truncated to an 8-bit signed integer.
    </returns><exception cref='T:System.OverflowException'>The parameter
      <paramref name='input'/>
       is infinity or not-a-number, or the truncated integer is less than -128
      or greater than 127.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EFloat.op_Explicit(PeterO.Numbers.EFloat)~System.Single">

            <summary>Converts an arbitrary-precision binary float to its closest equivalent as
      a 32-bit floating-point number. The half-even rounding mode is used.
      <para>If this value is a NaN, sets the high bit of the 32-bit floating point
        number's significand area for a quiet NaN, and clears it for a signaling
        NaN. Then the other bits of the significand area are set to the lowest
        bits of this object's unsigned mantissa (significand), and the
        next-highest bit of the significand area is set if those bits are all
        zeros and this is a signaling NaN. Unfortunately, in the .NET
        implementation, the return value of this method may be a quiet NaN even
        if a signaling NaN would otherwise be generated.
      </para>
    </summary><param name='bigValue'>The number to convert as an arbitrary-precision binary float.
    </param><returns>The closest 32-bit binary floating-point number to this value. The return
      value can be positive infinity or negative infinity if this value exceeds
      the range of a 32-bit floating point number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.op_Explicit(PeterO.Numbers.EFloat)~System.UInt16">

            <summary>Converts an arbitrary-precision binary float to a 16-bit unsigned integer
      if it can fit in a 16-bit unsigned integer after truncating to an integer.

    </summary><param name='input'>The number to convert as an arbitrary-precision binary float.
    </param><returns>The value of
      <paramref name='input'/>
       , truncated to a 16-bit unsigned integer.
    </returns><exception cref='T:System.OverflowException'>The parameter
      <paramref name='input'/>
       is infinity or not-a-number, or the truncated integer is less than 0 or
      greater than 65535.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EFloat.op_Explicit(PeterO.Numbers.EFloat)~System.UInt32">

            <summary>Converts an arbitrary-precision binary float to a 32-bit signed integer
      if it can fit in a 32-bit signed integer after truncating to an integer.
    </summary><param name='input'>The number to convert as an arbitrary-precision binary float.
    </param><returns>The value of
      <paramref name='input'/>
       , truncated to a 32-bit signed integer.
    </returns><exception cref='T:System.OverflowException'>The parameter
      <paramref name='input'/>
       is infinity or not-a-number, or the truncated integer is less than 0 or
      greater than 4294967295.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EFloat.op_Explicit(PeterO.Numbers.EFloat)~System.UInt64">

            <summary>Converts an arbitrary-precision binary float to a 64-bit unsigned integer
      if it can fit in a 64-bit unsigned integer after truncating to an integer.

    </summary><param name='input'>The number to convert as an arbitrary-precision binary float.
    </param><returns>The value of
      <paramref name='input'/>
       , truncated to a 64-bit unsigned integer.
    </returns><exception cref='T:System.OverflowException'>The parameter
      <paramref name='input'/>
       is infinity or not-a-number, or the truncated integer is less than 0 or
      greater than 18446744073709551615.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EFloat.op_Implicit(PeterO.Numbers.EInteger)~PeterO.Numbers.EFloat">

            <summary>Converts an arbitrary-precision integer to an arbitrary precision binary.

    </summary><param name='eint'>An arbitrary-precision integer.
    </param><returns>An arbitrary-precision binary float with the exponent set to 0.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.op_Implicit(System.Byte)~PeterO.Numbers.EFloat">

            <summary>Converts a byte (from 0 to 255) to an arbitrary-precision binary float.
    </summary><param name='inputByte'>The number to convert as a byte (from 0 to 255).
    </param><returns>The value of
      <paramref name='inputByte'/>
       as an arbitrary-precision binary float.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.op_Implicit(System.Double)~PeterO.Numbers.EFloat">

            <summary>Creates a binary float from a 64-bit floating-point number. This method
      computes the exact value of the floating point number, not an
      approximation, as is often the case by converting the floating point
      number to a string first.
    </summary><param name='dbl'>The parameter
      <paramref name='dbl'/>
       is a 64-bit floating-point number.
    </param><returns>A binary float with the same value as
      <paramref name='dbl'/>
       .
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.op_Implicit(System.Int16)~PeterO.Numbers.EFloat">

            <summary>Converts a 16-bit signed integer to an arbitrary-precision binary float.
    </summary><param name='inputInt16'>The number to convert as a 16-bit signed integer.
    </param><returns>The value of
      <paramref name='inputInt16'/>
       as an arbitrary-precision binary float.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.op_Implicit(System.Int32)~PeterO.Numbers.EFloat">

            <summary>Converts a 32-bit signed integer to an arbitrary-precision binary float.
    </summary><param name='inputInt32'>The number to convert as a 32-bit signed integer.
    </param><returns>The value of
      <paramref name='inputInt32'/>
       as an arbitrary-precision binary float.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.op_Implicit(System.Int64)~PeterO.Numbers.EFloat">

            <summary>Converts a 64-bit signed integer to an arbitrary-precision binary float.
    </summary><param name='inputInt64'>The number to convert as a 64-bit signed integer.
    </param><returns>The value of
      <paramref name='inputInt64'/>
       as an arbitrary-precision binary float.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.op_Implicit(System.SByte)~PeterO.Numbers.EFloat">

            <summary>Converts an 8-bit signed integer to an arbitrary-precision binary float.
    </summary><param name='inputSByte'>The number to convert as an 8-bit signed integer.
    </param><returns>The value of
      <paramref name='inputSByte'/>
       as an arbitrary-precision binary float.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.op_Implicit(System.Single)~PeterO.Numbers.EFloat">

            <summary>Creates a binary float from a 32-bit floating-point number. This method
      computes the exact value of the floating point number, not an
      approximation, as is often the case by converting the floating point
      number to a string first.
    </summary><param name='flt'>The parameter
      <paramref name='flt'/>
       is a 32-bit binary floating-point number.
    </param><returns>A binary float with the same value as
      <paramref name='flt'/>
       .
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.op_Implicit(System.UInt16)~PeterO.Numbers.EFloat">

            <summary>Converts a 16-bit unsigned integer to an arbitrary-precision binary
      float.
    </summary><param name='inputUInt16'>The number to convert as a 16-bit unsigned integer.
    </param><returns>The value of
      <paramref name='inputUInt16'/>
       as an arbitrary-precision binary float.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.op_Implicit(System.UInt32)~PeterO.Numbers.EFloat">

            <summary>Converts a 32-bit signed integer to an arbitrary-precision binary float.
    </summary><param name='inputUInt32'>The number to convert as a 32-bit signed integer.
    </param><returns>The value of
      <paramref name='inputUInt32'/>
       as an arbitrary-precision binary float.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.op_Implicit(System.UInt64)~PeterO.Numbers.EFloat">

            <summary>Converts a 64-bit unsigned integer to an arbitrary-precision binary
      float.
    </summary><param name='inputUInt64'>The number to convert as a 64-bit unsigned integer.
    </param><returns>The value of
      <paramref name='inputUInt64'/>
       as an arbitrary-precision binary float.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EFloat.op_Modulus(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat)">

            <summary>Finds the remainder when dividing one arbitrary-precision binary float by
      another.
    </summary><param name='dividend'>The number that will be divided by the divisor.
    </param><param name='divisor'>The number to divide by.
    </param><returns>The result of the operation.
    </returns><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='dividend'/>
       is null.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EFloat.op_Multiply(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat)">

            <summary>Multiplies two binary floats. The resulting exponent will be the sum of
      the exponents of the two binary floats.
    </summary><param name='operand1'>The first operand.
    </param><param name='operand2'>The second operand.
    </param><returns>The product of the two binary floats.
    </returns><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='operand1'/>
       is null.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EFloat.op_Subtraction(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat)">

            <summary>Subtracts one arbitrary-precision binary float from another.
    </summary><param name='bthis'>The first operand.
    </param><param name='subtrahend'>The second operand.
    </param><returns>The difference of the two objects.
    </returns><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='bthis'/>
       is null.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EFloat.op_UnaryNegation(PeterO.Numbers.EFloat)">

            <summary>Gets an object with the same value as this one, but with the sign
      reversed.
    </summary><param name='bigValue'>An arbitrary-precision binary float.
    </param><returns>The negated form of the given number. If the given number is positive
      zero, returns negative zero. Returns signaling NaN if this value is
      signaling NaN.
    </returns><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='bigValue'/>
       is null.
    </exception>

</doc>
<doc name="T:PeterO.Numbers.EInteger">

            <summary>Represents an arbitrary-precision integer. (The "E" stands for
      "extended", and has this prefix to group it with the other classes common
      to this library, particularly EDecimal, EFloat, and ERational.)
      <para>Instances of this class are immutable, so they are inherently safe for
        use by multiple threads. Multiple instances of this object with the same
        value are interchangeable, but they should be compared using the
        "Equals" method rather than the "==" operator.
      </para>
      <para><b>Security note</b>
      </para>
      <para>It is not recommended to implement security-sensitive algorithms using
        the methods in this class, for several reasons:
      </para>
      <list>
        <item><c>EInteger</c>
           objects are immutable, so they can't be modified, and the memory they
          occupy is not guaranteed to be cleared in a timely fashion due to
          garbage collection. This is relevant for applications that use
          many-bit-long numbers as secret parameters.
        </item>
        <item>The methods in this class (especially those that involve arithmetic)
          are not guaranteed to run in constant time for all relevant inputs.
          Certain attacks that involve encrypted communications have exploited
          the timing and other aspects of such communications to derive keying
          material or cleartext indirectly.
        </item>
      </list>
      <para>Applications should instead use dedicated security libraries to handle big numbers in security-sensitive algorithms.
      </para>
    </summary>

</doc>
<doc name="M:PeterO.Numbers.EInteger.Abs">

            <summary>Returns the absolute value of this object's value.
    </summary><returns>This object's value with the sign removed.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EInteger.Add(PeterO.Numbers.EInteger)">

            <summary>Adds this object and another object.
    </summary><param name='bigintAugend'>Another arbitrary-precision integer.
    </param><returns>The sum of the two objects.
    </returns><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='bigintAugend'/>
       is null.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EInteger.Add(System.Int32)">

            <summary>Adds this object and another object.
    </summary><param name='intValue'>The parameter
      <paramref name='intValue'/>
       is a 32-bit signed integer.
    </param><returns>The sum of the two objects.
    </returns><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='bigintAugend'/>
       is null.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EInteger.And(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">

            <summary>Does an AND operation between two arbitrary-precision integer values.
    </summary><param name='a'>The first arbitrary-precision integer.
    </param><param name='b'>The second arbitrary-precision integer.
    </param><returns>An arbitrary-precision integer.
    </returns><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='a'/>
       or
      <paramref name='b'/>
       is null.
    </exception><remarks>
       Each arbitrary-precision integer is treated as a two's-complement form
      (see
      <see cref='T:PeterO.Numbers.EDecimal'>
         "Forms of numbers"
      </see>
       ) for the purposes of this operator.
    </remarks>

</doc>
<doc name="M:PeterO.Numbers.EInteger.AsInt32Checked">

            <summary>Converts this object's value to a 32-bit signed integer, throwing an
      exception if it can't fit.
    </summary><returns>A 32-bit signed integer.
    </returns><exception cref=' T:System.OverflowException'>This object' s value is too big to fit a 32-bit signed integer.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EInteger.AsInt32Unchecked">

            <summary>Converts this object's value to a 32-bit signed integer. If the value
      can't fit in a 32-bit integer, returns the lower 32 bits of this object's
      two' s-complement form (see
      <see cref='T:PeterO.Numbers.EDecimal'>
         "Forms of numbers"
      </see>
       ) (in which case the return value might have a different sign than this
      object's value).
    </summary><returns>A 32-bit signed integer.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EInteger.AsInt64Checked">

            <summary>Converts this object's value to a 64-bit signed integer, throwing an
      exception if it can't fit.
    </summary><returns>A 64-bit signed integer.
    </returns><exception cref=' T:System.OverflowException'>This object' s value is too big to fit a 64-bit signed integer.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EInteger.AsInt64Unchecked">

            <summary>Converts this object's value to a 64-bit signed integer. If the value
      can't fit in a 64-bit integer, returns the lower 64 bits of this object's
      two' s-complement form (see
      <see cref='T:PeterO.Numbers.EDecimal'>
         "Forms of numbers"
      </see>
       ) (in which case the return value might have a different sign than this
      object's value).
    </summary><returns>A 64-bit signed integer.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EInteger.CanFitInInt32">

            <summary>Returns whether this object's value can fit in a 32-bit signed integer.
    </summary><returns><c>true</c>
       if this object's value is from -2147483648 through 2147483647; otherwise, <c>false</c>
       .
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EInteger.CanFitInInt64">

            <summary>Returns whether this object's value can fit in a 64-bit signed integer.
    </summary><returns><c>true</c>
       if this object's value is from -9223372036854775808 through
      9223372036854775807; otherwise, <c>false</c>
       .
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EInteger.CompareTo(PeterO.Numbers.EInteger)">

            <summary>Compares an arbitrary-precision integer with this instance.
    </summary><param name='other'>The integer to compare to this value.
    </param><returns>Zero if the values are equal; a negative number if this instance is less,
      or a positive number if this instance is greater.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EInteger.CompareTo(System.Int32)">

            <summary>Compares an arbitrary-precision integer with this instance.
    </summary><param name='intValue'>The parameter
      <paramref name='intValue'/>
       is a 32-bit signed integer.
    </param><returns>Zero if the values are equal; a negative number if this instance is less,
      or a positive number if this instance is greater.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EInteger.DivRem(PeterO.Numbers.EInteger)">

            <summary>Divides this object by another arbitrary-precision integer and returns
      the quotient and remainder.
    </summary><param name='divisor'>The number to divide by.
    </param><returns>An array with two arbitrary-precision integers: the first is the
      quotient, and the second is the remainder.
    </returns><exception cref='T:System.DivideByZeroException'>The parameter divisor is 0.
    </exception><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='divisor'/>
       is null.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EInteger.DivRem(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger,PeterO.Numbers.EInteger@)">

            <summary>Divides one arbitrary-precision integer by another, and returns the
      quotient and sets an output parameter to the remainder.
    </summary><param name='dividend'>The arbitrary-precision integer to be divided.
    </param><param name='divisor'>The arbitrary-precision integer to divide by.
    </param><param name='remainder'>An arbitrary-precision integer.
    </param><returns>An array of two arbitrary-precision integers: the first is the quotient,
      and the second is the remainder.
    </returns><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='dividend'/>
       or
      <paramref name='divisor'/>
       is null.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EInteger.Divide(PeterO.Numbers.EInteger)">

            <summary>Divides this instance by the value of an arbitrary-precision integer. The
      result is rounded down (the fractional part is discarded). Except if the
      result is 0, it will be negative if this object is positive and the other
      is negative, or vice versa, and will be positive if both are positive or
      both are negative.
    </summary><param name='bigintDivisor'>Another arbitrary-precision integer.
    </param><returns>The quotient of the two objects.
    </returns><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='bigintDivisor'/>
       is null.
    </exception><exception cref='T:System.DivideByZeroException'>Attempted to divide by zero.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EInteger.Divide(System.Int32)">

            <summary>Divides this instance by the value of an arbitrary-precision integer. The
      result is rounded down (the fractional part is discarded). Except if the
      result is 0, it will be negative if this object is positive and the other
      is negative, or vice versa, and will be positive if both are positive or
      both are negative.
    </summary><param name='intValue'>The parameter
      <paramref name='intValue'/>
       is a 32-bit signed integer.
    </param><returns>The quotient of the two objects.
    </returns><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='bigintDivisor'/>
       is null.
    </exception><exception cref='T:System.DivideByZeroException'>Attempted to divide by zero.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EInteger.Equals(PeterO.Numbers.EInteger)">

            <summary>Determines whether this object and another object are equal.
    </summary><param name='other'>Another arbitrary-precision integer.
    </param><returns><c>true</c>
       if this object and another object are equal; otherwise, <c>false</c>
       .
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EInteger.Equals(System.Object)">

            <summary>Determines whether this object and another object are equal and have the
      same type.
    </summary><param name='obj'>The parameter
      <paramref name='obj'/>
       is an arbitrary object.
    </param><returns><c>true</c>
       if this object and another object are equal; otherwise, <c>false</c>
       .
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EInteger.FromByte(System.Byte)">

            <summary>Converts a byte (from 0 to 255) to an arbitrary-precision integer.
    </summary><param name='inputByte'>The number to convert as a byte (from 0 to 255).
    </param><returns>This number's value as an arbitrary-precision integer.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EInteger.FromBytes(System.Byte[],System.Boolean)">

            <summary>Initializes an arbitrary-precision integer from an array of bytes.
    </summary><param name='bytes'>A byte array consisting of the two's-complement form (see
      <see cref='T:PeterO.Numbers.EDecimal'>
        "Forms of numbers"
      </see>
       ) of the arbitrary-precision integer to create. The byte array is encoded
      using the following rules:
      <list>
        <item>Positive numbers have the first byte's highest bit cleared, and
          negative numbers have the bit set.
        </item>
        <item>The last byte contains the lowest 8-bits, the next-to-last contains
          the next lowest 8 bits, and so on. For example, the number 300 can be
          encoded as
          <c>0x01, 0x2C</c>
           and 200 as
          <c>0x00, 0xC8</c>
          . (Note that the second example contains a set high bit in
          <c>0xC8</c>
          , so an additional 0 is added at the start to ensure it's interpreted
          as positive.)
        </item>
        <item>To encode negative numbers, take the absolute value of the number,
          subtract by 1, encode the number into bytes, and toggle each bit of
          each byte. Any further bits that appear beyond the most significant
          bit of the number will be all ones. For example, the number -450 can
          be encoded as
          <c>0xfe, 0x70</c>
           and -52869 as
          <c>0xff, 0x31, 0x7B</c>
          . (Note that the second example contains a cleared high bit in
          <c>0x31, 0x7B</c>
          , so an additional 0xff is added at the start to ensure it's
          interpreted as negative.)
        </item>
      </list>
      <para>For little-endian, the byte order is reversed from the byte order just
        discussed.
      </para>
      .
    </param><param name='littleEndian'>If true, the byte order is little-endian, or least-significant-byte first.
      If false, the byte order is big-endian, or most-significant-byte first.
    </param><returns>An arbitrary-precision integer. Returns 0 if the byte array's length is
      0.
    </returns><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='bytes'/>
       is null.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EInteger.FromInt16(System.Int16)">

            <summary>Converts a 16-bit signed integer to an arbitrary-precision integer.
    </summary><param name='inputInt16'>The number to convert as a 16-bit signed integer.
    </param><returns>This number's value as an arbitrary-precision integer.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EInteger.FromInt32(System.Int32)">

            <summary>Converts a 32-bit signed integer to an arbitrary-precision integer.
    </summary><param name='intValue'>The parameter
      <paramref name='intValue'/>
       is a 32-bit signed integer.
    </param><returns>An arbitrary-precision integer with the same value as the 64-bit number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EInteger.FromInt64(System.Int64)">

            <summary>Converts a 64-bit signed integer to an arbitrary-precision integer.
    </summary><param name='longerValue'>The parameter
      <paramref name='longerValue'/>
       is a 64-bit signed integer.
    </param><returns>An arbitrary-precision integer with the same value as the 64-bit number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EInteger.FromRadixString(System.String,System.Int32)">

            <summary>Converts a string to an arbitrary-precision integer in a given radix.
    </summary><param name='str'>A string described by the FromRadixSubstring method.
    </param><param name='radix'>A base from 2 to 36. Depending on the radix, the string can use the basic
      digits 0 to 9 (U+0030 to U+0039) and then the basic letters A to Z (U+0041
      to U+005A). For example, 0-9 in radix 10, and 0-9, then A-F in radix 16.
    </param><returns>An arbitrary-precision integer with the same value as the given string.
    </returns><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       is null.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EInteger.FromRadixSubstring(System.String,System.Int32,System.Int32,System.Int32)">

            <summary>Converts a portion of a string to an arbitrary-precision integer in a
      given radix.
    </summary><param name='str'>A text string. The desired portion of the string must contain only
      characters allowed by the given radix, except that it may start with a
      minus sign ("-", U+002D) to indicate a negative number. The desired
      portion is not allowed to contain white space characters, including
      spaces.
    </param><param name='radix'>A base from 2 to 36. Depending on the radix, the string can use the basic
      digits 0 to 9 (U+0030 to U+0039) and then the basic letters A to Z (U+0041
      to U+005A). For example, 0-9 in radix 10, and 0-9, then A-F in radix 16.
    </param><param name='index'>The index of the string that starts the string portion.
    </param><param name='endIndex'>The index of the string that ends the string portion. The length will be
      index + endIndex - 1.
    </param><returns>An arbitrary-precision integer with the same value as given in the string
      portion.
    </returns><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       is null.
    </exception><exception cref='T:System.FormatException'>The string portion is empty or in an invalid format.
    </exception><exception cref='T:System.ArgumentException'>"Doesn't satisfy (endIndex - index) % 4 == 0".
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EInteger.FromSByte(System.SByte)">

            <summary>Converts an 8-bit signed integer to an arbitrary-precision integer.
    </summary><param name='inputSByte'>The number to convert as an 8-bit signed integer.
    </param><returns>This number's value as an arbitrary-precision integer.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EInteger.FromString(System.String)">

            <summary>Converts a string to an arbitrary-precision integer.
    </summary><param name='str'>A text string. The string must contain only basic digits 0 to 9 (U+0030 to
      U+0039), except that it may start with a minus sign ("-", U+002D) to
      indicate a negative number. The string is not allowed to contain white
      space characters, including spaces.
    </param><returns>An arbitrary-precision integer with the same value as given in the
      string.
    </returns><exception cref='T:System.FormatException'>The parameter
      <paramref name='str'/>
       is in an invalid format.
    </exception><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       is null.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EInteger.FromSubstring(System.String,System.Int32,System.Int32)">

            <summary>Converts a portion of a string to an arbitrary-precision integer.
    </summary><param name='str'>A text string. The desired portion of the string must contain only basic
      digits 0 to 9 (U+0030 to U+0039), except that it may start with a minus
      sign ("-", U+002D) to indicate a negative number. The desired portion is
      not allowed to contain white space characters, including spaces.
    </param><param name='index'>The index of the string that starts the string portion.
    </param><param name='endIndex'>The index of the string that ends the string portion. The length will be
      index + endIndex - 1.
    </param><returns>An arbitrary-precision integer with the same value as given in the string
      portion.
    </returns><exception cref='T:System.ArgumentException'>The parameter
      <paramref name='index'/>
       is less than 0,
      <paramref name='endIndex'/>
       is less than 0, or either is greater than the string's length, or
      <paramref name='endIndex'/>
       is less than
      <paramref name='index'/>
       .
    </exception><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       is null.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EInteger.FromUInt16(System.UInt16)">

            <summary>Converts a 16-bit unsigned integer to an arbitrary-precision integer.
    </summary><param name='inputUInt16'>The number to convert as a 16-bit unsigned integer.
    </param><returns>This number's value as an arbitrary-precision integer.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EInteger.FromUInt32(System.UInt32)">

            <summary>Converts a 32-bit signed integer to an arbitrary-precision integer.
    </summary><param name='inputUInt32'>The number to convert as a 32-bit signed integer.
    </param><returns>This number's value as an arbitrary-precision integer.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EInteger.FromUInt64(System.UInt64)">

            <summary>Converts a 64-bit unsigned integer to an arbitrary-precision integer.
    </summary><param name='ulongValue'>The number to convert as a 64-bit unsigned integer.
    </param><returns>The value of
      <paramref name='ulongValue'/>
       as an arbitrary-precision integer.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EInteger.Gcd(PeterO.Numbers.EInteger)">

            <summary>Returns the greatest common divisor of this integer and the given
      integer. The greatest common divisor (GCD) is also known as the greatest
      common factor (GCF).
    </summary><param name='bigintSecond'>Another arbitrary-precision integer.
    </param><returns>An arbitrary-precision integer.
    </returns><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='bigintSecond'/>
       is null.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EInteger.GetBits(System.Int32,System.Int32)">

            <summary>Retrieves bits from this integer's two' s-complement form.
    </summary><param name='index'>Zero-based index of the first bit to retrieve, where 0 is the
      least-significant bit of the number.
    </param><param name='numberBits'>The number of bits to retrieve, starting with the first. Must be from 0
      through 64.
    </param><returns>A 64-bit signed integer containing the bits from this integer's two'
      s-complement form. The least significant bit is the first bit, and any
      unused bits are set to 0.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EInteger.GetDigitCount">

            <summary>Returns the number of decimal digits used by this integer.
    </summary><returns>The number of digits in the decimal form of this integer. Returns 1 if
      this number is 0.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EInteger.GetHashCode">

            <summary>Returns the hash code for this instance. No application or process IDs
      are used in the hash code calculation.
    </summary><returns>A 32-bit signed integer.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EInteger.GetLowBit">

            <summary>Gets the lowest set bit in this number's absolute value. (This will also
      be the lowest set bit in the number's two's-complement form (see
      <see cref='T:PeterO.Numbers.EDecimal'>
         "Forms of numbers"
      </see>
       ).).
    </summary><returns>The lowest bit set in the number, starting at 0. Returns -1 if this value
      is 0 or odd.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EInteger.GetLowBitAsEInteger">

            <summary>Gets the lowest set bit in this number's absolute value. (This will also
      be the lowest set bit in the number's two's-complement form (see
      <see cref='T:PeterO.Numbers.EDecimal'>
         "Forms of numbers"
      </see>
       ).).
    </summary><returns>The lowest bit set in the number, starting at 0. Returns -1 if this value
      is 0 or odd.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EInteger.GetSignedBit(System.Int32)">

            <summary>Returns whether a bit is set in the two's-complement form (see
      <see cref='T:PeterO.Numbers.EDecimal'>
         "Forms of numbers"
      </see>
       ) of this object' s value.
    </summary><param name='index'>The parameter
      <paramref name='index'/>
       is a 32-bit signed integer.
    </param><returns><c>true</c>
       if a bit is set in the two' s-complement form (see
      <see cref='T:PeterO.Numbers.EDecimal'>
         "Forms of numbers"
      </see>
       ) of this object' s value; otherwise, <c>false</c>
       .
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EInteger.GetSignedBitLength">

            <summary>Finds the minimum number of bits needed to represent this object's value,
      except for its sign. If the value is negative, finds the number of bits in
      the value equal to this object's absolute value minus 1.
    </summary><returns>The number of bits in this object's value. Returns 0 if this object's
      value is 0 or negative 1.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EInteger.GetUnsignedBit(System.Int32)">

            <summary>Returns whether a bit is set in this number's absolute value.
    </summary><param name='index'>Zero based index of the bit to test. 0 means the least significant bit.
    </param><returns><c>true</c>
       if a bit is set in this number's absolute value.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EInteger.GetUnsignedBitLength">

            <summary>Finds the minimum number of bits needed to represent this number's
      absolute value.
    </summary><returns>The number of bits in this object's value. Returns 0 if this object's
      value is 0, and returns 1 if the value is negative 1.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EInteger.GetUnsignedBitLengthAsEInteger">

            <summary>Finds the minimum number of bits needed to represent this number's
      absolute value.
    </summary><returns>The number of bits in this object's value. Returns 0 if this object's
      value is 0, and returns 1 if the value is negative 1.
    </returns>

</doc>
<doc name="P:PeterO.Numbers.EInteger.IsEven">

            <summary>Gets a value indicating whether this value is even.
    </summary><value><c>true</c>
       if this value is even; otherwise, <c>false</c>
       .
    </value>

</doc>
<doc name="P:PeterO.Numbers.EInteger.IsPowerOfTwo">

            <summary>Gets a value indicating whether this object's value is a power of two.
    </summary><value><c>true</c>
       if this object's value is a power of two; otherwise, <c>false</c>
       .
      <c>true</c>
       if this object' s value is a power of two; otherwise, <c>false</c>
       .
    </value>

</doc>
<doc name="P:PeterO.Numbers.EInteger.IsZero">

            <summary>Gets a value indicating whether this value is 0.
    </summary><value><c>true</c>
       if this value is 0; otherwise, <c>false</c>
       .
    </value>

</doc>
<doc name="M:PeterO.Numbers.EInteger.Mod(PeterO.Numbers.EInteger)">

            <summary>Finds the modulus remainder that results when this instance is divided by
      the value of an arbitrary-precision integer. The modulus remainder is the
      same as the normal remainder if the normal remainder is positive, and
      equals divisor plus normal remainder if the normal remainder is negative.
    </summary><param name='divisor'>The number to divide by.
    </param><returns>An arbitrary-precision integer.
    </returns><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='divisor'/>
       is null.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EInteger.ModPow(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">

            <summary>Calculates the remainder when this arbitrary-precision integer raised to
      a certain power is divided by another arbitrary-precision integer.
    </summary><param name='pow'>The power to raise this integer by.
    </param><param name='mod'>The integer to divide the raised number by.
    </param><returns>An arbitrary-precision integer.
    </returns><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='pow'/>
       or
      <paramref name='mod'/>
       is null.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EInteger.ModPow(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">

            <summary>Calculates the remainder when an arbitrary-precision integer raised to a
      certain power is divided by another arbitrary-precision integer.
    </summary><param name='bigintValue'>The starting operand.
    </param><param name='pow'>The power to raise this integer by.
    </param><param name='mod'>The integer to divide the raised number by.
    </param><returns>The value (
      <paramref name='bigintValue'/>
       ^
      <paramref name='pow'/>
       )%
      <paramref name='mod'/>
       .
    </returns><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='bigintValue'/>
       is null.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EInteger.Multiply(PeterO.Numbers.EInteger)">

            <summary>Multiplies this instance by the value of an arbitrary-precision integer
      object.
    </summary><param name='bigintMult'>Another arbitrary-precision integer.
    </param><returns>The product of the two numbers.
    </returns><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='bigintMult'/>
       is null.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EInteger.Multiply(System.Int32)">

            <summary>Multiplies this instance by the value of an arbitrary-precision integer
      object.
    </summary><param name='intValue'>The parameter
      <paramref name='intValue'/>
       is a 32-bit signed integer.
    </param><returns>The product of the two numbers.
    </returns><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='bigintMult'/>
       is null.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EInteger.Negate">

            <summary>Gets the value of this object with the sign reversed.
    </summary><returns>This object's value with the sign reversed.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EInteger.Not(PeterO.Numbers.EInteger)">

            <summary>Returns an arbitrary-precision integer with every bit flipped.
    </summary><param name='valueA'>The operand as an arbitrary-precision integer.
    </param><returns>An arbitrary-precision integer.
    </returns><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='valueA'/>
       is null.
    </exception>

</doc>
<doc name="P:PeterO.Numbers.EInteger.One">

            <summary>Gets the number 1 as an arbitrary-precision integer.
    </summary><value>The number 1 as an arbitrary-precision integer.
    </value>

</doc>
<doc name="M:PeterO.Numbers.EInteger.Or(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">

            <summary>Does an OR operation between two arbitrary-precision integer instances.
    </summary><param name='first'>The first operand.
    </param><param name='second'>The second operand.
    </param><returns>An arbitrary-precision integer.
    </returns><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='first'/>
       or
      <paramref name='second'/>
       is null.
    </exception><remarks>
       Each arbitrary-precision integer is treated as a two's-complement form
      (see
      <see cref='T:PeterO.Numbers.EDecimal'>
         "Forms of numbers"
      </see>
       ) for the purposes of this operator.
    </remarks>

</doc>
<doc name="M:PeterO.Numbers.EInteger.Pow(System.Int32)">
<summary>Raises an arbitrary-precision integer to a power.
    </summary>
    <param name='powerSmall'>The exponent to raise to.
    </param>
    <returns>The result. Returns 1 if &#x22;powerSmall&#x22; is 0.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.EInteger.PowBigIntVar(PeterO.Numbers.EInteger)">
<summary>Raises an arbitrary-precision integer to a power, which is given as
      another arbitrary-precision integer.
    </summary>
    <param name='power'>The exponent to raise to.
    </param>
    <returns>The result. Returns 1 if &#x22;power&#x22; is 0.
    </returns>
    <exception cref='T:System.ArgumentException'>The parameter
      <paramref name='power'/>
       is less than 0.
    </exception>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='power'/>
       is null.
    </exception>
</doc>
<doc name="M:PeterO.Numbers.EInteger.Remainder(PeterO.Numbers.EInteger)">

            <summary>Finds the remainder that results when this instance is divided by the
      value of an arbitrary-precision integer. The remainder is the value that
      remains when the absolute value of this object is divided by the absolute
      value of the other object; the remainder has the same sign (positive or
      negative) as this object.
    </summary><param name='divisor'>The number to divide by.
    </param><returns>The remainder of the two numbers.
    </returns><exception cref='T:System.DivideByZeroException'>Attempted to divide by zero.
    </exception><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='divisor'/>
       is null.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EInteger.Remainder(System.Int32)">

            <summary>Finds the remainder that results when this instance is divided by the
      value of an arbitrary-precision integer. The remainder is the value that
      remains when the absolute value of this object is divided by the absolute
      value of the other object; the remainder has the same sign (positive or
      negative) as this object.
    </summary><param name='intValue'>The parameter
      <paramref name='intValue'/>
       is a 32-bit signed integer.
    </param><returns>The remainder of the two numbers.
    </returns><exception cref='T:System.DivideByZeroException'>Attempted to divide by zero.
    </exception><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='divisor'/>
       is null.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EInteger.ShiftLeft(System.Int32)">

            <summary>Returns an arbitrary-precision integer with the bits shifted to the left
      by a number of bits. A value of 1 doubles this value, a value of 2
      multiplies it by 4, a value of 3 by 8, a value of 4 by 16, and so on.
    </summary><param name='numberBits'>The number of bits to shift. Can be negative, in which case this is the
      same as shiftRight with the absolute value of this parameter.
    </param><returns>An arbitrary-precision integer.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EInteger.ShiftRight(System.Int32)">

            <summary>Returns an arbitrary-precision integer with the bits shifted to the
      right. For this operation, the arbitrary-precision integer is treated as a
      two's-complement form (see
      <see cref='T:PeterO.Numbers.EDecimal'>
         "Forms of numbers"
      </see>
       ). Thus, for negative values, the arbitrary-precision integer is
      sign-extended.
    </summary><param name='numberBits'>Number of bits to shift right.
    </param><returns>An arbitrary-precision integer.
    </returns>

</doc>
<doc name="P:PeterO.Numbers.EInteger.Sign">

            <summary>Gets the sign of this object's value.
    </summary><value>The sign of this object' s value.
    </value>

</doc>
<doc name="M:PeterO.Numbers.EInteger.Sqrt">

            <summary>Finds the square root of this instance's value, rounded down.
    </summary><returns>The square root of this object's value. Returns 0 if this value is 0 or
      less.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EInteger.SqrtRem">

            <summary>Calculates the square root and the remainder.
    </summary><returns>An array of two arbitrary-precision integers: the first integer is the
      square root, and the second is the difference between this value and the
      square of the first integer. Returns two zeros if this value is 0 or less,
      or one and zero if this value equals 1.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EInteger.Subtract(PeterO.Numbers.EInteger)">

            <summary>Subtracts an arbitrary-precision integer from this arbitrary-precision
      integer.
    </summary><param name='subtrahend'>Another arbitrary-precision integer.
    </param><returns>The difference of the two objects.
    </returns><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='subtrahend'/>
       is null.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EInteger.Subtract(System.Int32)">

            <summary>Subtracts an arbitrary-precision integer from this arbitrary-precision
      integer.
    </summary><param name='intValue'>The parameter
      <paramref name='intValue'/>
       is a 32-bit signed integer.
    </param><returns>The difference of the two objects.
    </returns><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='subtrahend'/>
       is null.
    </exception>

</doc>
<doc name="P:PeterO.Numbers.EInteger.Ten">

            <summary>Gets the number 10 as an arbitrary-precision integer.
    </summary><value>The number 10 as an arbitrary-precision integer.
    </value>

</doc>
<doc name="M:PeterO.Numbers.EInteger.ToByteChecked">

            <summary>Converts this number's value to a byte (from 0 to 255) if it can fit in a
      byte (from 0 to 255).
    </summary><returns>This number's value as a byte (from 0 to 255).
    </returns><exception cref='T:System.OverflowException'>This value is less than 0 or greater than 255.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EInteger.ToByteUnchecked">

            <summary>Converts this number to a byte (from 0 to 255), returning the
      least-significant bits of this number's two's-complement form.
    </summary><returns>This number, converted to a byte (from 0 to 255).
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EInteger.ToBytes(System.Boolean)">

            <summary>Returns a byte array of this integer's value. The byte
            array will take the number's two' s-complement form (see
            <see cref='T:PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ),
            using the fewest bytes necessary to store its value unambiguously.
            If this value is negative, the bits that appear beyond the most
            significant bit of the number will be all ones. The resulting byte
            array can be passed to the <c>FromBytes()</c> method (with the same
            byte order) to reconstruct this integer's value.</summary><param name='littleEndian'>Either <c>true</c> or <c>false</c>
            .</param><returns>A byte array. If this value is 0, returns a byte array
            with the single element 0.</returns>

</doc>
<doc name="M:PeterO.Numbers.EInteger.ToInt16Checked">

            <summary>Converts this number's value to a 16-bit signed integer if it can fit in
      a 16-bit signed integer.
    </summary><returns>This number's value as a 16-bit signed integer.
    </returns><exception cref='T:System.OverflowException'>This value is less than -32768 or greater than 32767.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EInteger.ToInt16Unchecked">

            <summary>Converts this number to a 16-bit signed integer, returning the
      least-significant bits of this number's two's-complement form.
    </summary><returns>This number, converted to a 16-bit signed integer.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EInteger.ToInt32Checked">

            <summary>Converts this object's value to a 32-bit signed integer, throwing an
      exception if it can't fit.
    </summary><returns>A 32-bit signed integer.
    </returns><exception cref=' T:System.OverflowException'>This object' s value is too big to fit a 32-bit signed integer.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EInteger.ToInt32Unchecked">

            <summary>Converts this object's value to a 32-bit signed integer. If the value
      can't fit in a 32-bit integer, returns the lower 32 bits of this object's
      two' s-complement form (see
      <see cref='T:PeterO.Numbers.EDecimal'>
         "Forms of numbers"
      </see>
       ) (in which case the return value might have a different sign than this
      object's value).
    </summary><returns>A 32-bit signed integer.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EInteger.ToInt64Checked">

            <summary>Converts this object's value to a 64-bit signed integer, throwing an
      exception if it can't fit.
    </summary><returns>A 64-bit signed integer.
    </returns><exception cref=' T:System.OverflowException'>This object' s value is too big to fit a 64-bit signed integer.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EInteger.ToInt64Unchecked">

            <summary>Converts this object's value to a 64-bit signed integer. If the value
      can't fit in a 64-bit integer, returns the lower 64 bits of this object's
      two' s-complement form (see
      <see cref='T:PeterO.Numbers.EDecimal'>
         "Forms of numbers"
      </see>
       ) (in which case the return value might have a different sign than this
      object's value).
    </summary><returns>A 64-bit signed integer.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EInteger.ToRadixString(System.Int32)">

            <summary>Generates a string representing the value of this object, in the given
      radix.
    </summary><param name='radix'>A radix from 2 through 36. For example, to generate a hexadecimal
      (base-16) string, specify 16. To generate a decimal (base-10) string,
      specify 10.
    </param><returns>A string representing the value of this object. If this value is 0,
      returns "0". If negative, the string will begin with a minus sign ("-",
      U+002D). Depending on the radix, the string will use the basic digits 0 to
      9 (U+0030 to U+0039) and then the basic letters A to Z (U+0041 to U+005A).
      For example, 0-9 in radix 10, and 0-9, then A-F in radix 16.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EInteger.ToSByteChecked">

            <summary>Converts this number's value to an 8-bit signed integer if it can fit in
      an 8-bit signed integer.
    </summary><returns>This number's value as an 8-bit signed integer.
    </returns><exception cref='T:System.OverflowException'>This value is less than -128 or greater than 127.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EInteger.ToSByteUnchecked">

            <summary>Converts this number to an 8-bit signed integer, returning the
      least-significant bits of this number's two's-complement form.
    </summary><returns>This number, converted to an 8-bit signed integer.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EInteger.ToString">

            <summary>Converts this object to a text string in base 10.
    </summary><returns>A string representation of this object. If negative, the string will
      begin with a minus sign ("-", U+002D). The string will use the basic
      digits 0 to 9 (U+0030 to U+0039).
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EInteger.ToUInt16Checked">

            <summary>Converts this number's value to a 16-bit unsigned integer if it can fit
      in a 16-bit unsigned integer.
    </summary><returns>This number's value as a 16-bit unsigned integer.
    </returns><exception cref='T:System.OverflowException'>This value is less than 0 or greater than 65535.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EInteger.ToUInt16Unchecked">

            <summary>Converts this number to a 16-bit unsigned integer, returning the
      least-significant bits of this number's two's-complement form.
    </summary><returns>This number, converted to a 16-bit unsigned integer.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EInteger.ToUInt32Checked">

            <summary>Converts this number's value to a 32-bit signed integer if it can fit in
      a 32-bit signed integer.
    </summary><returns>This number's value as a 32-bit signed integer.
    </returns><exception cref='T:System.OverflowException'>This value is less than 0 or greater than 4294967295.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EInteger.ToUInt32Unchecked">

            <summary>Converts this number to a 32-bit signed integer, returning the
      least-significant bits of this number's two's-complement form.
    </summary><returns>This number, converted to a 32-bit signed integer.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EInteger.ToUInt64Checked">

            <summary>Converts this number's value to a 64-bit signed integer if it can fit in
      a 64-bit signed integer.
    </summary><returns>This number's value as a 64-bit signed integer.
    </returns><exception cref='T:System.OverflowException'>This value is outside the range of a 64-bit signed integer.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EInteger.ToUInt64Unchecked">

            <summary>Converts this number to a 64-bit signed integer, returning the
      least-significant bits of this number's two' s-complement form.
    </summary><returns>This number, converted to a 64-bit signed integer.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EInteger.Xor(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">

            <summary>Finds the exclusive "or" of two arbitrary-precision integer objects.
      <para>Each arbitrary-precision integer is treated as a two's-complement form
        (see
        <see cref='T:PeterO.Numbers.EDecimal'>
           "Forms of numbers"
        </see>
         ) for the purposes of this operator.
      </para>
    </summary><param name='a'>The first arbitrary-precision integer.
    </param><param name='b'>The second arbitrary-precision integer.
    </param><returns>An arbitrary-precision integer in which each bit is set if it's set in
      one input integer but not the other.
    </returns><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='a'/>
       or
      <paramref name='b'/>
       is null.
    </exception>

</doc>
<doc name="P:PeterO.Numbers.EInteger.Zero">

            <summary>Gets the number zero as an arbitrary-precision integer.
    </summary><value>The number zero as an arbitrary-precision integer.
    </value>

</doc>
<doc name="M:PeterO.Numbers.EInteger.op_Addition(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">

            <summary>Adds two arbitrary-precision integer objects and returns the result.
    </summary><param name='bthis'>The first operand.
    </param><param name='augend'>The second operand.
    </param><returns>The sum of the two objects.
    </returns><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='bthis'/>
       is null.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EInteger.op_BitwiseAnd(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">

            <summary>Does an AND operation between two arbitrary-precision integer values.
    </summary><param name='thisValue'>The first operand.
    </param><param name='otherValue'>The second operand.
    </param><returns>The result of the operation.
    </returns><exception cref='T:System.ArgumentNullException'>The parameter "a" or "b" is null.
    </exception><remarks>
       Each arbitrary-precision integer is treated as a two's-complement form
      (see
      <see cref='T:PeterO.Numbers.EDecimal'>
         "Forms of numbers"
      </see>
       ) for the purposes of this operator.
    </remarks>

</doc>
<doc name="M:PeterO.Numbers.EInteger.op_BitwiseOr(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">

            <summary>Does an OR operation between two arbitrary-precision integer instances.
    </summary><param name='thisValue'>An arbitrary-precision integer.
    </param><param name='otherValue'>Another arbitrary-precision integer.
    </param><returns>The result of the operation.
    </returns><exception cref='T:System.ArgumentNullException'>The parameter "first" or "second" is null.
    </exception><remarks>
       Each arbitrary-precision integer is treated as a two's-complement form
      (see
      <see cref='T:PeterO.Numbers.EDecimal'>
         "Forms of numbers"
      </see>
       ) for the purposes of this operator.
    </remarks>

</doc>
<doc name="M:PeterO.Numbers.EInteger.op_Division(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">

            <summary>Divides an arbitrary-precision integer by the value of an
      arbitrary-precision integer object.
    </summary><param name='dividend'>The number that will be divided by the divisor.
    </param><param name='divisor'>The number to divide by.
    </param><returns>The quotient of the two objects.
    </returns><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='dividend'/>
       is null.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EInteger.op_ExclusiveOr(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">

            <summary>Finds the exclusive "or" of two arbitrary-precision integer objects.
      <para>Each arbitrary-precision integer is treated as a two's-complement form
        (see
        <see cref='T:PeterO.Numbers.EDecimal'>
           "Forms of numbers"
        </see>
         ) for the purposes of this operator.
      </para>
    </summary><param name='a'>The first arbitrary-precision integer.
    </param><param name='b'>The second arbitrary-precision integer.
    </param><returns>An arbitrary-precision integer in which each bit is set if it's set in
      one input integer but not the other.
    </returns><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='a'/>
       or
      <paramref name='b'/>
       is null.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EInteger.op_Explicit(PeterO.Numbers.EInteger)~System.Byte">

            <summary>Converts an arbitrary-precision integer to a byte (from 0 to 255) if it
      can fit in a byte (from 0 to 255).
    </summary><param name='input'>The number to convert as an arbitrary-precision integer.
    </param><returns>The value of
      <paramref name='input'/>
       as a byte (from 0 to 255).
    </returns><exception cref='T:System.OverflowException'>The parameter
      <paramref name='input'/>
       is less than 0 or greater than 255.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EInteger.op_Explicit(PeterO.Numbers.EInteger)~System.Int16">

            <summary>Converts an arbitrary-precision integer to a 16-bit signed integer if it
      can fit in a 16-bit signed integer.
    </summary><param name='input'>The number to convert as an arbitrary-precision integer.
    </param><returns>The value of
      <paramref name='input'/>
       as a 16-bit signed integer.
    </returns><exception cref='T:System.OverflowException'>The parameter
      <paramref name='input'/>
       is less than -32768 or greater than 32767.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EInteger.op_Explicit(PeterO.Numbers.EInteger)~System.Int32">

            <summary>Converts an arbitrary-precision integer to a 32-bit signed integer if it
      can fit in a 32-bit signed integer.
    </summary><param name='input'>The number to convert as an arbitrary-precision integer.
    </param><returns>The value of
      <paramref name='input'/>
       as a 32-bit signed integer.
    </returns><exception cref='T:System.OverflowException'>The parameter
      <paramref name='input'/>
       is less than -2147483648 or greater than 2147483647.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EInteger.op_Explicit(PeterO.Numbers.EInteger)~System.Int64">

            <summary>Converts an arbitrary-precision integer to a 64-bit signed integer if it
      can fit in a 64-bit signed integer.
    </summary><param name='input'>The number to convert as an arbitrary-precision integer.
    </param><returns>The value of
      <paramref name='input'/>
       as a 64-bit signed integer.
    </returns><exception cref='T:System.OverflowException'>The parameter
      <paramref name='input'/>
       is less than -9223372036854775808 or greater than 9223372036854775807.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EInteger.op_Explicit(PeterO.Numbers.EInteger)~System.SByte">

            <summary>Converts an arbitrary-precision integer to an 8-bit signed integer if it
      can fit in an 8-bit signed integer.
    </summary><param name='input'>The number to convert as an arbitrary-precision integer.
    </param><returns>The value of
      <paramref name='input'/>
       as an 8-bit signed integer.
    </returns><exception cref='T:System.OverflowException'>The parameter
      <paramref name='input'/>
       is less than -128 or greater than 127.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EInteger.op_Explicit(PeterO.Numbers.EInteger)~System.UInt16">

            <summary>Converts an arbitrary-precision integer to a 16-bit unsigned integer if
      it can fit in a 16-bit unsigned integer.
    </summary><param name='input'>The number to convert as an arbitrary-precision integer.
    </param><returns>The value of
      <paramref name='input'/>
       as a 16-bit unsigned integer.
    </returns><exception cref='T:System.OverflowException'>The parameter
      <paramref name='input'/>
       is less than 0 or greater than 65535.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EInteger.op_Explicit(PeterO.Numbers.EInteger)~System.UInt32">

            <summary>Converts an arbitrary-precision integer to a 32-bit signed integer if it
      can fit in a 32-bit signed integer.
    </summary><param name='input'>The number to convert as an arbitrary-precision integer.
    </param><returns>The value of
      <paramref name='input'/>
       as a 32-bit signed integer.
    </returns><exception cref='T:System.OverflowException'>The parameter
      <paramref name='input'/>
       is less than 0 or greater than 4294967295.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EInteger.op_Explicit(PeterO.Numbers.EInteger)~System.UInt64">

            <summary>Converts an arbitrary-precision integer to a 64-bit unsigned integer if
      it can fit in a 64-bit unsigned integer.
    </summary><param name='input'>The number to convert as an arbitrary-precision integer.
    </param><returns>The value of
      <paramref name='input'/>
       as a 64-bit unsigned integer.
    </returns><exception cref='T:System.OverflowException'>The parameter
      <paramref name='input'/>
       is less than 0 or greater than 18446744073709551615.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EInteger.op_GreaterThan(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">

            <summary>Determines whether an arbitrary-precision integer is greater than another
      arbitrary-precision integer.
    </summary><param name='thisValue'>The first arbitrary-precision integer.
    </param><param name='otherValue'>The second arbitrary-precision integer.
    </param><returns><c>true</c>
       if
      <paramref name='thisValue'/>
       is greater than
      <paramref name='otherValue'/>
       ; otherwise, <c>false</c>
       .
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EInteger.op_GreaterThanOrEqual(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">

            <summary>Determines whether an arbitrary-precision integer value is greater than
      another arbitrary-precision integer.
    </summary><param name='thisValue'>The first arbitrary-precision integer.
    </param><param name='otherValue'>The second arbitrary-precision integer.
    </param><returns><c>true</c>
       if
      <paramref name='thisValue'/>
       is at least
      <paramref name='otherValue'/>
       ; otherwise, <c>false</c>
       .
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EInteger.op_Implicit(System.Byte)~PeterO.Numbers.EInteger">

            <summary>Converts a byte (from 0 to 255) to an arbitrary-precision integer.
    </summary><param name='inputByte'>The number to convert as a byte (from 0 to 255).
    </param><returns>The value of
      <paramref name='inputByte'/>
       as an arbitrary-precision integer.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EInteger.op_Implicit(System.Int16)~PeterO.Numbers.EInteger">

            <summary>Converts a 16-bit signed integer to an arbitrary-precision integer.
    </summary><param name='inputInt16'>The number to convert as a 16-bit signed integer.
    </param><returns>The value of
      <paramref name='inputInt16'/>
       as an arbitrary-precision integer.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EInteger.op_Implicit(System.Int32)~PeterO.Numbers.EInteger">

            <summary>Converts a 32-bit signed integer to an arbitrary-precision integer.
    </summary><param name='inputInt32'>The number to convert as a 32-bit signed integer.
    </param><returns>The value of
      <paramref name='inputInt32'/>
       as an arbitrary-precision integer.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EInteger.op_Implicit(System.Int64)~PeterO.Numbers.EInteger">

            <summary>Converts a 64-bit signed integer to an arbitrary-precision integer.
    </summary><param name='inputInt64'>The number to convert as a 64-bit signed integer.
    </param><returns>The value of
      <paramref name='inputInt64'/>
       as an arbitrary-precision integer.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EInteger.op_Implicit(System.SByte)~PeterO.Numbers.EInteger">

            <summary>Converts an 8-bit signed integer to an arbitrary-precision integer.
    </summary><param name='inputSByte'>The number to convert as an 8-bit signed integer.
    </param><returns>The value of
      <paramref name='inputSByte'/>
       as an arbitrary-precision integer.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EInteger.op_Implicit(System.UInt16)~PeterO.Numbers.EInteger">

            <summary>Converts a 16-bit unsigned integer to an arbitrary-precision integer.
    </summary><param name='inputUInt16'>The number to convert as a 16-bit unsigned integer.
    </param><returns>The value of
      <paramref name='inputUInt16'/>
       as an arbitrary-precision integer.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EInteger.op_Implicit(System.UInt32)~PeterO.Numbers.EInteger">

            <summary>Converts a 32-bit signed integer to an arbitrary-precision integer.
    </summary><param name='inputUInt32'>The number to convert as a 32-bit signed integer.
    </param><returns>The value of
      <paramref name='inputUInt32'/>
       as an arbitrary-precision integer.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EInteger.op_Implicit(System.UInt64)~PeterO.Numbers.EInteger">

            <summary>Converts a 64-bit unsigned integer to an arbitrary-precision integer.
    </summary><param name='inputUInt64'>The number to convert as a 64-bit unsigned integer.
    </param><returns>The value of
      <paramref name='inputUInt64'/>
       as an arbitrary-precision integer.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EInteger.op_LeftShift(PeterO.Numbers.EInteger,System.Int32)">

            <summary>Returns an arbitrary-precision integer with the bits shifted to the left
      by a number of bits. A value of 1 doubles this value, a value of 2
      multiplies it by 4, a value of 3 by 8, a value of 4 by 16, and so on.
    </summary><param name='bthis'>The arbitrary-precision integer to shift left.
    </param><param name='bitCount'>The number of bits to shift. Can be negative, in which case this is the
      same as shiftRight with the absolute value of this parameter.
    </param><returns>An arbitrary-precision integer.
    </returns><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='bthis'/>
       is null.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EInteger.op_LessThan(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">

            <summary>Determines whether an arbitrary-precision integer is less than another
      arbitrary-precision integer.
    </summary><param name='thisValue'>The first arbitrary-precision integer.
    </param><param name='otherValue'>The second arbitrary-precision integer.
    </param><returns><c>true</c>
       if
      <paramref name='thisValue'/>
       is less than
      <paramref name='otherValue'/>
       ; otherwise, <c>false</c>
       .
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EInteger.op_LessThanOrEqual(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">

            <summary>Determines whether an arbitrary-precision integer is up to another
      arbitrary-precision integer.
    </summary><param name='thisValue'>The first arbitrary-precision integer.
    </param><param name='otherValue'>The second arbitrary-precision integer.
    </param><returns><c>true</c>
       if
      <paramref name='thisValue'/>
       is up to
      <paramref name='otherValue'/>
       ; otherwise, <c>false</c>
       .
    </returns>

</doc>
<doc name="M:PeterO.Numbers.EInteger.op_Modulus(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">

            <summary>Finds the remainder that results when an arbitrary-precision integer is
      divided by the value of another arbitrary-precision integer.
    </summary><param name='dividend'>The first operand.
    </param><param name='divisor'>The number to divide by.
    </param><returns>The remainder of the two numbers.
    </returns><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='dividend'/>
       is null.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EInteger.op_Multiply(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">

            <summary>Multiplies an arbitrary-precision integer by the value of an
      arbitrary-precision integer.
    </summary><param name='operand1'>The first operand.
    </param><param name='operand2'>The second operand.
    </param><returns>The product of the two numbers.
    </returns><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='operand1'/>
       is null.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EInteger.op_OnesComplement(PeterO.Numbers.EInteger)">

            <summary>Returns an arbitrary-precision integer with every bit flipped.
    </summary><param name='thisValue'>The operand as an arbitrary-precision integer.
    </param><returns>An arbitrary-precision integer.
    </returns><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='thisValue'/>
       is null.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EInteger.op_RightShift(PeterO.Numbers.EInteger,System.Int32)">

            <summary>Shifts the bits of an arbitrary-precision integer to the right.
    </summary><param name='bthis'>Another arbitrary-precision integer.
    </param><param name='smallValue'>The parameter
      <paramref name='smallValue'/>
       is a 32-bit signed integer.
    </param><returns>An arbitrary-precision integer.
    </returns><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='bthis'/>
       is null.
    </exception><remarks>
       For this operation, the arbitrary-precision integer is treated as a
      two's-complement form (see
      <see cref='T:PeterO.Numbers.EDecimal'>
         "Forms of numbers"
      </see>
       ). Thus, for negative values, the arbitrary-precision integer is
      sign-extended.
    </remarks>

</doc>
<doc name="M:PeterO.Numbers.EInteger.op_Subtraction(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">

            <summary>Subtracts two arbitrary-precision integer values.
    </summary><param name='bthis'>An arbitrary-precision integer.
    </param><param name='subtrahend'>Another arbitrary-precision integer.
    </param><returns>The difference of the two objects.
    </returns><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='bthis'/>
       is null.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.EInteger.op_UnaryNegation(PeterO.Numbers.EInteger)">

            <summary>Negates an arbitrary-precision integer.
    </summary><param name='bigValue'>An arbitrary-precision integer to negate.
    </param><returns>An arbitrary-precision integer.
    </returns><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='bigValue'/>
       is null.
    </exception>

</doc>
<doc name="T:PeterO.Numbers.ERational">

            <summary>Represents an arbitrary-precision rational number. This class can't be
      inherited. (The "E" stands for "extended", meaning that instances of this
      class can be values other than numbers proper, such as infinity and
      not-a-number.)
      <para><b>Thread safety:</b>
         Instances of this class are immutable, so they are inherently safe for
        use by multiple threads. Multiple instances of this object with the same
        properties are interchangeable, so they should not be compared using the
        "==" operator (which might only check if each side of the operator is
        the same instance).
      </para>
    </summary>

</doc>
<doc name="M:PeterO.Numbers.ERational.#ctor(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">

            <summary>Initializes a new instance of the <see cref='T:PeterO.Numbers.ERational'/> class.
    </summary><param name='numerator'>The numerator.
    </param><param name='denominator'>The denominator.
    </param><exception cref='T:System.ArgumentException'>The denominator is zero.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.ERational.Abs">

            <summary>Returns the absolute value of this rational number, that is, a number
      with the same value as this one but as a nonnegative number.
    </summary><returns>An arbitrary-precision binary rational number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.ERational.Add(PeterO.Numbers.ERational)">
<summary>Adds two rational numbers.
    </summary>
    <param name='otherValue'>Another arbitrary-precision rational number.
    </param>
    <returns>The sum of the two numbers. Returns not-a-number (NaN) if either operand
      is NaN.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter &#x22;otherValue&#x22; is null.
    </exception>
</doc>
<doc name="M:PeterO.Numbers.ERational.CompareTo(PeterO.Numbers.ERational)">

            <summary>Compares an arbitrary-precision rational number with this instance.
    </summary><param name='other'>An arbitrary-precision rational number.
    </param><returns>Zero if the values are equal; a negative number if this instance is less,
      or a positive number if this instance is greater.
    </returns><exception cref='T:System.ArgumentException'>Doesn't satisfy this.IsFinite; doesn't satisfy other.IsFinite.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.ERational.CompareToBinary(PeterO.Numbers.EFloat)">

            <summary>Compares an arbitrary-precision binary float with this instance.
    </summary><param name='other'>An arbitrary-precision binary float.
    </param><returns>Zero if the values are equal; a negative number if this instance is less,
      or a positive number if this instance is greater.
    </returns><exception cref='T:System.ArgumentException'>Doesn't satisfy this.IsFinite; doesn't satisfy other.IsFinite.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.ERational.CompareToDecimal(PeterO.Numbers.EDecimal)">

            <summary>Compares an arbitrary-precision decimal number with this instance.
    </summary><param name='other'>An arbitrary-precision decimal number.
    </param><returns>Zero if the values are equal; a negative number if this instance is less,
      or a positive number if this instance is greater.
    </returns><exception cref='T:System.ArgumentException'>Doesn't satisfy this.IsFinite; doesn't satisfy other.IsFinite.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.ERational.CompareToTotal(PeterO.Numbers.ERational)">

            <summary>Compares the values of this object and another object, imposing a total
      ordering on all possible values. In this method:
      <list>
        <item>For objects with the same value, the one with the higher denominator
          has a greater "absolute value".
        </item>
        <item>Negative zero is less than positive zero.
        </item>
        <item>Quiet NaN has a higher "absolute value" than signaling NaN. If both
          objects are quiet NaN or both are signaling NaN, the one with the
          higher diagnostic information has a greater "absolute value".
        </item>
        <item>NaN has a higher "absolute value" than infinity.
        </item>
        <item>Infinity has a higher "absolute value" than any finite number.
        </item>
        <item>Negative numbers are less than positive numbers.
        </item>
      </list>
    </summary><param name='other'>An arbitrary-precision rational number to compare with this one.
    </param><returns>The number 0 if both objects have the same value, or -1 if this object is
      less than the other value, or 1 if this object is greater.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.ERational.CompareToTotalMagnitude(PeterO.Numbers.ERational)">

            <summary>Compares the absolute values of this object and another object, imposing
      a total ordering on all possible values (ignoring their signs). In this
      method:
      <list>
        <item>For objects with the same value, the one with the higher denominator
          has a greater "absolute value".
        </item>
        <item>Negative zero and positive zero are considered equal.
        </item>
        <item>Quiet NaN has a higher "absolute value" than signaling NaN. If both
          objects are quiet NaN or both are signaling NaN, the one with the
          higher diagnostic information has a greater "absolute value".
        </item>
        <item>NaN has a higher "absolute value" than infinity.
        </item>
        <item>Infinity has a higher "absolute value" than any finite number.
        </item>
      </list>
    </summary><param name='other'>An arbitrary-precision rational number to compare with this one.
    </param><returns>The number 0 if both objects have the same value, or -1 if this object is
      less than the other value, or 1 if this object is greater.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.ERational.CopySign(PeterO.Numbers.ERational)">
<summary>Returns a number with the same value as this one, but copying the sign
      (positive or negative) of another number.
    </summary>
    <param name='other'>A number whose sign will be copied.
    </param>
    <returns>An arbitrary-precision rational number.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter &#x22;other&#x22; is null.
    </exception>
</doc>
<doc name="M:PeterO.Numbers.ERational.Create(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">

            <summary>Creates a rational number with the given numerator and denominator.
    </summary><param name='numerator'>The numerator.
    </param><param name='denominator'>The denominator.
    </param><returns>An arbitrary-precision binary rational number.
    </returns><exception cref='T:System.ArgumentException'>The denominator is zero.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.ERational.Create(System.Int32,System.Int32)">

            <summary>Creates a rational number with the given numerator and denominator.
    </summary><param name='numeratorSmall'>The numerator.
    </param><param name='denominatorSmall'>The denominator.
    </param><returns>An arbitrary-precision binary rational number.
    </returns><exception cref='T:System.ArgumentException'>The denominator is zero.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.ERational.CreateNaN(PeterO.Numbers.EInteger)">
<summary>Creates a not-a-number arbitrary-precision rational number.
    </summary>
    <param name='diag'>A number to use as diagnostic information associated with this object. If
      none is needed, should be zero.
    </param>
    <returns>An arbitrary-precision rational number.
    </returns>
    <exception cref='T:System.ArgumentException'>The parameter &#x22;diag&#x22; is less than 0.
    </exception>
</doc>
<doc name="M:PeterO.Numbers.ERational.CreateNaN(PeterO.Numbers.EInteger,System.Boolean,System.Boolean)">
<summary>Creates a not-a-number arbitrary-precision rational number.
    </summary>
    <param name='diag'>A number to use as diagnostic information associated with this object. If
      none is needed, should be zero.
    </param>
    <param name='signaling'>Whether the return value will be signaling (true) or quiet (false).
    </param>
    <param name='negative'>Whether the return value is negative.
    </param>
    <returns>An arbitrary-precision rational number.
    </returns>
    <exception cref='T:System.ArgumentException'>The parameter &#x22;diag&#x22; is less than 0.
    </exception>
    <exception cref='T:System.ArgumentNullException'>The parameter &#x22;diag&#x22; is null.
    </exception>
</doc>
<doc name="P:PeterO.Numbers.ERational.Denominator">

            <summary>Gets this object's denominator.
    </summary><value>This object' s denominator.
    </value>

</doc>
<doc name="M:PeterO.Numbers.ERational.Divide(PeterO.Numbers.ERational)">
<summary>Divides this instance by the value of an arbitrary-precision rational
      number object.
    </summary>
    <param name='otherValue'>An arbitrary-precision rational number.
    </param>
    <returns>The quotient of the two objects.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter &#x22;otherValue&#x22; is null.
    </exception>
</doc>
<doc name="M:PeterO.Numbers.ERational.Equals(PeterO.Numbers.ERational)">

            <summary>Determines whether this object's numerator, denominator, and properties
      are equal to those of another object. Not-a-number values are considered
      equal if the rest of their properties are equal.
    </summary><param name='other'>An arbitrary-precision rational number to compare to.
    </param><returns>Either
      <c>true</c>
       or
      <c>false</c>
       .
    </returns>

</doc>
<doc name="M:PeterO.Numbers.ERational.Equals(System.Object)">

            <summary>Determines whether this object's numerator, denominator, and properties
      are equal to those of another object and that other object is an
      arbitrary-precision rational number. Not-a-number values are considered
      equal if the rest of their properties are equal.
    </summary><param name='obj'>The parameter
      <paramref name='obj'/>
       is an arbitrary object.
    </param><returns><c>true</c>
       if the objects are equal; otherwise, <c>false</c>
       .
    </returns>

</doc>
<doc name="M:PeterO.Numbers.ERational.FromByte(System.Byte)">

            <summary>Converts a byte (from 0 to 255) to an arbitrary-precision rational
      number.
    </summary><param name='inputByte'>The number to convert as a byte (from 0 to 255).
    </param><returns>This number's value as an arbitrary-precision rational number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.ERational.FromDecimal(System.Decimal)">

            <summary>Converts a
      <c>decimal</c>
       under the Common Language Infrastructure (usually a .NET Framework
      decimal) to a rational number.
    </summary><param name='eint'>The number to convert as a
      <c>decimal</c>
       under the Common Language Infrastructure (usually a .NET Framework
      decimal).
    </param><returns>An arbitrary-precision rational number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.ERational.FromDouble(System.Double)">
<summary>Converts a 64-bit floating-point number to a rational number. This method
      computes the exact value of the floating point number, not an
      approximation, as is often the case by converting the number to a string.
    </summary>
    <param name='flt'>The parameter
      <paramref name='flt'/>
       is a 64-bit floating-point number.
    </param>
    <returns>A rational number with the same value as &#x22;flt&#x22;.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.FromEDecimal(PeterO.Numbers.EDecimal)">
<summary>Converts an arbitrary-precision decimal number to a rational number.
    </summary>
    <param name='ef'>The number to convert as an arbitrary-precision decimal number.
    </param>
    <returns>An arbitrary-precision rational number.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter &#x22;ef&#x22; is null.
    </exception>
</doc>
<doc name="M:PeterO.Numbers.ERational.FromEFloat(PeterO.Numbers.EFloat)">
<summary>Converts an arbitrary-precision binary float to a rational number.
    </summary>
    <param name='ef'>The number to convert as an arbitrary-precision binary float.
    </param>
    <returns>An arbitrary-precision rational number.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter &#x22;ef&#x22; is null.
    </exception>
</doc>
<doc name="M:PeterO.Numbers.ERational.FromEInteger(PeterO.Numbers.EInteger)">

            <summary>Converts an arbitrary-precision integer to a rational number.
    </summary><param name='bigint'>The number to convert as an arbitrary-precision integer.
    </param><returns>The exact value of the integer as a rational number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.ERational.FromExtendedDecimal(PeterO.Numbers.EDecimal)">

            <summary>Converts an arbitrary-precision decimal number to a rational number.
    </summary><param name='ef'>The number to convert as an arbitrary-precision decimal number.
    </param><returns>An arbitrary-precision rational number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.ERational.FromExtendedFloat(PeterO.Numbers.EFloat)">

            <summary>Converts an arbitrary-precision binary float to a rational number.
    </summary><param name='ef'>The number to convert as an arbitrary-precision binary float.
    </param><returns>An arbitrary-precision rational number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.ERational.FromInt16(System.Int16)">

            <summary>Converts a 16-bit signed integer to an arbitrary-precision rational
      number.
    </summary><param name='inputInt16'>The number to convert as a 16-bit signed integer.
    </param><returns>This number's value as an arbitrary-precision rational number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.ERational.FromInt32(System.Int32)">

            <summary>Converts a 32-bit signed integer to an arbitrary-precision rational
      number.
    </summary><param name='inputInt32'>The number to convert as a 32-bit signed integer.
    </param><returns>This number's value as an arbitrary-precision rational number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.ERational.FromInt64(System.Int64)">

            <summary>Converts a 64-bit signed integer to an arbitrary-precision rational
      number.
    </summary><param name='inputInt64'>The number to convert as a 64-bit signed integer.
    </param><returns>This number's value as an arbitrary-precision rational number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.ERational.FromSByte(System.SByte)">

            <summary>Converts an 8-bit signed integer to an arbitrary-precision rational
      number.
    </summary><param name='inputSByte'>The number to convert as an 8-bit signed integer.
    </param><returns>This number's value as an arbitrary-precision rational number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.ERational.FromSingle(System.Single)">
<summary>Converts a 32-bit binary floating-point number to a rational number. This
      method computes the exact value of the floating point number, not an
      approximation, as is often the case by converting the number to a string.
    </summary>
    <param name='flt'>The parameter
      <paramref name='flt'/>
       is a 32-bit binary floating-point number.
    </param>
    <returns>A rational number with the same value as &#x22;flt&#x22;.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.FromString(System.String)">
<summary>Creates a rational number from a text string that represents a number. See

      <c>FromString(String, int, int)</c>
       for more information.
    </summary>
    <param name='str'>A string that represents a number.
    </param>
    <returns>An arbitrary-precision rational number with the same value as the given
      string.
    </returns>
    <exception cref='T:System.FormatException'>The parameter &#x22;str&#x22; is not a correctly formatted number string.
    </exception>
</doc>
<doc name="M:PeterO.Numbers.ERational.FromString(System.String,System.Int32,System.Int32)">
<summary><para>Creates a rational number from a text string that represents a number.
      </para>
      <para>The format of the string generally consists of:
      </para>
      <list type=''>
        <item>An optional plus sign ("+" , U+002B) or minus sign ("-", U+002D) (if
          '-' , the value is negative.)
        </item>
        <item>The numerator in the form of one or more digits.
        </item>
        <item>Optionally, "/" followed by the denominator in the form of one or more
          digits. If a denominator is not given, it's equal to 1.
        </item>
      </list>
      <para>The string can also be "-INF", "-Infinity", "Infinity", "INF", quiet NaN
        ("NaN" /"-NaN") followed by any number of digits, or signaling NaN
        ("sNaN" /"-sNaN") followed by any number of digits, all in any
        combination of upper and lower case.
      </para>
      <para>All characters mentioned above are the corresponding characters in the
        Basic Latin range. In particular, the digits must be the basic digits 0
        to 9 (U+0030 to U+0039). The string is not allowed to contain white
        space characters, including spaces.
      </para>
    </summary>
    <param name='str'>A text string, a portion of which represents a number.
    </param>
    <param name='offset'>A zero-based index showing where the desired portion of
      <paramref name='str'/>
       begins.
    </param>
    <param name='length'>The length, in code units, of the desired portion of
      <paramref name='str'/>
       (but not more than
      <paramref name='str'/>
       's length).
    </param>
    <returns>An arbitrary-precision rational number.
    </returns>
    <exception cref='T:System.FormatException'>The parameter &#x22;str&#x22; is not a correctly formatted number string.
    </exception>
    <exception cref='T:System.ArgumentNullException'>The parameter &#x22;str&#x22; is null.
    </exception>
</doc>
<doc name="M:PeterO.Numbers.ERational.FromUInt16(System.UInt16)">

            <summary>Converts a 16-bit unsigned integer to an arbitrary-precision rational
      number.
    </summary><param name='inputUInt16'>The number to convert as a 16-bit unsigned integer.
    </param><returns>This number's value as an arbitrary-precision rational number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.ERational.FromUInt32(System.UInt32)">

            <summary>Converts a 32-bit signed integer to an arbitrary-precision rational
      number.
    </summary><param name='inputUInt32'>The number to convert as a 32-bit signed integer.
    </param><returns>This number's value as an arbitrary-precision rational number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.ERational.FromUInt64(System.UInt64)">

            <summary>Converts a 64-bit unsigned integer to an arbitrary-precision rational
      number.
    </summary><param name='inputUInt64'>The number to convert as a 64-bit unsigned integer.
    </param><returns>This number's value as an arbitrary-precision rational number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.ERational.GetHashCode">

            <summary>Returns the hash code for this instance. No application or process IDs
      are used in the hash code calculation.
    </summary><returns>A 32-bit signed integer.
    </returns>

</doc>
<doc name="P:PeterO.Numbers.ERational.IsFinite">

            <summary>Gets a value indicating whether this object is finite (not infinity or
      NaN).
    </summary><value><c>true</c>
       if this object is finite (not infinity or NaN); otherwise, <c>false</c>
       .
    </value>

</doc>
<doc name="M:PeterO.Numbers.ERational.IsInfinity">

            <summary>Gets a value indicating whether this object's value is infinity.
    </summary><returns><c>true</c>
       if this object's value is infinity; otherwise, <c>false</c>
       .
    </returns>

</doc>
<doc name="M:PeterO.Numbers.ERational.IsNaN">

            <summary>Returns whether this object is a not-a-number value.
    </summary><returns><c>true</c>
       if this object is a not-a-number value; otherwise, <c>false</c>
       .
    </returns>

</doc>
<doc name="P:PeterO.Numbers.ERational.IsNegative">

            <summary>Gets a value indicating whether this object's value is negative
      (including negative zero).
    </summary><value><c>true</c>
       if this object's value is negative (including negative zero); otherwise, <c>false</c>
       .
      <c>true</c>
       if this object's value is negative; otherwise, <c>false</c>
       .
    </value>

</doc>
<doc name="M:PeterO.Numbers.ERational.IsNegativeInfinity">

            <summary>Returns whether this object is negative infinity.
    </summary><returns><c>true</c>
       if this object is negative infinity; otherwise, <c>false</c>
       .
    </returns>

</doc>
<doc name="M:PeterO.Numbers.ERational.IsPositiveInfinity">

            <summary>Returns whether this object is positive infinity.
    </summary><returns><c>true</c>
       if this object is positive infinity; otherwise, <c>false</c>
       .
    </returns>

</doc>
<doc name="M:PeterO.Numbers.ERational.IsQuietNaN">

            <summary>Returns whether this object is a quiet not-a-number value.
    </summary><returns><c>true</c>
       if this object is a quiet not-a-number value; otherwise, <c>false</c>
       .
    </returns>

</doc>
<doc name="M:PeterO.Numbers.ERational.IsSignalingNaN">

            <summary>Returns whether this object is a signaling not-a-number value (which
      causes an error if the value is passed to any arithmetic operation in this
      class).
    </summary><returns><c>true</c>
       if this object is a signaling not-a-number value (which causes an error
      if the value is passed to any arithmetic operation in this class); otherwise, <c>false</c>
       .
    </returns>

</doc>
<doc name="P:PeterO.Numbers.ERational.IsZero">

            <summary>Gets a value indicating whether this object's value equals 0.
    </summary><value><c>true</c>
       if this object's value equals 0; otherwise, <c>false</c>
       .
      <c>true</c>
       if this object' s value equals 0; otherwise, .
      <c>false</c>
       .
    </value>

</doc>
<doc name="M:PeterO.Numbers.ERational.Multiply(PeterO.Numbers.ERational)">
<summary>Multiplies this instance by the value of an arbitrary-precision rational
      number.
    </summary>
    <param name='otherValue'>An arbitrary-precision rational number.
    </param>
    <returns>The product of the two numbers.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter &#x22;otherValue&#x22; is null.
    </exception>
</doc>
<doc name="F:PeterO.Numbers.ERational.NaN">

            <summary>A not-a-number value.
    </summary>

</doc>
<doc name="M:PeterO.Numbers.ERational.Negate">

            <summary>Returns a rational number with the same value as this one but with the
      sign reversed.
    </summary><returns>An arbitrary-precision binary rational number.
    </returns>

</doc>
<doc name="F:PeterO.Numbers.ERational.NegativeInfinity">

            <summary>Negative infinity, less than any other number.
    </summary>

</doc>
<doc name="F:PeterO.Numbers.ERational.NegativeZero">

            <summary>A rational number for negative zero.
    </summary>

</doc>
<doc name="P:PeterO.Numbers.ERational.Numerator">

            <summary>Gets this object's numerator.
    </summary><value>This object' s numerator. If this object is a not-a-number value, returns
      the diagnostic information (which will be negative if this object is
      negative).
    </value>

</doc>
<doc name="F:PeterO.Numbers.ERational.One">

            <summary>The rational number one.
    </summary>

</doc>
<doc name="F:PeterO.Numbers.ERational.PositiveInfinity">

            <summary>Positive infinity, greater than any other number.
    </summary>

</doc>
<doc name="M:PeterO.Numbers.ERational.Remainder(PeterO.Numbers.ERational)">
<summary>Finds the remainder that results when this instance is divided by the
      value of an arbitrary-precision rational number.
    </summary>
    <param name='otherValue'>An arbitrary-precision rational number.
    </param>
    <returns>The remainder of the two numbers.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter &#x22;otherValue&#x22; is null.
    </exception>
</doc>
<doc name="P:PeterO.Numbers.ERational.Sign">

            <summary>Gets the sign of this rational number.
    </summary><value>The sign of this rational number.
    </value>

</doc>
<doc name="F:PeterO.Numbers.ERational.SignalingNaN">

            <summary>A signaling not-a-number value.
    </summary>

</doc>
<doc name="M:PeterO.Numbers.ERational.Subtract(PeterO.Numbers.ERational)">
<summary>Subtracts an arbitrary-precision rational number from this instance.
    </summary>
    <param name='otherValue'>An arbitrary-precision rational number.
    </param>
    <returns>The difference of the two objects.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter &#x22;otherValue&#x22; is null.
    </exception>
</doc>
<doc name="F:PeterO.Numbers.ERational.Ten">

            <summary>The rational number ten.
    </summary>

</doc>
<doc name="M:PeterO.Numbers.ERational.ToByteChecked">

            <summary>Converts this number's value to a byte (from 0 to 255) if it can fit in a
      byte (from 0 to 255) after truncating to an integer.
    </summary><returns>This number's value, truncated to a byte (from 0 to 255).
    </returns><exception cref='T:System.OverflowException'>This value is infinity or not-a-number, or the truncated integer is less
      than 0 or greater than 255.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.ERational.ToByteIfExact">

            <summary>Converts this number's value to a byte (from 0 to 255) if it can fit in a
      byte (from 0 to 255) without rounding to a different numerical value.
    </summary><returns>This number's value as a byte (from 0 to 255).
    </returns><exception cref='T:System.ArithmeticException'>This value is infinity or not-a-number, is not an exact integer, or is
      less than 0 or greater than 255.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.ERational.ToByteUnchecked">

            <summary>Truncates this number's value to an integer and returns the
      least-significant bits of its two's-complement form as a byte (from 0 to
      255).
    </summary><returns>This number, converted to a byte (from 0 to 255). Returns 0 if this value
      is infinity or not-a-number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.ERational.ToDecimal">

            <summary>Converts this value to a
      <c>decimal</c>
       under the Common Language Infrastructure (usually a .NET Framework
      decimal). Currently, converts this value to the precision and range of a
      .NET Framework decimal.
    </summary><returns>A
      <c>decimal</c>
       under the Common Language Infrastructure (usually a .NET Framework
      decimal).
    </returns>

</doc>
<doc name="M:PeterO.Numbers.ERational.ToDouble">

            <summary>Converts this value to a 64-bit floating-point number. The half-even
      rounding mode is used.
    </summary><returns>The closest 64-bit floating-point number to this value. The return value
      can be positive infinity or negative infinity if this value exceeds the
      range of a 64-bit floating point number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.ERational.ToEDecimal">

            <summary>Converts this rational number to a decimal number.
    </summary><returns>The exact value of the rational number, or not-a-number (NaN) if the
      result can't be exact because it has a nonterminating decimal expansion.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.ERational.ToEDecimal(PeterO.Numbers.EContext)">

            <summary>Converts this rational number to a decimal number and rounds the result
      to the given precision.
    </summary><param name='ctx'>An arithmetic context object to control the precision, rounding, and
      exponent range of the result. If HasFlags of the context is true, will
      also store the flags resulting from the operation (the flags are in
      addition to the pre-existing flags). Can be null, in which case the
      precision is unlimited and no rounding is needed.
    </param><returns>The value of the rational number, rounded to the given precision. Returns
      not-a-number (NaN) if the context is null and the result can't be exact
      because it has a nonterminating decimal expansion.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.ERational.ToEDecimalExactIfPossible(PeterO.Numbers.EContext)">

            <summary>Converts this rational number to a decimal number, but if the result
      would have a nonterminating decimal expansion, rounds that result to the
      given precision.
    </summary><param name='ctx'>An arithmetic context object to control the precision, rounding, and
      exponent range of the result. This context will be used only if the exact
      result would have a nonterminating decimal expansion. If HasFlags of the
      context is true, will also store the flags resulting from the operation
      (the flags are in addition to the pre-existing flags). Can be null, in
      which case the precision is unlimited and no rounding is needed.
    </param><returns>The exact value of the rational number if possible; otherwise, the
      rounded version of the result if a context is given. Returns not-a-number
      (NaN) if the context is null and the result can't be exact because it has
      a nonterminating decimal expansion.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.ERational.ToEFloat">

            <summary>Converts this rational number to a binary float.
    </summary><returns>The exact value of the rational number, or not-a-number (NaN) if the
      result can't be exact because it has a nonterminating binary expansion.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.ERational.ToEFloat(PeterO.Numbers.EContext)">

            <summary>Converts this rational number to a binary float and rounds that result to
      the given precision.
    </summary><param name='ctx'>An arithmetic context object to control the precision, rounding, and
      exponent range of the result. If HasFlags of the context is true, will
      also store the flags resulting from the operation (the flags are in
      addition to the pre-existing flags). Can be null, in which case the
      precision is unlimited and no rounding is needed.
    </param><returns>The value of the rational number, rounded to the given precision. Returns
      not-a-number (NaN) if the context is null and the result can't be exact
      because it has a nonterminating binary expansion.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.ERational.ToEFloatExactIfPossible(PeterO.Numbers.EContext)">

            <summary>Converts this rational number to a binary float, but if the result would
      have a nonterminating binary expansion, rounds that result to the given
      precision.
    </summary><param name='ctx'>An arithmetic context object to control the precision, rounding, and
      exponent range of the result. This context will be used only if the exact
      result would have a nonterminating binary expansion. If HasFlags of the
      context is true, will also store the flags resulting from the operation
      (the flags are in addition to the pre-existing flags). Can be null, in
      which case the precision is unlimited and no rounding is needed.
    </param><returns>The exact value of the rational number if possible; otherwise, the
      rounded version of the result if a context is given. Returns not-a-number
      (NaN) if the context is null and the result can't be exact because it has
      a nonterminating binary expansion.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.ERational.ToEInteger">

            <summary>Converts this value to an arbitrary-precision integer. Any fractional
      part in this value will be discarded when converting to an
      arbitrary-precision integer.
    </summary><returns>An arbitrary-precision integer.
    </returns><exception cref='T:System.OverflowException'>This object's value is infinity or not-a-number (NaN).
    </exception>

</doc>
<doc name="M:PeterO.Numbers.ERational.ToEIntegerExact">

            <summary>Converts this value to an arbitrary-precision integer, checking whether
      the value is an exact integer.
    </summary><returns>An arbitrary-precision integer.
    </returns><exception cref='T:System.OverflowException'>This object's value is infinity or not-a-number (NaN).
    </exception>

</doc>
<doc name="M:PeterO.Numbers.ERational.ToEIntegerIfExact">

            <summary>Converts this value to an arbitrary-precision integer, checking whether
      the value is an exact integer.
    </summary><returns>An arbitrary-precision integer.
    </returns><exception cref='T:System.OverflowException'>This object's value is infinity or not-a-number (NaN).
    </exception>

</doc>
<doc name="M:PeterO.Numbers.ERational.ToExtendedDecimal">

            <summary>Converts this rational number to a decimal number.
    </summary><returns>The exact value of the rational number, or not-a-number (NaN) if the
      result can't be exact because it has a nonterminating decimal expansion.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.ERational.ToExtendedDecimal(PeterO.Numbers.EContext)">

            <summary>Converts this rational number to a decimal number and rounds the result
      to the given precision.
    </summary><param name='ctx'>An arithmetic context object to control the precision, rounding, and
      exponent range of the result. If HasFlags of the context is true, will
      also store the flags resulting from the operation (the flags are in
      addition to the pre-existing flags). Can be null, in which case the
      precision is unlimited and no rounding is needed.
    </param><returns>The value of the rational number, rounded to the given precision. Returns
      not-a-number (NaN) if the context is null and the result can't be exact
      because it has a nonterminating decimal expansion.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.ERational.ToExtendedDecimalExactIfPossible(PeterO.Numbers.EContext)">

            <summary>Converts this rational number to a decimal number, but if the result
      would have a nonterminating decimal expansion, rounds that result to the
      given precision.
    </summary><param name='ctx'>An arithmetic context object to control the precision, rounding, and
      exponent range of the result. This context will be used only if the exact
      result would have a nonterminating decimal expansion. If HasFlags of the
      context is true, will also store the flags resulting from the operation
      (the flags are in addition to the pre-existing flags). Can be null, in
      which case the precision is unlimited and no rounding is needed.
    </param><returns>The exact value of the rational number if possible; otherwise, the
      rounded version of the result if a context is given. Returns not-a-number
      (NaN) if the context is null and the result can't be exact because it has
      a nonterminating decimal expansion.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.ERational.ToExtendedFloat">

            <summary>Converts this rational number to a binary float.
    </summary><returns>The exact value of the rational number, or not-a-number (NaN) if the
      result can't be exact because it has a nonterminating binary expansion.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.ERational.ToExtendedFloat(PeterO.Numbers.EContext)">

            <summary>Converts this rational number to a binary float and rounds that result to
      the given precision.
    </summary><param name='ctx'>An arithmetic context object to control the precision, rounding, and
      exponent range of the result. If HasFlags of the context is true, will
      also store the flags resulting from the operation (the flags are in
      addition to the pre-existing flags). Can be null, in which case the
      precision is unlimited and no rounding is needed.
    </param><returns>The value of the rational number, rounded to the given precision. Returns
      not-a-number (NaN) if the context is null and the result can't be exact
      because it has a nonterminating binary expansion.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.ERational.ToExtendedFloatExactIfPossible(PeterO.Numbers.EContext)">

            <summary>Converts this rational number to a binary float, but if the result would
      have a nonterminating binary expansion, rounds that result to the given
      precision.
    </summary><param name='ctx'>An arithmetic context object to control the precision, rounding, and
      exponent range of the result. This context will be used only if the exact
      result would have a nonterminating binary expansion. If HasFlags of the
      context is true, will also store the flags resulting from the operation
      (the flags are in addition to the pre-existing flags). Can be null, in
      which case the precision is unlimited and no rounding is needed.
    </param><returns>The exact value of the rational number if possible; otherwise, the
      rounded version of the result if a context is given. Returns not-a-number
      (NaN) if the context is null and the result can't be exact because it has
      a nonterminating binary expansion.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.ERational.ToInt16Checked">

            <summary>Converts this number's value to a 16-bit signed integer if it can fit in
      a 16-bit signed integer after truncating to an integer.
    </summary><returns>This number's value, truncated to a 16-bit signed integer.
    </returns><exception cref='T:System.OverflowException'>This value is infinity or not-a-number, or the truncated integer is less
      than -32768 or greater than 32767.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.ERational.ToInt16IfExact">

            <summary>Converts this number's value to a 16-bit signed integer if it can fit in
      a 16-bit signed integer without rounding to a different numerical value.
    </summary><returns>This number's value as a 16-bit signed integer.
    </returns><exception cref='T:System.ArithmeticException'>This value is infinity or not-a-number, is not an exact integer, or is
      less than -32768 or greater than 32767.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.ERational.ToInt16Unchecked">

            <summary>Truncates this number's value to an integer and returns the
      least-significant bits of its two's-complement form as a 16-bit signed
      integer.
    </summary><returns>This number, converted to a 16-bit signed integer. Returns 0 if this
      value is infinity or not-a-number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.ERational.ToInt32Checked">

            <summary>Converts this number's value to a 32-bit signed integer if it can fit in
      a 32-bit signed integer after truncating to an integer.
    </summary><returns>This number's value, truncated to a 32-bit signed integer.
    </returns><exception cref='T:System.OverflowException'>This value is infinity or not-a-number, or the truncated integer is less
      than -2147483648 or greater than 2147483647.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.ERational.ToInt32IfExact">

            <summary>Converts this number's value to a 32-bit signed integer if it can fit in
      a 32-bit signed integer without rounding to a different numerical value.
    </summary><returns>This number's value as a 32-bit signed integer.
    </returns><exception cref='T:System.ArithmeticException'>This value is infinity or not-a-number, is not an exact integer, or is
      less than -2147483648 or greater than 2147483647.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.ERational.ToInt32Unchecked">

            <summary>Truncates this number's value to an integer and returns the
      least-significant bits of its two's-complement form as a 32-bit signed
      integer.
    </summary><returns>This number, converted to a 32-bit signed integer. Returns 0 if this
      value is infinity or not-a-number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.ERational.ToInt64Checked">

            <summary>Converts this number's value to a 64-bit signed integer if it can fit in
      a 64-bit signed integer after truncating to an integer.
    </summary><returns>This number's value, truncated to a 64-bit signed integer.
    </returns><exception cref='T:System.OverflowException'>This value is infinity or not-a-number, or the truncated integer is less
      than -9223372036854775808 or greater than 9223372036854775807.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.ERational.ToInt64IfExact">

            <summary>Converts this number's value to a 64-bit signed integer if it can fit in
      a 64-bit signed integer without rounding to a different numerical value.
    </summary><returns>This number's value as a 64-bit signed integer.
    </returns><exception cref='T:System.ArithmeticException'>This value is infinity or not-a-number, is not an exact integer, or is
      less than -9223372036854775808 or greater than 9223372036854775807.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.ERational.ToInt64Unchecked">

            <summary>Truncates this number's value to an integer and returns the
      least-significant bits of its two's-complement form as a 64-bit signed
      integer.
    </summary><returns>This number, converted to a 64-bit signed integer. Returns 0 if this
      value is infinity or not-a-number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.ERational.ToSByteChecked">

            <summary>Converts this number's value to an 8-bit signed integer if it can fit in
      an 8-bit signed integer after truncating to an integer.
    </summary><returns>This number's value, truncated to an 8-bit signed integer.
    </returns><exception cref='T:System.OverflowException'>This value is infinity or not-a-number, or the truncated integer is less
      than -128 or greater than 127.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.ERational.ToSByteIfExact">

            <summary>Converts this number's value to an 8-bit signed integer if it can fit in
      an 8-bit signed integer without rounding to a different numerical value.
    </summary><returns>This number's value as an 8-bit signed integer.
    </returns><exception cref='T:System.ArithmeticException'>This value is infinity or not-a-number, is not an exact integer, or is
      less than -128 or greater than 127.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.ERational.ToSByteUnchecked">

            <summary>Truncates this number's value to an integer and returns the
      least-significant bits of its two's-complement form as an 8-bit signed
      integer.
    </summary><returns>This number, converted to an 8-bit signed integer. Returns 0 if this
      value is infinity or not-a-number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.ERational.ToSingle">

            <summary>Converts this value to a 32-bit binary floating-point number. The
      half-even rounding mode is used.
    </summary><returns>The closest 32-bit binary floating-point number to this value. The return
      value can be positive infinity or negative infinity if this value exceeds
      the range of a 32-bit floating point number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.ERational.ToString">

            <summary>Converts this object to a text string.
    </summary><returns>A string representation of this object. If this object's value is
      infinity or not-a-number, the result is the analogous return value of the
      <c>EDecimal.ToString</c>
       method. Otherwise, the return value has the following form:
      <c>[-]numerator/denominator</c>
       .
    </returns>

</doc>
<doc name="M:PeterO.Numbers.ERational.ToUInt16Checked">

            <summary>Converts this number's value to a 16-bit unsigned integer if it can fit
      in a 16-bit unsigned integer after truncating to an integer.
    </summary><returns>This number's value, truncated to a 16-bit unsigned integer.
    </returns><exception cref='T:System.OverflowException'>This value is infinity or not-a-number, or the truncated integer is less
      than 0 or greater than 65535.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.ERational.ToUInt16IfExact">

            <summary>Converts this number's value to a 16-bit unsigned integer if it can fit
      in a 16-bit unsigned integer without rounding to a different numerical
      value.
    </summary><returns>This number's value as a 16-bit unsigned integer.
    </returns><exception cref='T:System.ArithmeticException'>This value is infinity or not-a-number, is not an exact integer, or is
      less than 0 or greater than 65535.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.ERational.ToUInt16Unchecked">

            <summary>Truncates this number's value to an integer and returns the
      least-significant bits of its two's-complement form as a 16-bit unsigned
      integer.
    </summary><returns>This number, converted to a 16-bit unsigned integer. Returns 0 if this
      value is infinity or not-a-number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.ERational.ToUInt32Checked">

            <summary>Converts this number's value to a 32-bit signed integer if it can fit in
      a 32-bit signed integer after truncating to an integer.
    </summary><returns>This number's value, truncated to a 32-bit signed integer.
    </returns><exception cref='T:System.OverflowException'>This value is infinity or not-a-number, or the truncated integer is less
      than 0 or greater than 4294967295.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.ERational.ToUInt32IfExact">

            <summary>Converts this number's value to a 32-bit signed integer if it can fit in
      a 32-bit signed integer without rounding to a different numerical value.
    </summary><returns>This number's value as a 32-bit signed integer.
    </returns><exception cref='T:System.ArithmeticException'>This value is infinity or not-a-number, is not an exact integer, or is
      less than 0 or greater than 4294967295.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.ERational.ToUInt32Unchecked">

            <summary>Truncates this number's value to an integer and returns the
      least-significant bits of its two's-complement form as a 32-bit signed
      integer.
    </summary><returns>This number, converted to a 32-bit signed integer. Returns 0 if this
      value is infinity or not-a-number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.ERational.ToUInt64Checked">

            <summary>Converts this number's value to a 64-bit unsigned integer if it can fit
      in a 64-bit unsigned integer after truncating to an integer.
    </summary><returns>This number's value, truncated to a 64-bit unsigned integer.
    </returns><exception cref='T:System.OverflowException'>This value is infinity or not-a-number, or the truncated integer is less
      than 0 or greater than 18446744073709551615.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.ERational.ToUInt64IfExact">

            <summary>Converts this number's value to a 64-bit unsigned integer if it can fit
      in a 64-bit unsigned integer without rounding to a different numerical
      value.
    </summary><returns>This number's value as a 64-bit unsigned integer.
    </returns><exception cref='T:System.ArithmeticException'>This value is infinity or not-a-number, is not an exact integer, or is
      less than 0 or greater than 18446744073709551615.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.ERational.ToUInt64Unchecked">

            <summary>Truncates this number's value to an integer and returns the
      least-significant bits of its two's-complement form as a 64-bit unsigned
      integer.
    </summary><returns>This number, converted to a 64-bit unsigned integer. Returns 0 if this
      value is infinity or not-a-number.
    </returns>

</doc>
<doc name="P:PeterO.Numbers.ERational.UnsignedNumerator">

            <summary>Gets this object's numerator with the sign removed.
    </summary><value>This object's numerator. If this object is a not-a-number value, returns
      the diagnostic information.
    </value>

</doc>
<doc name="F:PeterO.Numbers.ERational.Zero">

            <summary>A rational number for zero.
    </summary>

</doc>
<doc name="M:PeterO.Numbers.ERational.op_Addition(PeterO.Numbers.ERational,PeterO.Numbers.ERational)">

            <summary>Adds two rational numbers.
    </summary><param name='bthis'>The first operand.
    </param><param name='augend'>The second operand.
    </param><returns>The sum of the two numbers. Returns not-a-number (NaN) if either operand
      is NaN.
    </returns><exception cref='T:System.ArgumentNullException'>The parameter "otherValue" is null.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.ERational.op_Division(PeterO.Numbers.ERational,PeterO.Numbers.ERational)">

            <summary>Divides an arbitrary-precision rational number by the value of another
      arbitrary-precision rational number object.
    </summary><param name='dividend'>An arbitrary-precision rational number serving as the dividend.
    </param><param name='divisor'>An arbitrary-precision rational number serving as the divisor.
    </param><returns>The quotient of the two objects.
    </returns><exception cref='T:System.ArgumentNullException'>The parameter "otherValue" is null.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.ERational.op_Explicit(PeterO.Numbers.ERational)~PeterO.Numbers.EInteger">

            <summary>Converts an arbitrary-precision rational number to an arbitrary-precision
      integer. Any fractional part in the value will be discarded when
      converting to an arbitrary-precision integer.
    </summary><param name='bigValue'>An arbitrary-precision rational number.
    </param><returns>An arbitrary-precision integer.
    </returns><exception cref='T:System.OverflowException'>This object's value is infinity or not-a-number (NaN).
    </exception>

</doc>
<doc name="M:PeterO.Numbers.ERational.op_Explicit(PeterO.Numbers.ERational)~System.Byte">

            <summary>Converts an arbitrary-precision rational number to a byte (from 0 to 255)
      if it can fit in a byte (from 0 to 255) after truncating to an integer.
    </summary><param name='input'>The number to convert as an arbitrary-precision rational number.
    </param><returns>The value of
      <paramref name='input'/>
       , truncated to a byte (from 0 to 255).
    </returns><exception cref='T:System.OverflowException'>The parameter
      <paramref name='input'/>
       is infinity or not-a-number, or the truncated integer is less than 0 or
      greater than 255.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.ERational.op_Explicit(PeterO.Numbers.ERational)~System.Decimal">

            <summary>Converts an arbitrary-precision rational number to a
      <c>decimal</c>
       under the Common Language Infrastructure (see
      <see cref='T:PeterO.Numbers.EDecimal'>
         "Forms of numbers"
      </see>
       ).
    </summary><param name='extendedNumber'>The number to convert as an arbitrary-precision rational number.
    </param><returns>A
      <c>decimal</c>
       under the Common Language Infrastructure (usually a .NET Framework
      decimal).
    </returns>

</doc>
<doc name="M:PeterO.Numbers.ERational.op_Explicit(PeterO.Numbers.ERational)~System.Double">

            <summary>Converts an arbitrary-precision rational number to a 64-bit
      floating-point number. The half-even rounding mode is used.
    </summary><param name='bigValue'>The number to convert as an arbitrary-precision rational number.
    </param><returns>The closest 64-bit floating-point number to this value. The return value
      can be positive infinity or negative infinity if this value exceeds the
      range of a 64-bit floating point number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.ERational.op_Explicit(PeterO.Numbers.ERational)~System.Int16">

            <summary>Converts an arbitrary-precision rational number to a 16-bit signed
      integer if it can fit in a 16-bit signed integer after truncating to an
      integer.
    </summary><param name='input'>The number to convert as an arbitrary-precision rational number.
    </param><returns>The value of
      <paramref name='input'/>
       , truncated to a 16-bit signed integer.
    </returns><exception cref='T:System.OverflowException'>The parameter
      <paramref name='input'/>
       is infinity or not-a-number, or the truncated integer is less than -32768
      or greater than 32767.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.ERational.op_Explicit(PeterO.Numbers.ERational)~System.Int32">

            <summary>Converts an arbitrary-precision rational number to a 32-bit signed
      integer if it can fit in a 32-bit signed integer after truncating to an
      integer.
    </summary><param name='input'>The number to convert as an arbitrary-precision rational number.
    </param><returns>The value of
      <paramref name='input'/>
       , truncated to a 32-bit signed integer.
    </returns><exception cref='T:System.OverflowException'>The parameter
      <paramref name='input'/>
       is infinity or not-a-number, or the truncated integer is less than
      -2147483648 or greater than 2147483647.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.ERational.op_Explicit(PeterO.Numbers.ERational)~System.Int64">

            <summary>Converts an arbitrary-precision rational number to a 64-bit signed
      integer if it can fit in a 64-bit signed integer after truncating to an
      integer.
    </summary><param name='input'>The number to convert as an arbitrary-precision rational number.
    </param><returns>The value of
      <paramref name='input'/>
       , truncated to a 64-bit signed integer.
    </returns><exception cref='T:System.OverflowException'>The parameter
      <paramref name='input'/>
       is infinity or not-a-number, or the truncated integer is less than
      -9223372036854775808 or greater than 9223372036854775807.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.ERational.op_Explicit(PeterO.Numbers.ERational)~System.SByte">

            <summary>Converts an arbitrary-precision rational number to an 8-bit signed
      integer if it can fit in an 8-bit signed integer after truncating to an
      integer.
    </summary><param name='input'>The number to convert as an arbitrary-precision rational number.
    </param><returns>The value of
      <paramref name='input'/>
       , truncated to an 8-bit signed integer.
    </returns><exception cref='T:System.OverflowException'>The parameter
      <paramref name='input'/>
       is infinity or not-a-number, or the truncated integer is less than -128
      or greater than 127.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.ERational.op_Explicit(PeterO.Numbers.ERational)~System.Single">

            <summary>Converts an arbitrary-precision rational number to a 32-bit binary
      floating-point number. The half-even rounding mode is used.
    </summary><param name='bigValue'>The number to convert as an arbitrary-precision rational number.
    </param><returns>The closest 32-bit binary floating-point number to this value. The return
      value can be positive infinity or negative infinity if this value exceeds
      the range of a 32-bit floating point number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.ERational.op_Explicit(PeterO.Numbers.ERational)~System.UInt16">

            <summary>Converts an arbitrary-precision rational number to a 16-bit unsigned
      integer if it can fit in a 16-bit unsigned integer after truncating to an
      integer.
    </summary><param name='input'>The number to convert as an arbitrary-precision rational number.
    </param><returns>The value of
      <paramref name='input'/>
       , truncated to a 16-bit unsigned integer.
    </returns><exception cref='T:System.OverflowException'>The parameter
      <paramref name='input'/>
       is infinity or not-a-number, or the truncated integer is less than 0 or
      greater than 65535.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.ERational.op_Explicit(PeterO.Numbers.ERational)~System.UInt32">

            <summary>Converts an arbitrary-precision rational number to a 32-bit signed
      integer if it can fit in a 32-bit signed integer after truncating to an
      integer.
    </summary><param name='input'>The number to convert as an arbitrary-precision rational number.
    </param><returns>The value of
      <paramref name='input'/>
       , truncated to a 32-bit signed integer.
    </returns><exception cref='T:System.OverflowException'>The parameter
      <paramref name='input'/>
       is infinity or not-a-number, or the truncated integer is less than 0 or
      greater than 4294967295.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.ERational.op_Explicit(PeterO.Numbers.ERational)~System.UInt64">

            <summary>Converts an arbitrary-precision rational number to a 64-bit unsigned
      integer if it can fit in a 64-bit unsigned integer after truncating to an
      integer.
    </summary><param name='input'>The number to convert as an arbitrary-precision rational number.
    </param><returns>The value of
      <paramref name='input'/>
       , truncated to a 64-bit unsigned integer.
    </returns><exception cref='T:System.OverflowException'>The parameter
      <paramref name='input'/>
       is infinity or not-a-number, or the truncated integer is less than 0 or
      greater than 18446744073709551615.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.ERational.op_Implicit(PeterO.Numbers.EDecimal)~PeterO.Numbers.ERational">

            <summary>Converts an arbitrary-precision decimal floating-point number to an
      arbitrary-precision rational number.
    </summary><param name='eint'>The parameter
      <paramref name='eint'/>
       is an arbitrary-precision decimal floating-point number.
    </param><returns>An arbitrary-precision rational number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.ERational.op_Implicit(PeterO.Numbers.EFloat)~PeterO.Numbers.ERational">

            <summary>Converts an arbitrary-precision binary float to an arbitrary-precision
      rational number.
    </summary><param name='eint'>An arbitrary-precision binary float.
    </param><returns>An arbitrary-precision rational number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.ERational.op_Implicit(PeterO.Numbers.EInteger)~PeterO.Numbers.ERational">

            <summary>Converts an arbitrary-precision integer to an arbitrary-precision
      rational number.
    </summary><param name='eint'>An arbitrary-precision integer.
    </param><returns>An arbitrary-precision rational number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.ERational.op_Implicit(System.Byte)~PeterO.Numbers.ERational">

            <summary>Converts a byte (from 0 to 255) to an arbitrary-precision rational
      number.
    </summary><param name='inputByte'>The number to convert as a byte (from 0 to 255).
    </param><returns>The value of
      <paramref name='inputByte'/>
       as an arbitrary-precision rational number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.ERational.op_Implicit(System.Decimal)~PeterO.Numbers.ERational">

            <summary>Converts a
      <c>decimal</c>
       under the Common Language Infrastructure (usually a .NET Framework
      decimal). to an arbitrary-precision rational number.
    </summary><param name='eint'>A
      <c>decimal</c>
       under the Common Language Infrastructure (usually a .NET Framework
      decimal).
    </param><returns>An arbitrary-precision rational number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.ERational.op_Implicit(System.Double)~PeterO.Numbers.ERational">

            <summary>Converts a 64-bit floating-point number to an arbitrary-precision
      rational number.
    </summary><param name='eint'>The parameter
      <paramref name='eint'/>
       is a 64-bit floating-point number.
    </param><returns>An arbitrary-precision rational number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.ERational.op_Implicit(System.Int16)~PeterO.Numbers.ERational">

            <summary>Converts a 16-bit signed integer to an arbitrary-precision rational
      number.
    </summary><param name='inputInt16'>The number to convert as a 16-bit signed integer.
    </param><returns>The value of
      <paramref name='inputInt16'/>
       as an arbitrary-precision rational number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.ERational.op_Implicit(System.Int32)~PeterO.Numbers.ERational">

            <summary>Converts a 32-bit signed integer to an arbitrary-precision rational
      number.
    </summary><param name='inputInt32'>The number to convert as a 32-bit signed integer.
    </param><returns>The value of
      <paramref name='inputInt32'/>
       as an arbitrary-precision rational number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.ERational.op_Implicit(System.Int64)~PeterO.Numbers.ERational">

            <summary>Converts a 64-bit signed integer to an arbitrary-precision rational
      number.
    </summary><param name='inputInt64'>The number to convert as a 64-bit signed integer.
    </param><returns>The value of
      <paramref name='inputInt64'/>
       as an arbitrary-precision rational number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.ERational.op_Implicit(System.SByte)~PeterO.Numbers.ERational">

            <summary>Converts an 8-bit signed integer to an arbitrary-precision rational
      number.
    </summary><param name='inputSByte'>The number to convert as an 8-bit signed integer.
    </param><returns>The value of
      <paramref name='inputSByte'/>
       as an arbitrary-precision rational number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.ERational.op_Implicit(System.Single)~PeterO.Numbers.ERational">

            <summary>Converts a 32-bit binary floating-point number to a rational number.
    </summary><param name='eint'>The parameter
      <paramref name='eint'/>
       is a 32-bit binary floating-point number.
    </param><returns>The value of
      <paramref name='eint'/>
       as an arbitrary-precision rational number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.ERational.op_Implicit(System.UInt16)~PeterO.Numbers.ERational">

            <summary>Converts a 16-bit unsigned integer to an arbitrary-precision rational
      number.
    </summary><param name='inputUInt16'>The number to convert as a 16-bit unsigned integer.
    </param><returns>The value of
      <paramref name='inputUInt16'/>
       as an arbitrary-precision rational number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.ERational.op_Implicit(System.UInt32)~PeterO.Numbers.ERational">

            <summary>Converts a 32-bit signed integer to an arbitrary-precision rational
      number.
    </summary><param name='inputUInt32'>The number to convert as a 32-bit signed integer.
    </param><returns>The value of
      <paramref name='inputUInt32'/>
       as an arbitrary-precision rational number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.ERational.op_Implicit(System.UInt64)~PeterO.Numbers.ERational">

            <summary>Converts a 64-bit unsigned integer to an arbitrary-precision rational
      number.
    </summary><param name='inputUInt64'>The number to convert as a 64-bit unsigned integer.
    </param><returns>The value of
      <paramref name='inputUInt64'/>
       as an arbitrary-precision rational number.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.ERational.op_Modulus(PeterO.Numbers.ERational,PeterO.Numbers.ERational)">

            <summary>Finds the remainder that results when this instance is divided by the
      value of an arbitrary-precision rational number.
    </summary><param name='dividend'>The dividend.
    </param><param name='divisor'>The divisor.
    </param><returns>The remainder of the two numbers.
    </returns><exception cref='T:System.ArgumentNullException'>The parameter "otherValue" is null.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.ERational.op_Multiply(PeterO.Numbers.ERational,PeterO.Numbers.ERational)">

            <summary>Multiplies this instance by the value of an arbitrary-precision rational
      number.
    </summary><param name='operand1'>The first operand.
    </param><param name='operand2'>The second operand.
    </param><returns>The product of the two numbers.
    </returns><exception cref='T:System.ArgumentNullException'>The parameter "otherValue" is null.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.ERational.op_Subtraction(PeterO.Numbers.ERational,PeterO.Numbers.ERational)">

            <summary>Subtracts an arbitrary-precision rational number from this instance.
    </summary><param name='bthis'>The first operand.
    </param><param name='subtrahend'>The second operand.
    </param><returns>The difference of the two objects.
    </returns><exception cref='T:System.ArgumentNullException'>The parameter "otherValue" is null.
    </exception>

</doc>
<doc name="M:PeterO.Numbers.ERational.op_UnaryNegation(PeterO.Numbers.ERational)">

            <summary>Returns an arbitrary-precision rational number with the same value as the
      given one but with its sign reversed.
    </summary><param name='bigValue'>An arbitrary-precision rational number to negate.
    </param><returns>An arbitrary-precision rational number.
    </returns><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='bigValue'/>
       is null.
    </exception>

</doc>
<doc name="T:PeterO.Numbers.ERounding">

            <summary>Specifies the mode to use when "shortening" numbers that otherwise can't
      fit a given number of digits, so that the shortened number has about the
      same value. This "shortening" is known as rounding. (The "E" stands for
      "extended", and has this prefix to group it with the other classes common
      to this library, particularly EDecimal, EFloat, and ERational.).
    </summary>

</doc>
<doc name="F:PeterO.Numbers.ERounding.Ceiling">

            <summary>If there is a fractional part, the number is rounded to the highest
      representable number that's closest to it.
    </summary>

</doc>
<doc name="F:PeterO.Numbers.ERounding.Down">

            <summary>The fractional part is discarded (the number is truncated).
    </summary>

</doc>
<doc name="F:PeterO.Numbers.ERounding.Floor">

            <summary>If there is a fractional part, the number is rounded to the lowest
      representable number that's closest to it.
    </summary>

</doc>
<doc name="F:PeterO.Numbers.ERounding.HalfDown">

            <summary>Rounded to the nearest number; if the fractional part is exactly half, it
      is discarded.
    </summary>

</doc>
<doc name="F:PeterO.Numbers.ERounding.HalfEven">

            <summary>Rounded to the nearest number; if the fractional part is exactly half,
      the number is rounded to the closest representable number that is even.
      This is sometimes also known as "banker's rounding".
    </summary>

</doc>
<doc name="F:PeterO.Numbers.ERounding.HalfUp">

            <summary>Rounded to the nearest number; if the fractional part is exactly half,
      the number is rounded to the closest representable number away from zero.
      This is the most familiar rounding mode for many people.
    </summary>

</doc>
<doc name="F:PeterO.Numbers.ERounding.None">

            <summary>Indicates that rounding will not be used. If rounding is required, the
      rounding operation will report an error.
    </summary>

</doc>
<doc name="F:PeterO.Numbers.ERounding.Odd">

            <summary>If there is a fractional part and the whole number part is even, the
      number is rounded to the closest representable odd number away from zero.
    </summary>

</doc>
<doc name="F:PeterO.Numbers.ERounding.OddOrZeroFiveUp">

            <summary>For binary floating point numbers, this is the same as Odd. For other
      bases (including decimal numbers), this is the same as ZeroFiveUp. This
      rounding mode is useful for rounding intermediate results at a slightly
      higher precision (at least 2 bits more for binary) than the final
      precision.
    </summary>

</doc>
<doc name="F:PeterO.Numbers.ERounding.Up">

            <summary>If there is a fractional part, the number is rounded to the closest
      representable number away from zero.
    </summary>

</doc>
<doc name="F:PeterO.Numbers.ERounding.ZeroFiveUp">

            <summary>If there is a fractional part and if the last digit before rounding is 0
      or half the radix, the number is rounded to the closest representable
      number away from zero; otherwise the fractional part is discarded. In
      overflow, the fractional part is always discarded.
    </summary>

</doc>
<doc name="T:PeterO.Numbers.ETrapException">

            <summary>Exception thrown for arithmetic trap errors. (The "E" stands for
      "extended", and has this prefix to group it with the other classes common
      to this library, particularly EDecimal, EFloat, and ERational.).
    </summary>

</doc>
<doc name="M:PeterO.Numbers.ETrapException.#ctor(System.Int32,PeterO.Numbers.EContext,System.Object)">

            <summary>Initializes a new instance of the <see cref='T:PeterO.Numbers.ETrapException'/> class.
    </summary><param name='flag'>A flag that specifies the kind of error (
      <c>EContext.FlagXXYY</c>
       ). This will only be one flag, such as
      <c>FlagInexact</c>
       or FlagSubnormal.
    </param><param name='ctx'>A context object for arbitrary-precision arithmetic settings.
    </param><param name='result'>The parameter
      <paramref name='result'/>
       is an arbitrary object.
    </param>

</doc>
<doc name="P:PeterO.Numbers.ETrapException.Context">

            <summary>Gets the arithmetic context used during the operation that triggered the
      trap. May be null.
    </summary><value>The arithmetic context used during the operation that triggered the trap.
      May be null.
    </value>

</doc>
<doc name="P:PeterO.Numbers.ETrapException.Error">

            <summary>Gets the flag that specifies the kind of error (EContext.FlagXXX). This
      will only be one flag, such as
      <c>FlagInexact</c>
       or FlagSubnormal.
    </summary><value>The flag that specifies the kind of error (EContext.FlagXXX). This will
      only be one flag, such as.
      <c>FlagInexact</c>
       or FlagSubnormal.
    </value>

</doc>
<doc name="P:PeterO.Numbers.ETrapException.Result">

            <summary>Gets the defined result of the operation that caused the trap.
    </summary><value>The defined result of the operation that caused the trap.
    </value>

</doc>
<doc name="M:PeterO.Numbers.FastInteger.AddBig(PeterO.Numbers.EInteger)">

            <summary>This is an internal API.
    </summary><param name='bigintVal'>The parameter
      <paramref name='bigintVal'/>
       is an internal value.
    </param><returns>A FastInteger object.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.FastInteger.Multiply(System.Int32)">

            <summary>This is an internal API.
    </summary><param name='val'>The parameter
      <paramref name='val'/>
       is an internal value.
    </param><returns>A FastInteger object.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.FastInteger.Negate">

            <summary>This is an internal API.
    </summary><returns>A FastInteger object.
    </returns>

</doc>
<doc name="P:PeterO.Numbers.FastInteger.Sign">

            <summary>Gets an internal value.
    </summary><value>An internal value.
    </value>

</doc>
<doc name="M:PeterO.Numbers.FastInteger.Subtract(PeterO.Numbers.FastInteger)">

            <summary>This is an internal API.
    </summary><param name='val'>The parameter
      <paramref name='val'/>
       is an internal value.
    </param><returns>A FastInteger object.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.FastInteger.SubtractBig(PeterO.Numbers.EInteger)">

            <summary>This is an internal API.
    </summary><param name='bigintVal'>The parameter
      <paramref name='bigintVal'/>
       is an internal value.
    </param><returns>A FastInteger object.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.FastInteger.SubtractInt(System.Int32)">

            <summary>This is an internal API.
    </summary><param name='val'>The parameter
      <paramref name='val'/>
       is an internal value.
    </param><returns>A FastInteger object.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.FastInteger.ToString">

            <summary>This is an internal API.
    </summary><returns>A text string.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.FastIntegerFixed.Negate">

            <summary>This is an internal API.
    </summary><returns>A FastIntegerFixed object.
    </returns>

</doc>
<doc name="M:PeterO.Numbers.FastIntegerFixed.ToString">

            <summary>This is an internal API.
    </summary><returns>A text string.
    </returns>

</doc>
<doc name="T:PeterO.Numbers.IShiftAccumulator">

            <summary>Common interface for classes that shift a number of digits and record
      information on whether a non-zero digit was discarded this way.
    </summary>

</doc>
<doc name="T:PeterO.Numbers.RadixMath`1">

            <summary>Encapsulates radix-independent arithmetic.
    </summary><typeparam name='T'>
       Data type for a numeric value in a particular radix.
    </typeparam>

</doc>
<doc name="T:PeterO.Rdf.URIUtility">
<summary>Contains utility methods for processing Uniform Resource Identifiers
      (URIs) and Internationalized Resource Identifiers (IRIs) under RFC3986 and
      RFC3987, respectively. In the following documentation, URIs and IRIs
      include URI references and IRI references, for convenience.
    </summary>
</doc>
<doc name="T:PeterO.Rdf.URIUtility.ParseMode">
<summary>Specifies whether certain characters are allowed when parsing IRIs and
      URIs.
    </summary>
</doc>
<doc name="F:PeterO.Rdf.URIUtility.ParseMode.IRILenient">
<summary>The rules only check for the appropriate delimiters when splitting the
      path, without checking if all the characters in each component are valid.
      Even with this mode, strings with unpaired surrogate code points are
      considered invalid.
    </summary>
</doc>
<doc name="F:PeterO.Rdf.URIUtility.ParseMode.IRIStrict">
<summary>The rules follow the syntax for parsing IRIs. In particular, many code
      points outside the Basic Latin range (U+0000 to U+007F) are allowed.
      Strings with unpaired surrogate code points are considered invalid.
    </summary>
</doc>
<doc name="F:PeterO.Rdf.URIUtility.ParseMode.IRISurrogateLenient">
<summary>The rules only check for the appropriate delimiters when splitting the
      path, without checking if all the characters in each component are valid.
      Unpaired surrogate code points are treated as though they were replacement
      characters instead for the purposes of these rules, so that strings with
      those code points are not considered invalid strings.
    </summary>
</doc>
<doc name="F:PeterO.Rdf.URIUtility.ParseMode.URILenient">
<summary>The rules only check for the appropriate delimiters when splitting the
      path, without checking if all the characters in each component are valid.
      Code points outside the Basic Latin range (U+0000 to U+007F) are not
      allowed.
    </summary>
</doc>
<doc name="F:PeterO.Rdf.URIUtility.ParseMode.URIStrict">
<summary>The rules follow the syntax for parsing IRIs, except that code points
      outside the Basic Latin range (U+0000 to U+007F) are not allowed.
    </summary>
</doc>
<doc name="M:PeterO.Rdf.URIUtility.escapeURI(System.String,System.Int32)">
<returns>A string possibly containing escaped characters, or null if s is null.
    </returns>
    <summary>Escapes characters that cannot appear in URIs or IRIs. The function is
      idempotent; that is, calling the function again on the result with the
      same mode doesn't change the result.
    </summary>
    <param name='s'>A string to escape.
    </param>
    <param name='mode'>The parameter
      <paramref name='mode'/>
       is a 32-bit signed integer.
    </param>
</doc>
<doc name="M:PeterO.Rdf.URIUtility.hasScheme(System.String)">
<summary>Determines whether the string is a valid IRI with a scheme component. This
      can be used to check for relative IRI references.
      <para>The following cases return true:
      </para>
      <code>xx-x:mm example:/ww
      </code>
       The following cases return false:
      <code>x@y:/z /x/y/z example.xyz
      </code>
    </summary>
    <param name='refValue'>A string representing an IRI to check.
    </param>
    <returns><c>true</c>
       if the string is a valid IRI with a scheme component; otherwise, <c>false</c>
       .
    </returns>
</doc>
<doc name="M:PeterO.Rdf.URIUtility.hasSchemeForURI(System.String)">
<summary>Determines whether the string is a valid URI with a scheme component. This
      can be used to check for relative URI references. The following cases
      return true:
      <code>http://example/z xx-x:mm example:/ww
      </code>
       The following cases return false:
      <code>x@y:/z /x/y/z example.xyz
      </code>
    </summary>
    <param name='refValue'>A string representing an IRI to check.
    </param>
    <returns><c>true</c>
       if the string is a valid URI with a scheme component; otherwise, <c>false</c>
       .
    </returns>
</doc>
<doc name="M:PeterO.Rdf.URIUtility.isValidCurieReference(System.String,System.Int32,System.Int32)">
<summary>Determines whether the substring is a valid CURIE reference under RDFA
      1.1. (The CURIE reference is the part after the colon.).
    </summary>
    <param name='s'>A string containing a CURIE reference. Can be null.
    </param>
    <param name='offset'>A zero-based index showing where the desired portion of "s" begins.
    </param>
    <param name='length'>The number of elements in the desired portion of "s" (but not more than
      "s" 's length).
    </param>
    <returns><c>true</c>
       if the substring is a valid CURIE reference under RDFA 1; otherwise, <c>false</c>
       . Returns false if
      <paramref name='s'/>
       is null.
    </returns>
    <exception cref='T:System.ArgumentException'>Either
      <paramref name='offset'/>
       or
      <paramref name='length'/>
       is less than 0 or greater than
      <paramref name='s'/>
       's length, or
      <paramref name='s'/>
       's length minus
      <paramref name='offset'/>
       is less than
      <paramref name='length'/>
       .
    </exception>
</doc>
<doc name="M:PeterO.Rdf.URIUtility.relativeResolve(System.String,System.String)">
<summary>Resolves a URI or IRI relative to another URI or IRI.
    </summary>
    <param name='refValue'>A string representing a URI or IRI reference. Example:
      <c>dir/file.txt</c>
       .
    </param>
    <param name='baseURI'>A string representing an absolute URI reference. Example:
      <c>http://example.com/my/path/</c>
       .
    </param>
    <returns>The resolved IRI, or null if
      <paramref name='refValue'/>
       is null or is not a valid IRI. If base is null or is not a valid IRI,
      returns refValue. Example: http://example.com/my/path/dir/file.txt.
    </returns>
</doc>
<doc name="M:PeterO.Rdf.URIUtility.relativeResolve(System.String,System.String,PeterO.Rdf.URIUtility.ParseMode)">
<summary>Resolves a URI or IRI relative to another URI or IRI.
    </summary>
    <param name='refValue'>A string representing a URI or IRI reference. Example:
      <c>dir/file.txt</c>
       .
    </param>
    <param name='baseURI'>A string representing an absolute URI reference. Example:
      <c>http://example.com/my/path/</c>
       .
    </param>
    <param name='parseMode'>Parse mode that specifies whether certain characters are allowed when
      parsing IRIs and URIs.
    </param>
    <returns>The resolved IRI, or null if
      <paramref name='refValue'/>
       is null or is not a valid IRI. If base is null or is not a valid IRI,
      returns refValue.
    </returns>
</doc>
<doc name="M:PeterO.Rdf.URIUtility.splitIRI(System.String)">
<summary>Parses an Internationalized Resource Identifier (IRI) reference under
      RFC3987. If the IRI reference is syntactically valid, splits the string
      into its components and returns an array containing the indices into the
      components.
      <returns>If the string is a valid IRI reference, returns an array of 10 integers.
        Each of the five pairs corresponds to the start and end index of the
        IRI's scheme, authority, path, query, or fragment component,
        respectively. If a component is absent, both indices in that pair will
        be -1. If the string is null or is not a valid IRI, returns null.
      </returns>
    </summary>
    <param name='s'>A string that contains an IRI.
    </param>
</doc>
<doc name="M:PeterO.Rdf.URIUtility.splitIRI(System.String,PeterO.Rdf.URIUtility.ParseMode)">
<summary>Parses an Internationalized Resource Identifier (IRI) reference under
      RFC3987. If the IRI is syntactically valid, splits the string into its
      components and returns an array containing the indices into the
      components.
    </summary>
    <param name='s'>A string representing an IRI. Can be null.
    </param>
    <param name='parseMode'>The parameter
      <paramref name='parseMode'/>
       is a ParseMode object.
    </param>
    <returns>If the string is a valid IRI reference, returns an array of 10 integers.
      Each of the five pairs corresponds to the start and end index of the IRI's
      scheme, authority, path, query, or fragment component, respectively. If a
      component is absent, both indices in that pair will be -1. If the string
      is null or is not a valid IRI, returns null.
    </returns>
</doc>
<doc name="M:PeterO.Rdf.URIUtility.splitIRI(System.String,System.Int32,System.Int32,PeterO.Rdf.URIUtility.ParseMode)">
<summary>Parses a substring that represents an Internationalized Resource
      Identifier (IRI) under RFC3987. If the IRI is syntactically valid, splits
      the string into its components and returns an array containing the indices
      into the components.
    </summary>
    <param name='s'>A string that contains an IRI.
    </param>
    <param name='offset'>A zero-based index showing where the desired portion of "s" begins.
    </param>
    <param name='length'>The length of the desired portion of "s" (but not more than "s" 's
      length).
    </param>
    <param name='parseMode'>Parse mode that specifies whether certain characters are allowed when
      parsing IRIs and URIs.
    </param>
    <returns>If the string is a valid IRI, returns an array of 10 integers. Each of the
      five pairs corresponds to the start and end index of the IRI's scheme,
      authority, path, query, or fragment component, respectively. If a
      component is absent, both indices in that pair will be -1 (an index won't
      be less than 0 in any other case). If the string is null or is not a valid
      IRI, returns null.
    </returns>
    <exception cref='T:System.ArgumentException'>Either
      <paramref name='offset'/>
       or
      <paramref name='length'/>
       is less than 0 or greater than
      <paramref name='s'/>
       's length, or
      <paramref name='s'/>
       's length minus
      <paramref name='offset'/>
       is less than
      <paramref name='length'/>
       .
    </exception>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='s'/>
       is null.
    </exception>
</doc>
</docs>
